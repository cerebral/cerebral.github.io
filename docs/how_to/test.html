<!DOCTYPE html>
<html>
  <head>
    <title>Cerebral Docs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
<link rel="stylesheet" href="/main.css" />
<link rel="stylesheet" href="/prism.css" />
<link rel="stylesheet" href="/docs.css" />
  </head>
  <body>
    <div id="app"><div class="docs-container"><div id="navigation" class="docs-navigation"><ul class="docs-navigation-menu"><li class="docs-navigation-item"><a href="/docs/get_started">get started</a><div class="underline"></div></li><li class="docs-navigation-item"><a href="/docs/tutorial">tutorial</a><div class="underline"></div></li><li class="docs-navigation-item active"><a href="/docs/how_to">how to</a><div class="underline"></div></li><li class="docs-navigation-item"><a href="/docs/migration">migration</a><div class="underline"></div></li><li class="docs-navigation-item"><a href="/docs/api">api</a><div class="underline"></div></li></ul><div class="docs-search"><input type="text" id="search-docs" placeholder="search..."/><div id="search-result" class="docs-search-result"></div></div><div class="docs-icons"><a href="https://github.com/cerebral/cerebral" class="docs-icon" target="_new"><div class="docs-icon-github"></div>github repo</a><a href="https://discord.gg/0kIweV4bd2bwwsvH" class="docs-icon" target="_new"><div class="docs-icon-discord"></div>chat</a></div></div><div id="navigation-mobile" class="docs-navigation mobile"><div id="hamburger" class="docs-navigation-hamburger">â˜°</div><div class="docs-navigation-title mobile">how to</div><div class="docs-navigation-float mobile"><ul class="docs-navigation-menu mobile"><li class="docs-navigation-item mobile"><a href="/docs/get_started">get started</a></li><li class="docs-navigation-item mobile"><a href="/docs/tutorial">tutorial</a></li><li class="docs-navigation-item active mobile"><a href="/docs/how_to">how to</a><div class="docs-toc"><div class="docs-toc-content"><div><strong>Table of contents</strong></div><ul><li><a href="/docs/how_to/index.html">Define state</a></li><li><a href="/docs/how_to/signals.html">Run signals</a></li><li><a href="/docs/how_to/actions.html">Create actions</a></li><li><a href="/docs/how_to/chains_and_paths.html">Use chains and paths</a></li><li><a href="/docs/how_to/providers.html">Add providers</a></li><li><a href="/docs/how_to/factories.html">Create factories</a></li><li><a href="/docs/how_to/connect.html">Connect components</a></li><li><a href="/docs/how_to/compute.html">Compute values</a></li><li><a href="/docs/how_to/organize.html">Organize</a></li><li class="active"><a href="/docs/how_to/test.html">Test</a><ul><li><a href="#components">Components</a></li><li><a href="#computes">Computes</a><ul><li><a href="#example">Example</a></li></ul></li><li><a href="#actions">Actions</a><ul><li><a href="#example">Example</a></li></ul></li><li><a href="#signals">Signals</a><ul><li><a href="#runsignal">runSignal</a><ul><li><a href="#example">Example</a></li></ul></li><li><a href="#runsignal-factory">RunSignal factory</a><ul><li><a href="#example">Example</a></li></ul></li></ul></li></ul></li></ul></div></div></li><li class="docs-navigation-item mobile"><a href="/docs/migration">migration</a></li><li class="docs-navigation-item mobile"><a href="/docs/api">api</a></li></ul></div></div><div class="docs-content"><div class="docs-toc"><div class="docs-toc-content"><div><strong>Table of contents</strong></div><ul><li><a href="/docs/how_to/index.html">Define state</a></li><li><a href="/docs/how_to/signals.html">Run signals</a></li><li><a href="/docs/how_to/actions.html">Create actions</a></li><li><a href="/docs/how_to/chains_and_paths.html">Use chains and paths</a></li><li><a href="/docs/how_to/providers.html">Add providers</a></li><li><a href="/docs/how_to/factories.html">Create factories</a></li><li><a href="/docs/how_to/connect.html">Connect components</a></li><li><a href="/docs/how_to/compute.html">Compute values</a></li><li><a href="/docs/how_to/organize.html">Organize</a></li><li class="active"><a href="/docs/how_to/test.html">Test</a><ul><li><a href="#components">Components</a></li><li><a href="#computes">Computes</a><ul><li><a href="#example">Example</a></li></ul></li><li><a href="#actions">Actions</a><ul><li><a href="#example">Example</a></li></ul></li><li><a href="#signals">Signals</a><ul><li><a href="#runsignal">runSignal</a><ul><li><a href="#example">Example</a></li></ul></li><li><a href="#runsignal-factory">RunSignal factory</a><ul><li><a href="#example">Example</a></li></ul></li></ul></li></ul></li></ul></div></div><div class="docs-doc"><div class="docs-doc-content"><div class="docs-doc-edit"><a href="https://github.com/cerebral/cerebral/tree/master/docs/docs/docs/how_to/test.md" target="_new">Edit on Github</a></div><h1 id="test">Test</h1><p>Cerebral makes it easy to test your application components and business logic.</p><h2 id="components">Components</h2><p>The <strong>Container</strong> you use to expose Cerebral to your components can also be used when testing, but you can also use the <strong>StateContainer</strong> which allows you to pass state down to your components as if it was extracted from the Cerebral controller.</p><pre><code class="language-js">import React from &#x27;react&#x27;
import {mount} from &#x27;enzyme&#x27;
import {StateContainer} from &#x27;cerebral/react&#x27;

import Foo from &#x27;./Foo&#x27;

describe(&#x27;&lt;Foo /&gt;&#x27;, () =&gt; {
  it(&#x27;allows us to set props&#x27;, () =&gt; {
    const state = {
      foo: &#x27;bar&#x27;
    }
    const wrapper = mount(
      &lt;StateContainer state={state}&gt;
        &lt;Foo /&gt;
      &lt;/StateContainer&gt;
    )
    expect(wrapper.find(&#x27;.foo&#x27;)).to.have.length(1)
  })
})</code></pre><p>This approach allows you to pass down state wherever you want and ensure the components render as expected.</p><h2 id="computes">Computes</h2><p>The <code>runCompute</code> test helper accepts the <code>compute</code> and <code>fixtures</code> arguments and returns the compute output.</p><pre><code class="language-js">var result = runCompute(compute, state)</code></pre><p>The optional <code>fixture</code> argument should be an object that contains any of the following:</p><pre><code class="language-js">{
  state: {}, // test state
  props: {}  // props passed to the computed
}</code></pre><h3 id="example">Example</h3><pre><code class="language-js">import {props, state} from &#x27;cerebral/tags&#x27;
import {runCompute} from &#x27;cerebral/test&#x27;

import Multiply from &#x27;./Multiply&#x27;

it(&#x27;should multiply by the specified number&#x27;, () =&gt; {
  const multiply = Multiply(state`number`, props`number`)
  const result = runCompute(multiply, {
    state: { number: 5 },
    props: { number: 2 }
  })
  assert.equal(result, 10)
})</code></pre><h2 id="actions">Actions</h2><p>The <code>runAction</code> test helper accepts the <code>action</code> and <code>fixture</code> arguments and returns a promise.</p><pre><code class="language-js">runAction(action, fixture).then((result) =&gt; {})</code></pre><p>The optional <code>fixture</code> argument should be an object that contains any of the following:</p><pre><code class="language-js">{
  state: {}, // test state
  props: {}, // props passed to the action
  // any other options that can be passed to the
  // cerebral controller, including router, providers...
}</code></pre><p>The <code>result</code> object passed when the promise resolves contains <code>state</code>, <code>controller</code>, <code>props</code> and <code>output</code> properties.</p><pre><code class="language-undefined">{
  state,
  controller,
  props: {
    // props data received by action
  },
  output: {
    // action output data
  }
}</code></pre><h3 id="example">Example</h3><pre><code class="language-js">import {state} from &#x27;cerebral/tags&#x27;
import {runAction} from &#x27;cerebral/test&#x27;

import Increment from &#x27;./Increment&#x27;

it(&#x27;should increment numbers in state&#x27;, () =&gt; {
  const increment = Increment(state`number`)

  return runAction(increment, { state: { number: 1 } })
    .then(({state}) =&gt; assert.equal(state.number, 2))
})</code></pre><h2 id="signals">Signals</h2><h3 id="runsignal">runSignal</h3><p>The <code>runSignal</code> test helper accepts the <code>signal</code> (chain of actions or signal name) and <code>fixture</code> arguments and returns a promise. <code>runSignal</code> is designed to be called one time, to test calling multiple signals in a single test see the <code>RunSignal</code> factory below.</p><pre><code class="language-js">runSignal(signal, fixture. options).then((result) =&gt; {})</code></pre><p>The optional <code>fixture</code> argument should be an object that contains any of the following:</p><pre><code class="language-js">{
  state: {}, // test state
  props: {}, // props passed to the signal
  // any other options that can be passed to the
  // cerebral controller, including signals, modules, router, providers...
}</code></pre><p>If the <code>signal</code> argument is passed as a string, then the signal must be defined within the fixtures.</p><p>The optional <code>options</code> argument contain the the following options:</p><p><code>recordActions: true|false|&#x27;byName&#x27;</code></p><p>When <code>recordActions: true</code> is specified each action will record its props/output against its index within the signal action chain. When <code>recordActions: &#x27;byName&#x27;</code> is specified each action will record its output against an named property in the result.</p><p>The <code>result</code> object passed when the promise resolves contains <code>state</code>, <code>controller</code> and an object for each named action in the signal chain with the same name as the actions with <code>props</code> and <code>output</code> properties.</p><pre><code class="language-undefined">{
  state,
  controller,
  &#x27;2&#x27;: {
    props: {
      // props data
    },
    output: {
      // action output data
    }
  },
  &#x27;1&#x27;: {
    props: {
      // props data
    },
    output: {
      // action output data
    }
  }
}</code></pre><h4 id="example">Example</h4><pre><code class="language-js">import {runSignal} from &#x27;cerebral/test&#x27;

// the buttonClicked signal has two actions: validateForm and updateIsValid
import buttonClicked from &#x27;./buttonClick&#x27;

it(&#x27;should handle button clicks&#x27;, () =&gt; {
  const fixture = {
    state: { isValid: false },
    props: { buttonName: &#x27;submit&#x27; }
  }
  return runSignal(buttonClicked, fixture, {recordActions: &#x27;byName&#x27;})
    .then(({validateForm, updateIsValid, state}) =&gt; {
      assert.equal(validateForm.props.buttonName, &#x27;submit&#x27;)
      assert.equal(updateIsValid.props.isValid, true)
      assert.equal(state.isValid, true)
    })
})</code></pre><h3 id="runsignal-factory">RunSignal factory</h3><p>The <code>RunSignal</code> factory is similar to run signal except that it will return a runSignal function that can be called many times without resetting the controller in between.</p><pre><code class="language-js">const runSignal = Run(fixture. options)
runSignal(signal, props).then((result) =&gt; {})</code></pre><h4 id="example">Example</h4><pre><code class="language-js">import {RunSignal} from &#x27;cerebral/test&#x27;

it(&#x27;should accumulate a count&#x27;, () =&gt; {
  const runMathSignal = RunSignal({
    modules: {
      math: math()
    }
  })
  return runMathSignal(&#x27;math.plusOne&#x27;).then(({state}) =&gt; {
    assert.equal(state.math.count, 1)
    return runMathSignal(&#x27;math.plusTwo&#x27;).then(({state}) =&gt; {
      assert.equal(state.math.count, 3)
    })
  })
})</code></pre></div></div></div><div style="z-index:99;background-color:#DD4A68;color:#fff;padding:5px 10px;position:fixed;width:100%;bottom:0;left:0;">Docs are still being written and might not be up to date with API</div></div></div>
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
<script src="/search.js"></script>
<script src="/mobile.js"></script>
  </body>
</html>
