<!DOCTYPE html>
<html>
  <head>
    <title>Cerebral Docs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
<link rel="stylesheet" href="/main.css" />
<link rel="stylesheet" href="/prism.css" />
<link rel="stylesheet" href="/docs.css" />
  </head>
  <body>
    <div id="app"><div class="docs-container"><div class="beta">beta</div><div id="navigation" class="docs-navigation"><ul class="docs-navigation-menu"><li class="docs-navigation-item"><a href="/docs/get_started">get started</a><div class="underline"></div></li><li class="docs-navigation-item"><a href="/docs/developer_guide">developer guide</a><div class="underline"></div></li><li class="docs-navigation-item active"><a href="/docs/packages">packages</a><div class="underline"></div></li><li class="docs-navigation-item"><a href="/docs/migration">migration</a><div class="underline"></div></li><li class="docs-navigation-item"><a href="/docs/api">api</a><div class="underline"></div></li></ul><div class="docs-search"><input type="text" id="search-docs" placeholder="search..."/><div id="search-result" class="docs-search-result"></div></div><div class="docs-icons"><a href="https://github.com/cerebral/cerebral" class="docs-icon" target="_new"><div class="docs-icon-github"></div>github repo</a><a href="https://discord.gg/0kIweV4bd2bwwsvH" class="docs-icon" target="_new"><div class="docs-icon-discord"></div>chat</a><a href="http://cerebral-website.herokuapp.com/" class="docs-icon" target="_new" style="color:#DD4A68;">old website</a></div></div><div id="navigation-mobile" class="docs-navigation mobile"><div id="hamburger" class="docs-navigation-hamburger">â˜°</div><div class="docs-navigation-title mobile">packages</div><div class="docs-navigation-float mobile"><ul class="docs-navigation-menu mobile"><li class="docs-navigation-item mobile"><a href="/docs/get_started">get started</a></li><li class="docs-navigation-item mobile"><a href="/docs/developer_guide">developer guide</a></li><li class="docs-navigation-item active mobile"><a href="/docs/packages">packages</a><div class="docs-toc"><div class="docs-toc-content"><div><strong>Table of contents</strong></div><ul><li><a href="/docs/packages/index.html">cerebral-provider-http</a></li><li><a href="/docs/packages/firebase.html">cerebral-provider-firebase</a></li><li><a href="/docs/packages/useragent.html">cerebral-module-useragent</a></li><li><a href="/docs/packages/forms.html">cerebral-provider-forms</a></li><li><a href="/docs/packages/storage.html">cerebral-provider-storage</a></li><li class="active"><a href="/docs/packages/function_tree.html">function-tree</a><ul><li><a href="#install">Install</a></li><li><a href="#description">Description</a></li><li><a href="#api">API</a><ul><li><a href="#instantiate">instantiate</a></li><li><a href="#devtools">devtools</a></li><li><a href="#sequence">sequence</a></li><li><a href="#parallel">parallel</a></li><li><a href="#context">context</a><ul><li><a href="#props">props</a></li><li><a href="#path">path</a></li><li><a href="#execution">execution</a><ul><li><a href="#retry">retry</a></li><li><a href="#abort">abort</a></li></ul></li></ul></li><li><a href="#error">error</a></li><li><a href="#provider">provider</a><ul><li><a href="#contextprovider">ContextProvider</a></li></ul></li><li><a href="#events">events</a></li></ul></li></ul></li></ul></div></div></li><li class="docs-navigation-item mobile"><a href="/docs/migration">migration</a></li><li class="docs-navigation-item mobile"><a href="/docs/api">api</a></li></ul></div></div><div class="docs-content"><div class="docs-toc"><div class="docs-toc-content"><div><strong>Table of contents</strong></div><ul><li><a href="/docs/packages/index.html">cerebral-provider-http</a></li><li><a href="/docs/packages/firebase.html">cerebral-provider-firebase</a></li><li><a href="/docs/packages/useragent.html">cerebral-module-useragent</a></li><li><a href="/docs/packages/forms.html">cerebral-provider-forms</a></li><li><a href="/docs/packages/storage.html">cerebral-provider-storage</a></li><li class="active"><a href="/docs/packages/function_tree.html">function-tree</a><ul><li><a href="#install">Install</a></li><li><a href="#description">Description</a></li><li><a href="#api">API</a><ul><li><a href="#instantiate">instantiate</a></li><li><a href="#devtools">devtools</a></li><li><a href="#sequence">sequence</a></li><li><a href="#parallel">parallel</a></li><li><a href="#context">context</a><ul><li><a href="#props">props</a></li><li><a href="#path">path</a></li><li><a href="#execution">execution</a><ul><li><a href="#retry">retry</a></li><li><a href="#abort">abort</a></li></ul></li></ul></li><li><a href="#error">error</a></li><li><a href="#provider">provider</a><ul><li><a href="#contextprovider">ContextProvider</a></li></ul></li><li><a href="#events">events</a></li></ul></li></ul></li></ul></div></div><div class="docs-doc"><div class="docs-doc-content"><div class="docs-doc-edit"><a href="https://github.com/cerebral/cerebral/tree/master/docs/packages/function_tree.md" target="_new">Edit on Github</a></div><h1 id="function-tree">function-tree</h1><h2 id="install">Install</h2><p><code>npm install function-tree@next --save --save-exact</code></p><h2 id="description">Description</h2><p>Function-tree is the what Cerebral extends to create its signal implementation. Basically a function-tree allows you to execute a tree of functions. You can use the Cerebral debugger to debug function tree execution in any JS environment.</p><p>Function-tree is somewhat in the same family as Rxjs and Promises. The main difference is that Rxjs and Promises  are based on value transformation. That means only the value returned from the previous function is available in the next. This works when you indeed want to transform values, but events in your application are rarely about value transformation, they are about running side effects and going through one of multiple execution paths. Function tree embraces the fact that most of what we do in application development is running side effects.</p><p>Rxjs and Promises are also about execution control, but neither of them have declarative conditional execution paths, you have to write an <em>IF</em> or <em>SWITCH</em> statement or decouple streams. With function tree you are able to diverge the execution down paths just as declaratively as functions. This helps readability.</p><h2 id="api">API</h2><p>Function-tree is implemented with ES6 imports, meaning that on Node you will have to point to the specific exports, like <strong>default</strong>. Examples are given with Node environment.</p><h3 id="instantiate">instantiate</h3><pre><code class="language-js">const FunctionTree = require(&#x27;function-tree&#x27;).default

const execute = FunctionTree([
  // Providers
])

execute([
  function someFunc (context) {},
  function someOtherFunc (context) {}
], {
  foo: &#x27;bar&#x27; // optional payload
})</code></pre><h3 id="devtools">devtools</h3><p>Download the function tree standalone debugger for <a href="https://drive.google.com/file/d/0B1pYKovu9Upyb1Bkdm5IbkdBN3c/view?usp=sharing" target="new">Mac</a>, <a href="https://drive.google.com/file/d/0B1pYKovu9UpyMGRRbG45dWR6R1k/view?usp=sharing" target="new">Windows</a> or <a href="https://drive.google.com/file/d/0B1pYKovu9UpyMFQ5dEdnSy1aN0E/view?usp=sharing" target="new">Linux</a>.</p><pre><code class="language-js">const FunctionTree = require(&#x27;function-tree&#x27;).default
const Devtools = require(&#x27;function-tree/devtools&#x27;).default

// Instantiate the devtools with the port
// you are running the debugger on
const devtools = Devtools({
  remoteDebugger: &#x27;localhost:8585&#x27;
})

// Add the provider to any instantiated
// function tree you want to pass
// information from
const execute = FunctionTree([
  devtools.Provider()
])

// Watch execution of the tree
devtools.watchExecution(execute)</code></pre><p>You can now use the debugger from your functions contexts and/or providers:</p><pre><code class="language-js">function someFunction(context) {
  context.debugger.send({
    method: &#x27;someMethod&#x27;,
    args: [&#x27;foo&#x27;, &#x27;bar&#x27;],
    color: &#x27;red&#x27;
  })
}</code></pre><h3 id="sequence">sequence</h3><p>You can use an array literal to define a sequence of functions.</p><pre><code class="language-js">function someFunction (context) {}
function someOtherFunction (context) {}

module.exports = [
  someFunction,
  someOtherFunction
]</code></pre><p>Or you can be explicit by using the <strong>sequence</strong> function:</p><pre><code class="language-js">const sequence = require(&#x27;function-tree&#x27;).sequence

function someFunction (context) {}
function someOtherFunction (context) {}

module.exports = sequence([
  someFunction,
  someOtherFunction
])</code></pre><p>The first argument to <strong>sequence</strong> can be a string, which names the sequence. This will be shown in the debugger.</p><pre><code class="language-js">const sequence = require(&#x27;function-tree&#x27;).sequence

function someFunction (context) {}
function someOtherFunction (context) {}

module.exports = sequence(&#x27;My awesome sequence&#x27;, [
  someFunction,
  someOtherFunction
])</code></pre><h3 id="parallel">parallel</h3><pre><code class="language-js">const parallel = require(&#x27;function-tree&#x27;).parallel

function someFunction (context) {}
function someOtherFunction (context) {}

module.exports = parallel([
  someFunction,
  someOtherFunction
])</code></pre><p>Even though <strong>someFunction</strong> returns a Promise, <strong>someOtherFunction</strong> will be run immediately.</p><h3 id="context">context</h3><h4 id="props">props</h4><pre><code class="language-js">const FunctionTree = require(&#x27;function-tree&#x27;).default

function funcA (context) {
  context.props.foo // &quot;bar&quot;
}

const execute = FunctionTree()
const tree = [
  funcA
]

execute(tree, {foo: &#x27;bar&#x27;})</code></pre><h4 id="path">path</h4><p>The path is only available on the context when the function can diverge the execution down a path.</p><pre><code class="language-js">const FunctionTree = require(&#x27;function-tree&#x27;).default

function funcA (context) {
  context.props.foo // &quot;bar&quot;

  return context.path.pathA({foo2: &#x27;bar2&#x27;})
}

function funcB (context) {
  context.props.foo // &quot;bar&quot;
  context.props.foo2 // &quot;bar2&quot;

  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve({foo3: &#x27;bar3&#x27;})
    }, 100)
  })
}

function funcC(context) {
  context.props.foo // &quot;bar&quot;
  context.props.foo2 // &quot;bar2&quot;
  context.props.foo3 // &quot;bar3&quot;
}

const execute = FunctionTree([])
const tree = [
  funcA, {
    pathA: [
      funcB,
      funcC
    ],
    pathB: []
  }
]

execute(tree, {foo: &#x27;bar&#x27;})</code></pre><h4 id="execution">execution</h4><h5 id="retry">retry</h5><pre><code class="language-js">function funcA (context) {
  return new Promise(resolve =&gt; {
    setTimeout(resolve, 500)
  })
}

function funcB (context) {
  if (context.props.retryCount &lt; 3) {
    return context.execution.retry({
      retryCount: context.props.retryCount + 1
    })
  }
}

const tree = [
  funcA,
  funcB
]</code></pre><h5 id="abort">abort</h5><pre><code class="language-js">const FunctionTree = require(&#x27;function-tree&#x27;).default
const execute = FunctionTree([])

function funcA (context) {
  return context.execution.abort()
}

function funcB (context) {
  // Does not run
}

const tree = [
  funcA,
  funcB
]

execute.on(&#x27;abort&#x27;, (functionDetails, payload) =&gt; {})

execute(tree)</code></pre><h3 id="error">error</h3><pre><code class="language-js">const FunctionTree = require(&#x27;function-tree&#x27;).default
const execute = FunctionTree([])

// As an event (async)
execute.on(&#x27;error&#x27;, function (error, execution, payload) {

})

// As callback (sync)
execute(tree, (error, execution, payload) =&gt; {
  if (error) {
    // There is an error
  }
})</code></pre><h3 id="provider">provider</h3><p>A provider gives you access to the current context and other information about the execution. It is required that you return the context or a mutated version of it.</p><pre><code class="language-js">const FunctionTree = require(&#x27;function-tree&#x27;).default

function MyProvider(context, functionDetails, payload) {
  context // Current context
  context.props // Input created by the PropsProvider (default)

  payload // The current payload (Used by PropsProvider)

  functionDetails.name // Name of the function
  functionDetails.functionIndex // The index of the function in the tree, like an ID
  functionDetails.function // A reference to the running function
  functionDetails.isParallel // If the function is running in parallel with others

  context.execution.name // Function tree id
  context.execution.id // Current execution id
  context.execution.staticTree // The static representation of the tree
  context.execution.datetime // Time of execution
  context.execution.functionTree // The function tree instance

  return context // Always return the changed context
}

const execute = FunctionTree([
  MyProvider
])</code></pre><p>Providers lets us do some pretty amazing things. The debugger for <strong>function-tree</strong> is actually just a provider that sends information to the debugger about execution and exposes an API for other providers to send their own data to the debugger.</p><h4 id="contextprovider">ContextProvider</h4><p>Will extend the context. If the debugger is active the methods on the attached object will be wrapped and debugger will notify about their uses.</p><pre><code class="language-js">const FunctionTree = require(&#x27;function-tree&#x27;).default
const ContextProvider = require(&#x27;function-tree/providers&#x27;).ContextProvider
const request = require(&#x27;request&#x27;)

function funcA (context) {
  context.request
  context.request.get(&#x27;/whatever&#x27;) // Debugger will know about this
}

const execute = FunctionTree([
  ContextProvider({
    request
  })
])
const tree = [
  funcA
]

execute(tree)</code></pre><h3 id="events">events</h3><p>The execute function is also an event emitter.</p><pre><code class="language-js">import FunctionTree from &#x27;function-tree&#x27;

const execute = FunctionTree([])
const tree = [
  funcA
]

// When an error is thrown, also catches promise errors
execute.on(&#x27;error&#x27;, (error, execution, payload) =&gt; {})

// When a function tree is executed
execute.on(&#x27;start&#x27;, (execution, payload) =&gt; {})

// When a function tree execution has ended
execute.on(&#x27;end&#x27;, (execution, payload) =&gt; {})

// When a function tree goes down a path
execute.on(&#x27;pathStart&#x27;, (execution, payload) =&gt; {})

// When a function tree ends execution of a path
execute.on(&#x27;pathEnd&#x27;, (execution, payload) =&gt; {})

// When a function in a function tree starts executing
execute.on(&#x27;functionStart&#x27;, (execution, functionDetails, payload) =&gt; {})

// When a function in a function tree stops executing
execute.on(&#x27;functionEnd&#x27;, (execution, functionDetails, payload) =&gt; {})

// Triggers when an async function has been run
execute.on(&#x27;asyncFunction&#x27;, (execution, functionDetails, payload) =&gt; {})

// When a parallel execution is about to happen (array in array)
execute.on(&#x27;parallelStart&#x27;, (execution, payload, functionsToResolveCount) =&gt; {})

// When a function in parallel execution is done executing
execute.on(&#x27;parallelProgress&#x27;, (execution, payload, functionsStillResolvingCount) =&gt; {})

// When a parallel execution is done
execute.on(&#x27;parallelEnd&#x27;, (execution, payload, functionsExecutedCount) =&gt; {})

execute(tree)</code></pre></div></div></div></div></div>
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
<script src="/search.js"></script>
<script src="/mobile.js"></script>
  </body>
</html>
