{"get_started":{"index":{"raw":"# Cerebral\n\nTo install Cerebral you need to use the Node Package Manager. NPM is part of [Node](https://nodejs.org/en/), so please install that on your computer first. You should install Node version 5 or later. If you are not familiar with Node and/or Webpack it can be a good idea to start out with [the tutorial](../tutorial/01_introduction.html).\n\nTo install Cerebral Alpha you have to explicitly install Cerebral and its dependency:\n\n`npm install cerebral@next --save --save-exact`\n\n\n## Choosing a view type\nCerebral technically can use any view layer. Currently it officially supports [React](https://facebook.github.io/react/) and [Inferno](http://infernojs.org/). From a Cerebral perspective they have the exact same API, you just have to choose to import from **cerebral/react** or **cerebral/inferno**. For specific API differences of the two view libraries please check their documentation.\n\nChoose React if you want a huge ecosystem of shared components and documentation. Inferno is faster than React and is recommended to be used when you do not depend heavily on 3rd party components.\n\n## Hello world\n*controller.js*\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {\n    title: 'Hello world'\n  }\n})\n\nexport default controller\n```\n\n*App.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`\n},\n  function App ({title}) {\n    return (\n      <h1>{title}</h1>\n    )\n  }\n)\n```\n\n*main.js*\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\nimport controller from './controller'\nimport App from './App'\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n","title":"Cerebral"},"debugger":{"raw":"# Debugger\n\nCerebral has a powerful development tool. It knows about all the state in your application, all the state updates, side effects run, state paths currently active in your components and when they render. All the things Cerebral helps you with, it visualizes in the debugger.\n\nThe Cerebral debugger is a standalone application and a chrome extension. You can use both if you want, as the chrome extension is the fallback if the standalone debugger is not opened. You can install the chrome extension from [the google store](https://chrome.google.com/webstore/detail/cerebral2-debugger/ghoadjdodkgkbbmhhpbfhgikjgjelojc).\n\nThe standalone debugger connects to your application through websockets. You will need to configure the **devtools** for this purpose (see below). Download and extract the zip for your target OS: [Mac](https://docs.google.com/uc?id=0B1pYKovu9UpybHRMRm9YZU10WUU&export=download), [Windows](https://docs.google.com/uc?id=0B1pYKovu9UpyU0lkU2UyWklMV28&export=download) or [Linux](https://docs.google.com/uc?id=0B1pYKovu9UpyWE85UWVHNFRCQkk&export=download)\n\nYou initialize the devtools by adding it to the controller.\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  // You do not want to run the devtools in production as it\n  // requires a bit of processing and memory to send data from\n  // your application\n  devtools: (\n    process.env.NODE_ENV === 'production' ?\n      null\n    :\n      Devtools({\n        // If running standalone debugger\n        remoteDebugger: 'localhost:8585'\n      })\n  )\n})\n\nexport default controller\n```\n","title":"Debugger"},"the_architecture":{"raw":"# The architecture\n\nCerebral is based on the simple concept of three things your application does in order to function. **Store state**, **render state** and **update state**.\n\n## Store state\nWhere to store the state of an application is a highly debated subject. Should we allow the components to store state? Should we have multiple models? Stores? Reducers? Services? There are many concepts that can store state. In Cerebral you store all your state in \"a single state tree\". That means you do not create classes or other abstractions around state, it is all basically one big object of plain JavaScript types. Objects, arrays, strings, numbers and booleans:\n\n```js\n{\n  auth: {\n    isLoggedIn: false,\n    user: {}\n  },\n  posts: {\n    list: [],\n    selectedPostIndex: 0\n  }\n}\n```\n\nWith this approach we get some benefits not possible with other approaches.\n\n### Simple and consistent API\nTypically a state update changes a value, pushes an item in a list or merges an object into another. With a single state tree we can create an API that does exactly that:\n\n```js\nstate.set('user.prefs.style', 'dark')\nstate.push('user.friends', 'Joe')\nstate.merge('user.info', {\n  email: 'cheetah@jungle.com',\n  name: 'Cheetah'\n})\n```\n\nWith a single state tree we can point to parts of the state using paths (the first argument). We use dot notation to point to nested paths, like **auth.user.name**.\n\n### Optimized rendering\nCerebral does not look at the updates in your application as \"value updates\", but as \"path updates\". This allows Cerebral to make optimizations not possible in other frameworks:\n\n1. There is no need for immutability in Cerebral because a change to a path means that any component depending on that path should render (no value comparison). In applications with large data structures immutability has a high cost. There is no need to hack objects and arrays to observe changes to them either. There is nothing special about the state you put into Cerebrals state tree\n2. Since there is no value comparison in Cerebral it uses what we call **strict render**. This allows us to do render optimizations not possible with other solutions. For example you can say that a component depending on a list is only interested in added/removed items of the list or if the list itself is being replaced\n\n## Render state\nSince Cerebral stores all the state of the application in a single state tree we need a way to expose that state to the components. In some frameworks this is done by passing the whole model or collection of models/stores from the top of the application and down from one component to the next. This can become very tedious and fragile as all nested components completely depend on their parent. In Cerebral the state of the application is directly connected to each component:\n\n```js\nconnect({\n  userName: state`app.user.name`\n},\n  function User(props) {\n    props.userName // \"some name\" (value stored in 'app.user.name')\n  }\n)\n```\n\n**connect** tells Cerebral that the component is interested in a path where the user name happens to be. When that path changes the component will render. The component is now completely independent of other components. You can move it wherever you want in the component tree and it will still work.\n\n## Update state\nThis is where Cerebral really differs from other approaches to application development. Updating the state of an application can be anything from:\n\n- flipping a **true** to a **false**\n- setting some value, like a filter\n- reading (and storing) something in local storage\n- requesting data from the server and, depending on the status code of the response, do something with that response which might lead to new requests and/or setting up a listener for data on the server\n- etc...\n\nThe point is, updating state can be a very complex flow of operations. This is often where spaghetti code comes from and we use abstractions to hide it. The problem with abstractions is that it is very difficult to understand how things actually work and it becomes more difficult to make changes.\n\nTo handle everything from a simple toggle to very complex operations, Cerebral has the concept of **signals**. Signals allows you to compose functions together into a flow that is not only about the \"happy path\" but properly takes the actual paths of execution into account, them being errors or other reasons to diverge execution. You can define many different execution paths based on whatever you want (a status code, an error, some state, etc). This allows you to write decoupled code, while still bringing everything together in the form of a higher abstraction which greatly helps understanding how things relate to one another (in what order they will run, when they will run, etc). Under the hood, signals are based on [function-tree](https://github.com/cerebral/function-tree), a project that came out of the initial experimentations in the first version of Cerebral.\n\nAnother powerful feature of **signals** (aka function-tree) is that there is a debugger that can track execution and understands when a signal triggers, what functions are run, what state is being updated and what other side effects are triggered.\n\n## Summary\nThe architecture of Cerebral is driven by the goal to give you insight. The single state tree and the way state is connected to the components all support this vision. Creating a Cerebral application allows you and your team members to never question what actually happens when a page loads, a specific button is clicked, etc. Decoupling of state, components and state updates also makes it an overall better experience when scaling up an application as the components will be just a dumb layer that transforms a given state to a user interface.\n","title":"The architecture"},"demos":{"raw":"# Demos\n\n## Webpackbin\nThe webpack bin service is built with Cerebral.\n\n[Open Webpackbin](https://www.webpackbin.com)\n\n## TodoMVC\nThe traditional web application for showing off the typical challenges of building apps. Handle state, deriving state and structure the application.\n\n[Open TodoMVC demo](/todomvc)\n\n[Go to repo](https://github.com/cerebral/cerebral/tree/master/demos/todomvc)\n","title":"Demos"},"articles_and_videos":{"raw":"# Articles and videos\n\n## Articles\n- [The story of Cerebral](http://medium.com/p/5793c08db2cc)\n- [An unlikely success story](https://gist.github.com/christianalfoni/b08a99faa09df054afe87528a2134730)\n\n## Videos\n- [A real project - Ducky](https://youtu.be/uXlxNJfGKjU?t=4m18s)\n","title":"Articles and videos"},"counter":{"raw":"# Example: Counter\n\n*controller.js*\n```js\nimport {Controller} from 'cerebral'\n\nfunction increase ({state}) {\n  state.set('count', state.get('count') + 1)\n}\n\nfunction decrease ({state}) {\n  state.set('count', state.get('count') - 1)\n}\n\nconst controller = Controller({\n  state: {\n    count: 0\n  },\n  signals: {\n    increaseClicked: [increase],\n    decreaseClicked: [decrease]\n  }\n})\n\nexport default controller\n```\n\n*App.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  count: state`count`,\n  increaseClicked: signal`increaseClicked`,\n  decreaseClicked: signal`decreaseClicked`,\n},\n  function App ({count, increaseClicked, decreaseClicked}) {\n    return (\n      <div>\n        <button\n          onClick={() => increaseClicked()}\n        > + </button>\n        {count}\n        <button\n          onClick={() => decreaseClicked()}\n        > - </button>\n      </div>\n    )\n  }\n)\n```\n\n*main.js*\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\nimport controller from './controller'\nimport App from './App'\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n","title":"Example: Counter"}},"developer_guide":{"index":{"raw":"# Introduction\n\nThis developer guide will explain the concepts of Cerebral. The first sections also includes a **tutorial**, meaning that you get introduced to the concept first and then you will be guided through a tutorial using the [Webpackbin](https://www.webpackbin.com) service.\n\nGoing through the tutorials it is highly recommended that you install the **standalone** version of the debugger. You can use the Chrome Extension version when you develop normally on your machine.\n\nIf you ever get lost or have other questions we are happy to help you on [discord chat](https://discord.gg/0kIweV4bd2bwwsvH). Hope you enjoy it!\n","title":"Introduction"},"state":{"raw":"# State\n\nCerebral uses a single state tree to store all the state of your application. It is just a single object:\n\n```js\n{}\n```\n\nThat's it.\n\nYou will normally store other objects, arrays, strings, booleans and numbers in it. Forcing you to think of your state in this simple form gives us benefits.\n\n1. The state of the application is exposed as simple values. There are no classes or other abstractions hiding the state of your application\n2. The state can be stored on the server, local storage and passed to the debugger. It is what we call **serializable** state\n3. All the state of your application can be inspected through one object\n4. All state is related to a path. There is no need to import and/or pass around model instances into other model instances to access state\n\nState can be defined at the top level in the controller and/or in modules. State is defined as plain JavaScript value types. Objects, arrays, strings, numbers and booleans. This means that the state is serializable. There are no classes or other abstractions around state. This is an important choice in Cerebral that makes it possible to track changes to update the UI, store state on server/local storage and passing state information to the debugger.\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://webpackbin-prod.firebaseapp.com//bins/-KdACuVE1vrPicewg7fm)\n\nTo define the initial state of any application all we need to do is to add it to our **Controller** in *controller.js*\n\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: Devtools({\n    remoteDebugger: '127.0.0.1:8585'\n  }),\n  state: {\n    title: 'Cerebral Tutorial'\n  }\n})\n\nexport default controller\n```\n\nWhen you save your bin and look at the state tree you will see the state added. If it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"State"},"connect":{"raw":"# Components\n\nIn Cerebral you connect state to components where you need it. This give some benefits:\n\n1. Cerebral will optimize the component\n2. The debugger will know about this component and visualize its state dependencies and when it renders\n3. Increased readability as every component explicitly tells you what state it needs and where it gets it from\n4. You can safely move the component wherever you want without breaking chain of props passing\n\nWhen you connect a component like this...\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  foo: state`app.title`\n},\n  function MyComponent ({title}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n      </div>\n    )\n  }\n)\n```\n\n...the component will be registered to the **Container** which is used to expose the controller. The *Container* actually has a register of all connected components in your application. This information is passed to the debugger and whenever Cerebral flushes out changes made to different state paths, the *Container* will figure out what components should render.\n\nAll connected components are automatically optimized, meaning that they will only render if a parent component passes a changed prop or the *Container* tells it to render.\n\nYou can also use classes where needed:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  foo: state`app.foo`\n},\n  class MyComponent extends React.Component {\n    render () {\n      return (\n        <div>\n          <h1>{this.props.title}</h1>\n        </div>\n      )\n    }\n  }\n)\n```\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://webpackbin-prod.firebaseapp.com//bins/-KdBDYEXCVwtPoaMAXgJ)\n\nNow let's get that state displayed in our application.\nFirst of all, we need to tell our component (App) to **connect** to the state.\n\nSo please change *App.js* to:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`\n},\n  function App ({title}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>Render state</h2>\n      </div>\n    )\n  }\n)\n```\n\nAnd voilà, your application should now look exactly the same, only getting the title from the state tree. And this is the essence of creating web applications. We define state and how that state should be displayed in the user interface.\n\nWe used something called a **tag** to define our state dependency. If you are unfamiliar with [template literals and template literal tags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) in JavaScript, you can read about them or just accept their awesome power :)\n\nBut our application does not do much. We have to introduce the concept of change. With the debugger, we can actually force a change to our state and make the UI update. Click the title state in the debugger, change it and hit enter. You will see the application display your changed state.\n\nThanks to...\n```js\nconnect({\n  title: state`title`\n}, ...)\n```\n...we told Cerebral that this component is interested in the value on the path **title**, and we wanted it exposed as **title** to our component as well. Because this component now depends on the **title** state it gets rendered whenever the path has a change.\n\nCongratulations, you have now created application state and exposed it to a component. You have now gained the power of translating the state of the application into something a user can understand. You will notice with Cerebral that this is a very clear separation. You define your application state in Cerebral and you use components to translate this state into a user interface.\n\n### The component signature\nLet us quickly talk about the syntax before moving on. The signature of connect most commonly uses two arguments:\n\n**connect(dependencies, Component)**\n\nWe usually write this out as:\n\n```js\nconnect({\n  title: state`title`\n},\n  function App ({title}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>Render state</h2>\n      </div>\n    )\n  }\n)\n```\n\nWriting out the arguments on multiple lines and with indentation just makes it read better. It is also very nice to read the dependencies of your component first and then what the component does with those dependencies.\n\n### Challenge\n\nIt's time for your first challenge!\n\n- Add another state to the store called *subTitle*\n- Connect *subTitle* to the App component and replace the content of the H2 with that state\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Components"},"signals":{"raw":"# Signals\n\nThe signals of Cerebral are named in past tense. So typically you would name a signal **inputChanged** or **mounted**. You call a signal just like you would call a function, the difference is that you start a function tree execution.\n\nCerebral uses the [function-tree](https://github.com/cerebral/function-tree) project to implement its signals. A function-tree allows you to define a tree of functions to be executed. In Cerebral world we call the arrays in a function-tree **chains**. These chains contains functions, we call them **actions**. So to sum up: *\"signals are chains of actions\"*.\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\n\nexport default [\n  actionA,\n  actionB\n]\n```\n\nCerebral runs one action after the other synchronously. When an action returns a promise it will hold until the promise resolves and then continue.\n\n## Parallel execution\nYou can also run these actions in parallel. You do that by grouping them in another array:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport actionC from '../actions/actionC'\n\nexport default [\n  [\n    actionA,\n    actionB\n  ],\n  actionC\n]\n```\n\nIf actionA returns a promise actionB will still be run instantly, meaning that they run in parallel. When both actionA and actionB is done, actionC is run.\n\n## Composing\nChains can be composed into an other chain by using the spread operator. This is a powerful concept that allows you to compose large pieces of logic into other parts of your application.\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport chainA from '../chains/chainA'\n\nexport default [\n  actionA,\n  ...chainA,\n  actionB\n]\n```\n\nCerebral will now run this as one signal, first running *actionA*, then whatever is expressed in *chainA* and then run *actionB* last.\n\n## Running a signal\nTo run a signal you can grab it from the controller:\n\n```js\nimport {Controller} from 'controller'\nimport someChain from './chains/someChain'\n\nconst controller = Controller({\n  signals: {\n    somethingHappened: someChain\n  }\n})\n\nconst signal = controller.getSignal('somethingHappened')\nsignal()\n```\n\nThis signal triggers synchronously and you can pass it a payload.\n\n```js\n...\nsignal({\n  foo: 'bar'\n})\n```\n\nThis payload is brought into the signal execution and acts as the **props** of the signal. Typically you will not trigger signals manually this way, but rather from within a component.\n\n```js\nconnect({\n  foo: state`app.foo`,\n  somethingHappened: signal`app.somethingHappened`\n},\n  function MyComponent (props) {\n    return <button onClick={() => props.somethingHappened()}>Click me</button>\n  }\n)\n```\n\nThe payload passed to a signal is typically the core value types of JavaScript. Object, Array, String, Number or Boolean. It is also possible to pass in some special value types, like files. For a full list of supported value types, check the [state API documentation](../api/state.html).\n\n## Tutorial\n**Before you start,** [load this BIN on Webpackbin](https://webpackbin-prod.firebaseapp.com//bins/-KdBGyGo09NxQfRWSNOb)\n\nDefining state and user interfaces is more about describing how something should look, rather than how it should update. Updates are the tricky part, this is where we usually introduce complexity in our applications.\n\nCerebral allows you to describe updates the same way you describe state and user interfaces, in a declarative manner. We call them **signals** and they will help you handle complexity both in code and in your head.\n\n### Adding a signal\nLet us add a signal to our **Controller** in *controller.js*:\n\n```js\n...\nfunction updateSubtitle ({state}) {\n  state.set('subTitle', 'Updating some state')\n}\n\nconst controller = Controller({\n  devtools: Devtools(),\n  state: {\n    title: 'Hello from Cerebral!',\n    subTitle: 'Working on my state management'\n  },\n  signals: {\n    buttonClicked: [\n      updateSubtitle\n    ]\n  }\n})\n```\nWe now defined a signal named **buttonClicked**. The signal tells us \"what happened to make this signal run\". A signal is defined using an array containing functions. What we want to happen when this signal triggers is to update the **subTitle** in our state with a static value. We do this by pointing to our *subTitle* function, making it an item of the array. Normally you would define this function in a separate file. The **updateSubtitle** function is one of possibly multiple functions that will run when **buttonClicked** runs.\n\nAs you can see functions in a signal receives an argument, which we [destructure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) to grab the *state*. The argument itself is called the **context**. So **state** is on the **context**, as we can see here:\n\n```js\n...\nfunction updateSubtitle ({state}) {\n  state.set('subTitle', 'Updating some state')\n}\n...\n```\n\n### Trigger the change\nPlease take a closer look at *App.js*:\n\n```js\n...\nconnect({\n  title: state`title`,\n  subTitle: state`subTitle`\n},\n  ...\n)\n```\nAs you can see the App-Component depends on **subTitle**. That means it will render automatically whenever **subTitle** changes. Because our **updateSubtitle** function changes the path **subTitle**, Cerebral just knows which components need to update and thus there is no dirty checking or other value comparison needed.\n\nTo trigger the signal we need to wire up a click-handler on a button and add our signal **buttonClicked** to the **connect(..)** method:\n\n*App.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  buttonClicked: signal`buttonClicked`\n},\n  function App ({title, subTitle, buttonClicked}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>{subTitle}</h2>\n        <button onClick={() => buttonClicked()}>\n          Update state\n        </button>\n      </div>\n    )\n  }\n)\n```\nNow click it and take a look at the debugger. You will see the debugger list the execution of the signal, with information about what happened. This is also a tool the Cerebral debugger provides to give you insight into your application. Very handy for example when you need to dig into a **complex application** after not touching it for a long time, introduce a new team member to the application or debug complex execution flows.\n\nSo changing the *subTitle* is kind of a silly state change on a button click. Let's introduce a very simple \"Toast\"-Component. It has already been added for you on the next chapter.\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Signals"},"actions":{"raw":"# Actions\n\nA signal runs actions and actions are actually just functions.\n\n```js\nfunction iAmAnAction () {}\n```\n\nThat means you do not need any API to define an action. This makes actions highly testable.\n\nTypically you use actions to change the state of the application or run other side effects.\n\n```js\nfunction iAmAnAction ({props, state}) {\n  state.set('some.path', props.someValue)\n}\n```\n\n```js\nfunction iAmAnAction ({http, path}) {\n  return http.get('/someitems')\n    .then(path.success)\n    .catch(path.error)\n}\n```\n\n## Update props\nYou update the props on the signal by returning an object form the action. This object will be merged with existing props.\n\n```js\nfunction iAmAnAction () {\n  return {\n    newProp: 'someValue'\n  }\n}\n```\n\n## Async\nWhen actions return a promise the signal will hold execution until it is resolved. any resolved values will be merged in with props.\n\n```js\nfunction iAmAnAction () {\n  return new Promise((resolve) => {\n    resolve({\n      newProp: 'someValue'\n    })\n  })\n}\n```\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://webpackbin-prod.firebaseapp.com//bins/-KdBPZwKFDQKkAcUqRte)\n\nSignals can take a props-object which can then be accessed or processed by any subsequent action.\n\nLet us say you have a user input which should get written to state.\nAs we now know, the correct way to write any state change is to use **signals** with **actions**.\n\nJust like we are able to grab the **state** from the context of an action, we can also grab the **props**. This props object can be populated when a signal triggers and it can be further extended using actions. Any object returned from an action will be merged into the current props and passed to the next action.\n\n### Create an action\nLet us create a new action that will take a prop from the signal and add some exclamation marks.\n\n```js\nfunction shoutIt ({props}) {\n  return {\n    message: `${props.message}!!!`\n  }\n}\n```\n\nAs you can see we grabbed the props just like we grabbed the state. The object we return from the action will be merged with the existing props. That means we are overriding the **message** with exclamation marks.\n\nOn our first **set** operator we rather now use a tag, *props*, to define that we want to set the message from the props.\n\n```js\n...\nimport {set, wait} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n...\n{\n  buttonClicked: [\n    shoutIt,\n    set(state`toast`, props`message`),\n    wait(4000),\n    set(state`toast`, null)\n  ]  \n}\n```\n\n### Passing a payload\nNow we just need to change our button click to actually pass a message:\n\n*App.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport Toast from './Toast'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  buttonClicked: signal`buttonClicked`\n},\n  function App ({title, subTitle, buttonClicked}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h3>{subTitle}</h3>\n        <button onClick={() => buttonClicked({\n          message: 'Please shout me'\n        })}>\n          Update state\n        </button>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\n\nNow we are ready to test drive our changes. Click the button and you should see the toast message appear with three exclamation marks behind. Take some time to open up the **debugger** and explore the changes you've made. You can track the flow of the props object as it is passed into the action *Input:{}* and after the action has excecuted *Output: {}*. Keep in mind that the object returned from an action will be merged with the props object and handed over to the next action. You could just as easily use a different property for the shouted message.\n\n### Challenge\n\n- Add another custom action which transforms the props value to Uppercase. You may override existing properties on the props or create a new one\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Actions"},"operators":{"raw":"# Operators\nCreating an action for any kind of state change will be tedious. That is why Cerebral has **operators**. These operators are just functions that return an action for you. There is an operator for every kind of state change, but also other operators controlling time and execution paths.\n\n## State changes\nThe most common operators you will use changes the state of your application.\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, 'bar')\n]\n```\n\nWith the help of **tags** we are able to express that we want to set the state path **foo** to have the value **\"bar\"**. We can also use the **props** tag to express that we want to grab the value from the current payload of the signal instead:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, props`foo`)\n]\n```\n\nAnd this is how you go about using operators:\n\n```js\nimport {merge, push, pop} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  merge(state`some.object`, props`newObj`),\n  push(state`some.list`, props`newItem`),\n  pop(state`some.otherList`)\n]\n```\n\n## Time\nYou can control time using operators. For example to hold a signals execution, you can:\n\n```js\nimport {wait} from 'cerebral/operators'\nimport doThis from '../actions/doThis'\nimport doThat from '../actions/doThat'\n\nexport default [\n  doThis,\n  wait(2000),\n  doThat\n]\n```\n\nYou can also do more complex time control using **debounce**.\n\n```js\nimport {set, debounce} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\nimport makeQueryRequest from '../chains/makeQueryRequest'\n\nexport default [\n  set(state`query`, props`query`),\n  debounce(500), {\n    continue: [\n      ...makeQueryRequest\n    ],\n    discard: []\n  }\n]\n```\n\n## Paths\nSome operators helps you go down specific paths of execution.\n\n```js\nimport {when, equals} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  when(state`app.isAwesome`), {\n    true: [],\n    false: []\n  },\n  equals(state`user.role`), {\n    admin: [],\n    user: [],\n    otherwise: []\n  }\n]\n```\n\nAs you can see **operators** are a powerful concept that allows you to describe how your application executes and changes its state. Other tools in the Cerebral ecosystem also has its own operators for running side effects like HTTP requests, Firebase requests etc. Most of your application can actually be described with operators.\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://webpackbin-prod.firebaseapp.com//bins/-KdBHyLJDefteJy0s821)\n\nA signal can trigger an array of functions. This array we call a **chain** and the functions we call **actions**. For now, we have seen it trigger a function that changes the **subTitle** path and in this chapter, we have added a **Toast** component which displays any message set on its related state.\n\n### Refactor to operator\nLet us first change out our **updateSubtitle** action with an operator instead. Since we did a *set*, we change it out with the **set** operator. Operators also take advantage of the tags. In this case, the first argument uses a tag to target our state. The second argument could also have been a tag, but we hardcode a value instead.\n\nNow lets add a **wait** operator and another **set** to close our toast message after a few seconds. So go ahead and change our **buttonClicked** signal in *App.js* to execute 2 more actions:\n\n```js\n...\nimport {set, wait} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n...\n{\n  buttonClicked: [\n    set(state`toast`, 'Button Clicked!'),\n    wait(4000),\n    set(state`toast`, null)\n  ]\n}\n```\n\nNow when we check again in the debugger you will see all the 3 actions executed when signal *buttonClicked* got triggered.\n\nStill speaking of the debugger did you notice the **Input: {}** in front of every action executed? Looks quite empty. Let us look at that in the next chapter! If it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Operators"},"factories":{"raw":"# Factories\nFunction factories is a common term in programming. It is basically a function that returns a function:\n\n```js\nfunction createHelloMessage (name) {\n  function helloMessage () {\n    console.log(`Hello there ${name}`)\n  }\n\n  return helloMessage\n}\n\nconst helloBob = createHelloMessage('Bob')\nhelloBob() // Logs: \"Hello there Bob\"\n```\n\nIn Cerebral you will find yourself creating a lot of factories. Factories for creating actions and even factories for creating chains. Actually the Cerebral **operators** are action and chain factories.\n\n## Action factory\n```js\nfunction hasUserRoleFactory (role) {\n  function hasUserRole ({state, path}) {\n    if (state.get('user.role') === role) {\n      return path.true()\n    }\n\n    return path.false()\n  }\n\n  return hasUserRole\n}\n```\n\nSo this factory can now be used in any chain:\n\n```js\nimport hasUserRole from '../factories/hasUserRole'\n\nexport default [\n  hasUserRole('admin'), {\n    true: [],\n    false: []\n  }\n]\n```\n\n## Chain factory\n```js\nimport {set, wait} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nfunction showMessageFactory (message, ms) {\n  return [\n    set(state`app.message`, message),\n    wait(ms),\n    set(state`app.message`, null)\n  ]\n}\n```\n\nNow this can be used in any chain:\n\n```js\nimport showMessage from '../factories/showMessage'\n\nexport default [\n  ...showMessage('Hello there!', 500)\n]\n```\n\nChain factories should always be **spread** into chains. Think of it as \"merging it in\". Usually it does not matter, cause it will just be treated as a parallel execution, but it is good practice.\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://webpackbin-prod.firebaseapp.com//bins/-KdBPZwKFDQKkAcUqRte)\n\nUntil now we have mostly used synchronous actions inside our **signals** and the flow was, therefore, straightforward. Example:\n\n```js\nController({\n  signals: {\n    somethingHappened:[\n      action1,\n      action2\n    ]\n  }\n})\n```\nBecause action2 appears after action1, action1 finishes before action2 starts. Clear enough. But now what happens when action1 executes asynchronously?\n\nWe already have an example of this in our code. The **wait** operator runs asynchronously. It runs for 4 seconds before the toast message is reset.\n\n```js\nController({\n  signals: {\n    buttonClicked:[\n      set(state`toast`, props`message`),\n      wait(4000),\n      set(state`toast`, null)\n    ]\n  }\n})\n```\n\nThe signal executes with the same behavior, it waits for an action to resolve before moving to the next. So how does Cerebral know that **wait** is an asynchronous action? Well, the action returns a promise. That means all actions returning a promise is considered an *async action*.\n\n### Creating factories\nLet us look at how **wait** is defined:\n\n```js\nfunction waitFactory (ms) {\n  function wait () {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms)\n    })\n  }\n\n  return wait\n}\n```\n\nWe have just defined a **factory**. A function that returns an action. The action itself (wait) returns a promise. This promise is what tells the signal to hold its execution until it is resolved.\n\nCerebral factories are not only restricted to actions, you can also have chain factories.\n\n### Chain factories\nLet us create our own custom **showToast** chain factory. Instead of returning an action, we return a chain. As you can see we have moved the actions we defined previously into this array, using the arguments passed into the factory.\n\n```js\n...\nfunction showToast(message, ms) {\n  return [\n    set(state`toast`, message),\n    wait(ms),\n    set(state`toast`, null)\n  ]\n}\n...\nconst controller = Controller(...)\n```\n\nWe need to adjust the signal as well:\n```js\nController({\n  signals: {\n    buttonClicked: [\n      shoutIt,\n      ...showToast(props`message`, 1000)\n    ]\n  }\n})\n```\n\nSince **showToast** returns an array we use the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) to merge into our existing chain.\n\nCongratulations! You have successfully mastered the power of factories. But there are a couple of more concepts that will help you define state changes, jump over to the next chapter to find out more.\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Factories"},"paths":{"raw":"# Paths\nChains can also express execution paths. For example:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport actionC from '../actions/actionC'\n\nexport default [\n  actionA, {\n    foo: [\n      actionB\n    ],\n    bar: [\n      actionC\n    ]\n  }\n]\n```\n\nYou can think of this as \"if statements\" in the chain. When a path is expressed after an action, the context of that action will have a **path** on its context. For example in this example:\n\n```js\nfunction actionA ({path}) {\n  path.foo // function\n  path.bar // function\n}\n```\n\nWhen the action returns one of these paths, that path will be executed:\n\n```js\nfunction actionA ({path}) {\n  return path.foo()\n}\n```\n\nThis is possible due to Cerebrals static analysis of the signals. It knows exactly how it is going to run before it is executed.\n\nYou can also pass a payload to the path:\n\n```js\nfunction actionA ({path}) {\n  return path.foo({\n    foo: 'bar'\n  })\n}\n```\n\nThis is merged into the *props* and made available to the next actions. If you return a promise from an action you just resolve the path:\n\n```js\nfunction actionA ({path}) {\n  return new Promise((resolve) => {\n    resolve(path.foo({\n      foo: 'bar'\n    }))\n  })\n}\n```\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://webpackbin-prod.firebaseapp.com//bins/-KdBUBNJyrfqL3c6VHkr)\n\nIn the previous chapter we introduced async actions. But what about the following scenario: \"User gets data async from a server, server responds with either a success or error\". To handle not only the so called *Happy Path* we should also allow our signals to branch out into a different flows (which is just another chain of actions and operators) depending on the result of the previous action.\n\n### Http Provider\nSo let us build that scenario introducing *cerebral-http-provider*. *cerebral-http-provider* is a simple http-provider which enables you to request data from servers. You could have used any other HTTP library if you wanted to. We have already added it as a configuration of the controller. The concept of **Providers** will be covered in more detail in the next chapter.\n\nTo handle any kind of diverging execution in a signal we can use the concept of **paths**. A simple signal using paths and a sample async action named *getData* could look like this:\n\n```js\nController({\n  signals: {\n    submitClicked:[\n      getData, {\n        success:[\n          processResults,\n          showSuccessMessage\n        ],\n        error: [\n          showErrorMessage\n        ]\n      }\n    ]\n  }\n})\n```\n\nWhere *success* and *error* are our **paths**.\n\n### Grabbing a repo\nLet us implement something similar. We are going to grab information about github repos and display it in the toast:\n\n```js\n...\nimport {set, wait} from 'cerebral/operators'\nimport {state, props, string} from 'cerebral/tags'\n...\n{\n  buttonClicked: [\n    ...showToast(string`Loading data for repo: ${props`repo`}`, 2000),\n    getRepo, {\n      success: [\n        ...showToast(\n          string`\n            How cool is that. ${props`repo`}\n            has ${props`data.subscribers_count`}\n            subscribers and ${props`data.stargazers_count`}\n            stars!\n          `, 5000)\n      ],\n      error: [\n        ...showToast(\n          string`\n            Ooops something went wrong: ${props`data.message`}\n          `, 5000)\n      ]\n    }\n  ]\n}\n```\n\nAs you can see you can configure as many and whatever paths you like. Just add an object after an action and the action will know about possible paths to execute.\n\nAlso notice here that we plan our signal before implementing. Typically working in a team you would actually define the signal first and later implement the actions. It is the flow that is important to get right.\n\nThe **getRepo** action can look like this:\n\n```js\n...\nfunction getRepo({props, http, path}) {\n  return http.get(`/repos/cerebral/${props.repo}`)\n    .then((response) => {\n      return path.success({data: response.result})\n    })\n    .catch((error) => {\n      return path.error({data: error.result})\n    })\n}\n\nconst controller = Controller(...)\n```\n\nThe path **success** and **error** are now available inside the action because we defined those paths after the action in the chain. Last, but not least, we need to pass in a **repo** property on our button click:\n\n*App.js*\n```js\n...\n<button onClick={() => buttonClicked({repo: 'cerebral'})>\n  Update state\n</button>\n...\n```\n\n### Parallel execution\nBut there is an issue here. Did you notice that the message *Loading data for repo...* is blocking the execution for 2 seconds? It would be nice to indicate to Cerebral that actions can execute in parallel. Relax and take a sip from your coffee or beer, Cerebral has you covered!\n\nReplace your signal with the following snippet:\n\n```js\n{\n  buttonClicked: [\n    [\n      ...showToast(string`Loading data for repo: ${props`repo`}`, 2000),\n      getRepo, {\n        success: [\n           ...showToast(\n             string`\n               How cool is that. ${props`repo`}\n               has ${props`data.subscribers_count`}\n               subscribers and ${props`data.stargazers_count`}\n               stars!\n             `, 5000, 'success')\n        ],\n        error: [\n          ...showToast(\n            string`\n              Ooops something went wrong: ${props`data.message`}\n            `, 5000, 'error')\n        ]\n     }\n    ]\n  ]\n}\n```\n\nWhat is happening here? Did you spot the additional **[** and **]**? Well whenever Cerebral encounters an Array in an Array  **[action1, [action2, action3], action4]** it will start the actions within that array in parallel, so after action1 finishes action2 and action3 are executed right after each other, even though they return promises. After action2 and action3 finish, action4 will be executed.\n\nWe got, even more, flow control now, telling Cerebral to execute actions/operators in parallel by using JS arrays, and objects to diverge execution. By reading the signals you get a good understanding what the application will do. And don't forget, you do not even have to look at the code to understand this, the debugger reflects parallel execution, state changes, and even **paths** chosen.\n\n### Handling time\nBut... there is an other issue here. Did you notice that these **showToast** action factories do not cancel each other out? So the initial 2 second wait might close the toast where it was supposed to hold for 5 seconds after a success?\n\nInstead of using **wait**, we can use **debounce**. It is difficult to wrap your head around debounce. Simply said it ensures that whenever we run **showToast**, any pending toast timer will be discarded. But that is not enough, cause we have multiple *showToast* in our signal. So we need this behavior to be shared across them. Whenever any *showToast* is called, we want the existing pending toast timer to be discarded. This just ensures whenever we display a toast it will stay there for the time set unless a new toast is triggered.\n\n```js\n...\nimport {set, merge, debounce} from 'cerebral/operators'\nimport {state, props, string} from 'cerebral/tags'\n...\nconst toastDebounce = debounce.shared()\nfunction showToast (message, ms, type = null) {\n  return [\n    // We use merge as it supports evaluating tags in an object\n    merge(state`app.toast.message`, {type, message}),\n    toastDebounce(ms), {\n      continue: [\n        set(state`app.toast`, null)\n      ],\n      discard: []\n    }\n  ]\n}\n...\n```\n\nCongratulations! Now you know how to control your flow using **paths**. And if you need **parallel actions/operators**, well just add another array **[]** to the chain. You have even gotten insight into very complex control flow using **debounce**.\n\n### Challenge\n\nWe would like you to run two getRepo(...) requests. One to *cerebral/cerebral* and one to *cerebral/addressbar*. So it is a good idea to make *getRepo* a factory instead. On their successes, they should insert their data into the state tree.\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Paths"},"compute":{"raw":"# Compute\nNormally you use state directly from the state tree, but sometimes you need to compute values. Typically filtering lists, grabbing the projects of a user or other derived state.\n\nCerebral allows you to compute state that can be used in multiple contexts. Let us look at the signature:\n\n```js\nimport {compute} from 'cerebral'\n\nexport default compute(() => {\n  return 'foo'\n})\n```\n\nYou can now use this with **connect**:\n\n```js\nimport computedFoo from '../computedFoo'\n\nconnect({\n  foo: computedFoo\n})\n```\n\nYou can use it with operators in a signal:\n\n```js\nimport computedFoo from '../computedFoo'\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, computedFoo)\n]\n```\n\nOr you can resolve it inside an action if you need to:\n\n```js\nimport computedFoo from '../computedFoo'\n\nfunction myAction ({resolve}) {\n  const foo = resolve.value(computedFoo)\n}\n```\n\nYou can even compose it into a Tag:\n\n```js\nimport computedFoo from '../computedFoo'\nimport {state} from 'cerebral/tags'\n\nstate`${computedFoo}.bar`\n```\n\n## Getting data\nCompute can manually grab data related to where it is run. For example in **connect** you have access to both state and properties of the component. In a signal you would have access to state and the props to the signal. You do this by combining the **get** argument with a related tag:\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default compute((get) => {\n  return get(state`foo`) + get(props`bar`)\n})\n```\n\nCerebral now knows what paths this computed is interested in and can optimize its need to run again to produce a changed value.\n\n## Composing\nWhat makes compute very powerful is its ability to compose tags and other compute. Any tags you pass as arguments will be passed in as a value to the next function in line. The last argument of the function is always the **get** function.\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nconst computedItemUsers = compute(\n  state`items.${props`itemKey`}`,\n  (item, get) => {\n    return item.userIds.map((userId) => get(state`users.${userId}`))\n  }\n)\n\n// In connect\nconnect({\n  users: computedItemUsers\n})\n```\n\nIt uses the *itemKey* property from the component to grab the actual item. Then it grab each user based on the userIds of the item. You can also compose multiple compute together.\n\n```js\nconnect({\n  item: compute(filteredList, onlyAwesome)\n})\n```\n\nHere *filteredList* returns a list of filtered items, where *onlyAwesome* expects to receive a list and filters it again.\n\n```js\ncompute((list) => {\n  return list.filter((item) => item.isAwesome)\n})\n```\n\nIt is possible to combine tags and functions as many times as you would like:\n\n```js\ncompute(\n  state`currentItemKey`,\n  (currentItemKey, get) => {\n    return get(state`item.${currentItemKey}`)\n  },\n  state`isAwesome`,\n  (item, isAwesome) => {\n    return item.isAwesome === isAwesome\n  }\n)\n```\n\nTypically you get away with most things using Tags, but compute will help you with any other scenario where more \"umph\" is needed.\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://webpackbin-prod.firebaseapp.com//bins/-KdBaa45GzVJFOxU69Gp)\n\nIn our application we want to sum up the number of stars. We have already implemented a naive approach, which we are going to refactor. We created an action which adds the count together:\n\n```js\nfunction setStarsCount ({state}) {\n  state.set('starsCount',\n    state.get('repos.cerebral.stargazers_count') +\n    state.get('repos.addressbar.stargazers_count')\n  )\n}\n```\n\nThis is a perfectly okay approach for our simple scenario, but computing state like this can be tedious in large applications. We might want to use this state multiple places in our application and we want to make sure it is the same wherever we use it.\n\n### Computing\nIn Cerebral, we can automatically compute state by using **compute**. It is basically a function that takes any number of arguments to produce a value. Let us look at how it works with our scenario:\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default compute(\n  state`repos`,\n  function starsCount (repos) {\n    return Object.keys(repos).reduce((currentCount, repoKey) => {\n      return currentCount + repos[repoKey].stargazers_count\n    }, 0)\n  }\n)\n```\n\nWe depend on our repos state. Then we just count the stars and return it. When the compute is used with a component it will automatically track whatever dependencies it has and only runs when any of those dependencies change. You can use computed for even more granular control of the state and even component props dependencies, but you can read more about that later.\n\nLet us finish this example. To do so please create a new file named *starsCount.js* containing the snippet we just looked at. Then we would like to use our computed both in the signal and we also want to show the count in our component.\n\n### Replacing with computed\nLet us remove the **setStarsCount** action and refactor our signal to rather grab the repos first and then we update the state in one go. This just to show you different strategies.\n\nThe first thing we need to do is refactor our *getRepo* action factories to no longer return paths, just values. So either they return a result using the repo name as the key, or they will set an error.\n\n```js\n...\nfunction getRepo (repoName) {\n  function get ({http}) {\n    return http.get(`/repos/cerebral/${repoName}`)\n      .then((response) => {\n        return {[repoName]: response.result}\n      })\n      .catch((error) => {\n        return {error: error.result}\n      })\n  }\n\n  return get\n}\n...\n```\n\nThen we change how our signal looks:\n\n```js\n...\nimport starsCount from './computeds/starsCount'\n...\n{\n  buttonClicked: [\n    ...showToast(string`Loading data for repos...`),\n    [\n      getRepo('cerebral'),\n      getRepo('addressbar')\n    ],\n    when(props`error`), {\n      'true': [\n        ...showToast(string`Error: ${props`error`}`, 5000)\n      ],\n      'false': [\n        set(state`repos.cerebral`, props`cerebral`),\n        set(state`repos.addressbar`, props`addressbar`),\n        ...showToast(string`The repos have ${starsCount} stars`, 5000)\n      ]\n    }\n  ]\n}\n...\n```\n\nWe also use the *when* operator to figure out if we indeed have an error, diverging execution to show an error message. If that is not the case, we update our state tree on show the message.\n\nNote here that we also updated the *toast* to allow no time to passed in, causing it to stick.\n\n\n\nYou can use computeds with other computeds, directly in tags, with operators, in actions and in components. Lets update our **App** component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport starsCount from '.starsCount'\nimport Toast from './Toast'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  buttonClicked: signal`buttonClicked`,\n  starsCount\n},\n  function App ({title, subTitle, buttonClicked, starsCount}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>{subTitle}</h2>\n        <button onClick={() => buttonClicked()}>\n          Update star count ({starsCount})\n        </button>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\nThats it for now regarding *Compute*. Of course summarizing some numbers is pretty simple stuff, but you can compute anything.\n\nBut now it has only been Cerebral stuff, what if you want to use other libraries in your action flow? Well, refill your coffee or open up another drink and enjoy the next chapter introducing **the router**.\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Compute"},"routing":{"raw":"# Routing\nTypically applications uses a router. To instantiate the Cerebral router you install it as a separate package:\n\n`npm install cerebral-router@next --save`\n\nThen you instantiate it on the controller:\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst controller = Controller({\n  router: Router({\n    routes: {}, // Route definitions\n    query: false, // Query support\n    onlyHash: false, // Use hash urls\n    baseUrl: '/' // Only handle url changes on nested path\n  })\n})\n```\n\n## Defining routes\nRoutes in Cerebral does not affect the components, they affect signals. The signals puts your application in a specific state and then your components decides what to render based on that state. So the router is completely decoupled from your components. This is a very good thing because a route can now translate to any kind of state changes and side effects.\n\nLet us create a small app:\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\nimport HomeModule from './modules/Home'\nimport PostsModule from './modules/Posts'\n\nconst controller = Controller({\n  router: Router({\n    routes: {\n      '/': 'home.routed',\n      '/posts': 'posts.routed'\n    }\n  }),\n  state: {\n    currentPage: 'home'\n  },\n  modules: {\n    home: HomeModule,\n    posts: PostsModule\n  }\n})\n```\n\nAs we can see, when the root route is hit we want to trigger a signal that says that home is routed:\n\n*modules/Home/index.js*\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default {\n  signals: {\n    routed: [\n      set(state`currentPage`, 'home')\n    ]\n  }\n}\n```\n\nThe **/posts** route points to a different module and signal.\n\n*modules/Posts/index.js*\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default {\n  signals: {\n    routed: [\n      set(state`currentPage`, 'posts')\n    ]\n  }\n}\n```\n\n## Render based on state\nSo we do not render anything based on the route. We render based on state, like we do with everything else. A route never affects the components, it only affects your state.\n\n*components/App/index.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\nimport Home from '../Home'\nimport Posts from '../Posts'\n\nconst pages = {\n  home: Home,\n  posts: Posts\n}\n\nexport default Connect({\n  currentPage: state`currentPage`\n},\n  function App(props) {\n    const Page = pages[props.currentPage]\n\n    return <Page />\n  }\n)\n```\n\nSo this was simple page handling routing, but you can imagine that a route does not have to be a page change. It can be opening a modal, highlight some item or whatever. You are completely free to structure this. If some data fetching was needed before changing the page you would just put this in the signal.\n\n## Tutorial\n**Before you start,** [load this BIN on Webpackbin](https://webpackbin-prod.firebaseapp.com//bins/-KdBeIDJoRv0PQlF7uWU)\n\nNow that our tutorial UI gets more complex it is a good idea to separate it a little bit. We want a home tab and a repos tab. Our two repos should load when we click the repos tab or hit the url directly.\n\n### Adding some tabs\nLet us introduce the tabs first. We will just shove everything into our one component. Normally you would split this up into multiple components of course. You would probably also use JavaScript to map over a list of tabs or something similar, but let us be explicit now. Please change *App.js* to:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport Toast from './Toast'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  repos: state`repos`,\n  activeTab: state`activeTab`,\n  homeClicked: signal`homeClicked`,\n  reposClicked: signal`reposClicked`\n},\n  function App ({\n    title,\n    subTitle,\n    repos,\n    activeTab,\n    homeClicked,\n    reposClicked\n  }) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>{subTitle}</h2>\n        <div>\n          <div className='tabs'>\n            <div\n              onClick={() => homeClicked()}\n              className={`tab ${\n                activeTab === 'home' ? 'tab-active' : ''\n              }`}\n            >\n              Home\n            </div>\n            <div\n              onClick={() => reposClicked()}\n              className={`tab ${\n                activeTab === 'repos' ? 'tab-active' : ''\n              }`}\n            >\n              Repos\n            </div>\n          </div>\n          <br />\n          {\n            activeTab === 'home' ? (\n              <div>\n                Some awesome home page content\n              </div>   \n            ) : null\n          }\n          {\n            activeTab === 'repos' ? (\n              <div>\n                <ul>\n                  {Object.keys(repos).map((repoKey, index) => {\n                    const name = repos[repoKey].name\n                    const count = repos[repoKey].stargazers_count\n\n                    return (\n                      <li key={index}>\n                        {name} ({count})\n                      </li>\n                    )\n                  })}\n               </ul>\n              </div>   \n            ) : null\n          }\n        </div>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\n\nWe also need to add new state in *main.js*:\n```js\n...\n{\n  title: 'Hello from Cerebral!',\n  subTitle: 'Working on my state management',\n  toast: null,\n  repos: {},\n  activeTab: 'home'\n}\n...\n```\nAnd update the signals as well:\n```js\n...\n{\n  homeClicked: [\n    set(state`activeTab`, 'home')\n  ],\n  reposClicked: [\n    set(state`activeTab`, 'repos'),\n    ...showToast(string`Loading data for repo: ${props`repo`}`),\n    [\n      getRepo('cerebral'),\n      getRepo('addressbar')\n    ],\n    when(props`error`), {\n      'true': [\n        ...showToast(string`Error: ${props`error`}`, 5000, 'error')\n      ],\n      'false': [\n        set(state`repos.cerebral`, props`cerebral`),\n        set(state`repos.addressbar`, props`addressbar`),\n        ...showToast(string`The repos have ${starsCount} stars`, 5000, 'success')    \n      ]\n    }\n  ]\n}\n...\n```\nNow you can test-drive your changes. You should see the first tab activated. Now go to the debugger and change *activeTab* state to 'repos' and you will see the second tab. If you click the tabs you will actually trigger the signals which appear in the debugger. Nice! But what has this to do with Routing?\n\n### Introducing the router\nTraditional routers is a wrapper around your components and they manipulate what components to display based on the URL. That is not how routing works in Cerebral. In Cerebral you connect URLs to signals. So:\n\n1. A URL is hit or changed\n2. The respective signal is triggered putting your application in the correct state\n3. The components now renders based on the state of the application\n\nThis is a really good thing because most route changes require quite a few state changes and side effects, like server requests, to be run. This is exactly what signals do so well.\n\nLet us introduce **cerebral-router** to our project by adding an import to the top of our *./main.js*:\n\n```js\nimport Router from 'cerebral-router'\n\n```\n\nAnd go ahead by doing the router config as follows inside the controller:\n```js\n...\nconst controller = Controller({\n  ...\n  modules: {\n    router: Router({\n      routes: [\n        {path: '/', signal: 'homeClicked'},\n        {path: '/repos', signal: 'reposClicked'}\n      ],\n      onlyHash: true\n    })\n  },\n  ...\n})\n...\n```\n\nAs you can see, defining *routes* is as easy as linking them to *signals*. When you save and load up the BIN again you can go to the addressbar and change the url to **//repos**. You will now see the signal triggers and the repos content is shown. This is exactly what happens when you click the tab as well.\n\n### Challenge\n\nGo to your browsers addressbar and enter an invalid route like: localhost//*foo* and press Enter. Now check the log! The challenge is to add another route which catches those *unknown* routes, runs a signal and display a toast with an error. You probably need to read some more docs on the router to make this work.\n","title":"Routing"},"organize":{"raw":"# Organize\n\nCerebral uses a concept called **modules** to organize application code. These allow you to wrap state and signals into a namespace without isolating them. Any action run in a signal can change any state in the application.\n\nTypically the file structure for modules looks like this. We call it the **signals pattern**. Every signal has its own file.\n\n```js\n/modules\n  /home\n    /actions\n    /signals\n    index.js\nmain.js\n```\n\nThe **index.js** file is where you define the module. It is just an object where you can define state, signals and optionally sub modules.\n\n```js\nimport somethingHappened from './signals/somethingHappened'\n\nexport default {\n  state: {},\n  signals: {\n    somethingHappened\n  }\n}\n```\n\nYou might rather want to follow the **chains** pattern, which looks like this:\n\n```js\n/modules\n  /home\n    /actions\n    /chains\n    index.js\nmain.js\n```\n\n```js\nimport doThis from './chains/doThis'\n\nexport default {\n  signals: {\n    somethingHappened: doThis\n  }\n}\n```\n\nIn this case you rather composes your signals together inside the module definition.\n\n\nIn the **main.js** file, the module is added to the controller:\n\n```js\nimport {Controller} from 'cerebral'\nimport home from './modules/home'\n\nconst controller = Controller({\n  modules: {\n    home\n  }\n})\n```\n\nAny signal and state defined inside the *home* module will live on the namespace chosen during controller instantiation.\n\nAnd this is how an application scales: by defining modules and submodules. Actions or chains that are common are often placed in a folder called **common**:\n\n```js\n/common\n  /actions\n  /chains\n/modules\n  /home\n    /actions\n    /chains\n    index.js\nmain.js\n```\n\n## Components\n\nA very important point in Cerebral is that your components do not affect the structure of the application state. Modules are defined in terms of what makes sense for state and signals. Sometimes this is similar to how components are structured, but more often it is not. This is why components usually live in their own **components** folder, separated from the modules:\n\n```js\n/components\n  /Home\n    index.js\n/common\n  /actions\n  /chains\n/modules\n  /home\n    /actions\n    /chains\n    index.js\nmain.js\n```\n\nAnd this is it. You will never get in trouble creating a module because any action can change any state in your application. Modules are just a way to structure state and signals, not isolate them.\n\n## Tutorial\n\nBefore we begin you can have a look at [the solution over here](https://webpackbin-prod.firebaseapp.com//bins/-KdLD809oZId6qs7c9P7). Click the **download** button, which downloads the project as a Webpack project, extract the contents to a folder on your computer and make sure that you have installed [Node JS](https://nodejs.org/en/). From the command line, run:\n\n`npm install`\n\nThen you can run:\n\n`npm start`\n\nGo to *localhost:3000* in your browser. Now you have a starting point for playing more with Cerebral and make the final adjustments yourself. A new Webpack loader called **CSS Modules** has been added and also the **classnames** tool is ready to be used. These two features allows you to refactor the CSS of the application in a scalable way.\n\n### Folder structure\nSO! Welcome to the world of **modules**. We will build the following structure:\n```\n/src\n  /components\n    /App\n      index.js\n      styles.css\n    /Home\n      index.js\n      styles.css\n    /Repos\n      index.js\n      styles.css\n    /Toast\n      index.js\n      styles.css\n\n  /modules\n    /app\n      /factories\n        showToast.js\n      index.js\n    /home\n      /signals\n        routed.js\n      index.js\n    /repos\n      /factories\n        getRepo.js\n      /signals\n        routed.js\n      index.js\n\n  /computed\n    starsCount.js\n\n  controller.js\n  main.js\n```\n\nLet us do this step by step.\n\n### main.js\nOur main file should just wire things together, meaning that it wires the controller with the view.\n\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\nimport controller from './controller'\nimport App from './components/App'\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n### controller.js\nOur controller does the same kind of wiring. It wires the modules of our app to the controller and its configuration.\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\nimport Router from 'cerebral-router'\nimport HttpProvider from 'cerebral-provider-http'\nimport app from './modules/app'\nimport home from './modules/home'\nimport repos from './modules/repos'\n\nconst controller = Controller({\n  devtools: Devtools({\n    remoteDebugger: '127.0.0.1:8585'\n  }),\n  modules: {\n    app,\n    home,\n    repos,\n    router: Router({\n      routes: [\n        {path: '/', signal: 'home.routed'},\n        {path: '/repos', signal: 'repos.routed'}\n      ],\n      onlyHash: true\n    })\n  },\n  providers: [\n    HttpProvider({\n      baseUrl: 'https://api.github.com'\n    })\n  ]\n})\n```\n\nBasically our state and signals has been removed and we rather import modules instead.\n\n### modules/app\nThe app module will take care of what tab is currently active, our titles and the toast.\n\n*index.js*\n```js\nexport default {\n  state: {\n    title: 'Cerebral Tutorial',\n    subTitle: 'Routing',\n    activeTab: 'home',\n    toast: null\n  }\n}\n```\n\nIt will also hold the **showToast** factory as we consider it a \"global app thing\", even though it is currently only used by the **repos** module.\n\n*factories/showToast.js*\n```js\nimport {set, merge, debounce} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nconst toastDebounce = debounce.shared()\nfunction showToast (message, ms, type = null) {\n  if (!ms) {\n    return [\n      merge(state`app.toast`, {message, type})\n    ]\n  }\n\n  return [\n    merge(state`app.toast`, {message, type}),\n    toastDebounce(ms), {\n      continue: [\n        set(state`app.toast`, null)\n      ],\n      discard: []\n    }\n  ]\n}\n\nexport default showToast\n```\n\nNote that the paths to the state has changed, since **toast** now is under the namespace **app**.\n\n### modules/home\nThe home module does not have any state, but it does have a signal related to being clicked.\n\n*index.js*\n```js\nimport clicked from './signals/clicked'\n\nexport default {\n  signals: {\n    clicked\n  }\n}\n```\n\n*signals/clicked.js*\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`app.activeTab`, 'home')\n]\n```\n\nAs you can see any signal can point to any state. This allows you to organize your app in a way that makes sense without worrying about isolation. This is really important, because in complex applications isolation causes big challenges.\n\n### modules/repos\nOur repos module holds the list of repos and also holds the signal for opening the repos tab.\n\n*index.js*\n```js\nimport clicked from './signals/clicked'\n\nexport default {\n  state: {\n    list: {}\n  },\n  signals: {\n    clicked\n  }\n}\n```\n\n*signals/clicked.js*\n```js\nimport {set, when} from 'cerebral/operators'\nimport {state, props, string} from 'cerebral/tags'\nimport getRepo from '../factories/getRepo'\nimport showToast from '../../app/factories/showToast'\nimport starsCount from '../../computed/starsCount'\n\nexport default [\n  set(state`app.activeTab`, 'repos'),\n  ...showToast(string`Loading data for repos...`),\n  [\n    getRepo('cerebral'),\n    getRepo('addressbar')\n  ],\n  when(props`error`), {\n    'true': [\n      ...showToast(string`Error: ${props`error`}`, 5000, 'error')\n    ],\n    'false': [\n      set(state`repos.list.cerebral`, props`cerebral`),\n      set(state`repos.list.addressbar`, props`addressbar`),\n      ...showToast(string`The repos have ${starsCount} stars`, 5000, 'success')    \n    ]\n  }\n]\n```\n\n*factories/getRepo.js*\n```js\nfunction getRepoFactory (repoName) {\n  function getRepo ({http}) {\n    return http.get(`/repos/cerebral/${repoName}`)\n      .then((response) => {\n        return {[repoName]: response.result}\n      })\n      .catch((error) => {\n        return {error: error.result}\n      })\n  }\n\n  return getRepo\n}\n\nexport default getRepoFactory\n```\n\nThis is a good example of how Cerebral works. Note that there are no imports to this action factory. You just write out the logic of it, cause the context is decoupled from the actual logic.\n\n### components/App\nWe also need to split up our components a bit. The app component is now cleaned up a bit and it is using **CSS Modules** and the **classnames** tool.\n\n*index.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport styles from './styles.css'\nimport classnames from 'classnames'\nimport Toast from './Toast'\nimport Home from '../Home'\nimport Repos from '../Repos'\n\nexport default connect({\n  title: state`app.title`,\n  subTitle: state`app.subTitle`,\n  activeTab: state`app.activeTab`,\n  homeClicked: signal`home.clicked`,\n  reposClicked: signal`repos.clicked`\n},\n  function App ({\n    title,\n    subTitle,\n    activeTab,\n    homeClicked,\n    reposClicked\n  }) {\n    return (\n      <div>\n        <h1 className={styles.center}>{title}</h1>\n        <h2 className={styles.center}>{subTitle}</h2>\n        <div>\n          <div className={styles.tabs}>\n            <div\n              onClick={() => homeClicked()}\n              className={classnames(styles.tab, {\n                [styles.activeTab]: activeTab === 'home'\n              })}\n            >\n              Home\n            </div>\n            <div\n              onClick={() => reposClicked()}\n              className={classnames(styles.tab, {\n                [styles.activeTab]: activeTab === 'repos'\n              })}\n            >\n              Repos\n            </div>\n          </div>\n          <br />\n          {activeTab === 'home' ? <Home /> : null}\n          {activeTab === 'repos' ? <Repos /> : null}\n        </div>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\nNote here how css class names are actually being exported as a module to the component file. Allowing it to point to these classes with plain JavaScript. That is what css modules is all about and they are great for keeping you sane writing CSS in large applications. Lets look at how to refactor the css file:\n\n*styles.css*\n```css\n.center {\n  text-align: center;\n}\n\n.tabs {\n  display: flex;\n}\n\n.tab {\n  flex: 1;\n  font-size: 18px;\n  cursor: pointer;\n  text-align: center;\n  padding: 5px;\n}\n\n.activeTab {\n  background-color: #0086b3;\n  border-radius: 3px;\n  color: #FFF;\n}\n```\n\n### Finish the refactor\nWe have shown you the idea of the refactor here and now you can finish it. You need to refactor the following:\n\n1. Home component and styles (if any)\n2. Repos component and styles\n3. starsCount computed\n\nAnd some notes:\n\n1. Remember to changes paths to signals and state, they are now namespaced. For example: **repos.list** instead of **repos**\n2. There should not be any **styles.css** file linked to in **index.html**. All CSS should be related to a specific component\n\nCongratulations! You have reached the end of our *Get Started* - tutorial.\nThere is a lot of other good stuff on this website. So please check it out!\n\nWhen you are done with the refactor you can try to create a form input where on **onSubmit** it will fetch that repo and show its stars count. Remember to **preventDefault** on the form submit event! :)\n\nBuild your next big thing with **Cerebral** and please tell us about it on [discord chat](https://discord.gg/0kIweV4bd2bwwsvH) :)\n","title":"Organize"},"providers":{"raw":"# Providers\n\nProviders are added to the context of every action executed by a signal. Providers can be everything from a tool you are already using, to something Cerebral specific. The point of providers is to separate side effects from execution. That means you can create all the logic you want with chains and actions without creating any dependencies to other tools. This makes them highly testable and generally gives you more flexibility.\n\nAdding a provider is done by:\n\n```js\nimport {Controller} from 'cerebral'\n\nfunction MyProvider (context, functionDetails, payload, prevPayload) {\n  // The current context object, which can be mutated\n  context\n\n  // The details of the action running, like name, index (id) etc.\n  functionDetails\n\n  // The current payload passed to the action\n  payload\n\n  // The previous payload\n  prevPayload\n\n  // You have to return the context after it has bee mutated\n  return context\n}\n\nconst controller = Controller({\n  providers: [\n    MyProvider\n  ]\n})\n```\n\n## Context Provider\nThere is a built in provider with Cerebral you can use to expose tools. The provider will wrap the tool so that you can see its usage in the debugger:\n\n```js\nimport {Controller} from 'cerebral'\nimport {ContextProvider} from 'cerebral/providers'\nimport axios from 'axios'\nimport uuid from 'uuid'\n\nconst controller = Controller({\n  providers: [\n    ContextProvider({axios, uuid})\n  ]\n})\n```\n\nNote that some tools has a very complex API that **ContextProvider** has a hard time analyzing. With these kinds of tools it is a better idea to create your own provider, exposing APIs that you actually use from the original tool.\n\n## Creating a provider\nYou can use providers for pretty much anything, though typically it is to handle some kind of side effect. Examples of providers is [cerebral-provider-firebase](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-provider-firebase) and [cerebral-provider-http](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-provider-http).\n\n```js\nfunction MyProvider (options = {}) {\n  let cachedProvider = null\n\n  function createProvider (context) {\n    return {\n      doSomething() {},\n      doSomethingElse() {}\n    }\n  }\n\n  return (context) => {\n    context.myProvider = cachedProvider = cachedProvider || createProvider(context)\n\n    if (context.debugger) {\n      context.debugger.wrapProvider('myProvider')\n    }\n\n    return context\n  }\n}\n```\n\nThis is a very typical setup for a provider. It creates and caches it. It also wraps and methods exposed if the debugger is available, tracking its execution.\n","title":"Providers"},"test":{"raw":"# Test\n\nCerebral makes it easy to test your application components and business logic.\n\n## Components\nThe **Container** you use to expose Cerebral to your components can also be used when testing, but you can also use the **StateContainer** which allows you to pass state down to your components as if it was extracted from the Cerebral controller.\n\n```js\nimport React from 'react'\nimport {mount} from 'enzyme'\nimport {StateContainer} from 'cerebral/react'\n\nimport Foo from './Foo'\n\ndescribe('<Foo />', () => {\n  it('allows us to set props', () => {\n    const state = {\n      foo: 'bar'\n    }\n    const wrapper = mount(\n      <StateContainer state={state}>\n        <Foo />\n      </StateContainer>\n    )\n    expect(wrapper.find('.foo')).to.have.length(1)\n  })\n})\n```\n\nThis approach allows you to pass down state wherever you want and ensure the components render as expected.\n\n## Computes\n\nThe `runCompute` test helper accepts the `compute` and `fixtures` arguments and returns the compute output.\n\n```js\nvar result = runCompute(compute, state)\n```\n\nThe optional `fixture` argument should be an object that contains any of the following:\n\n```js\n{\n  state: {}, // test state\n  props: {}  // props passed to the computed\n}\n```\n\n### Example\n\n```js\nimport {props, state} from 'cerebral/tags'\nimport {runCompute} from 'cerebral/test'\n\nimport Multiply from './Multiply'\n\nit('should multiply by the specified number', () => {\n  const multiply = Multiply(state`number`, props`number`)\n  const result = runCompute(multiply, {\n    state: { number: 5 },\n    props: { number: 2 }\n  })\n  assert.equal(result, 10)\n})\n```\n\n## Actions\n\nThe `runAction` test helper accepts the `action` and `fixture` arguments and returns a promise.\n\n```js\nrunAction(action, fixture).then((result) => {})\n```\n\nThe optional `fixture` argument should be an object that contains any of the following:\n\n```js\n{\n  state: {}, // test state\n  props: {}, // props passed to the action\n  // any other options that can be passed to the\n  // cerebral controller, including router, providers...\n}\n```\n\nThe `result` object passed when the promise resolves contains `state`, `controller`, `props` and `output` properties.\n\n```\n{\n  state,\n  controller,\n  props: {\n    // props data received by action\n  },\n  output: {\n    // action output data\n  }\n}\n```\n\n### Example\n\n```js\nimport {state} from 'cerebral/tags'\nimport {runAction} from 'cerebral/test'\n\nimport Increment from './Increment'\n\nit('should increment numbers in state', () => {\n  const increment = Increment(state`number`)\n\n  return runAction(increment, { state: { number: 1 } })\n    .then(({state}) => assert.equal(state.number, 2))\n})\n```\n\n## Signals\n\n### runSignal\n\nThe `runSignal` test helper accepts the `signal` (chain of actions or signal name) and `fixture` arguments and returns a promise. `runSignal` is designed to be called one time, to test calling multiple signals in a single test see the `RunSignal` factory below.\n\n```js\nrunSignal(signal, fixture. options).then((result) => {})\n```\n\nThe optional `fixture` argument should be an object that contains any of the following:\n\n```js\n{\n  state: {}, // test state\n  props: {}, // props passed to the signal\n  // any other options that can be passed to the\n  // cerebral controller, including signals, modules, router, providers...\n}\n```\n\nIf the `signal` argument is passed as a string, then the signal must be defined within the fixtures.\n\nThe optional `options` argument contain the the following options:\n\n`recordActions: true|false|'byName'`\n\nWhen `recordActions: true` is specified each action will record its props/output against its index within the signal action chain. When `recordActions: 'byName'` is specified each action will record its output against an named property in the result.\n\nThe `result` object passed when the promise resolves contains `state`, `controller` and an object for each named action in the signal chain with the same name as the actions with `props` and `output` properties.\n\n```\n{\n  state,\n  controller,\n  '2': {\n    props: {\n      // props data\n    },\n    output: {\n      // action output data\n    }\n  },\n  '1': {\n    props: {\n      // props data\n    },\n    output: {\n      // action output data\n    }\n  }\n}\n```\n\n#### Example\n\n```js\nimport {runSignal} from 'cerebral/test'\n\n// the buttonClicked signal has two actions: validateForm and updateIsValid\nimport buttonClicked from './buttonClick'\n\nit('should handle button clicks', () => {\n  const fixture = {\n    state: { isValid: false },\n    props: { buttonName: 'submit' }\n  }\n  return runSignal(buttonClicked, fixture, {recordActions: 'byName'})\n    .then(({validateForm, updateIsValid, state}) => {\n      assert.equal(validateForm.props.buttonName, 'submit')\n      assert.equal(updateIsValid.props.isValid, true)\n      assert.equal(state.isValid, true)\n    })\n})\n```\n\n### RunSignal factory\n\nThe `RunSignal` factory is similar to run signal except that it will return a runSignal function that can be called many times without resetting the controller in between.\n\n```js\nconst runSignal = Run(fixture. options)\nrunSignal(signal, props).then((result) => {})\n```\n\n#### Example\n\n```js\nimport {RunSignal} from 'cerebral/test'\n\nit('should accumulate a count', () => {\n  const runMathSignal = RunSignal({\n    modules: {\n      math: math()\n    }\n  })\n  return runMathSignal('math.plusOne').then(({state}) => {\n    assert.equal(state.math.count, 1)\n    return runMathSignal('math.plusTwo').then(({state}) => {\n      assert.equal(state.math.count, 3)\n    })\n  })\n})\n```\n","title":"Test"}},"tools":{"index":{"raw":"# cerebral-provider-http\n\n## Install\n`npm install cerebral-provider-http@next --save`\n\n## Description\nThe HTTP provider exposes the ability to do HTTP requests both in actions and directly in signals. It supports **cors** and file upload, with progress handling. It default to **json**, but you can configure it to whatever you want.\n\n```js\nimport {set} from 'cerebral/operators'\nimport {httpGet} from 'cerebral-provider-http'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpGet(`/items/${props`itemKey`}`), {\n    success: [\n      set(state`app.currentItem`, props`result`)\n    ],\n    error: [\n      set(state`app.error`, props`result`)\n    ]\n  }\n]\n```\n\nAll factories of HTTP provider supports template tags.\n\n## API\n\n### instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport HttpProvider from 'cerebral-provider-http'\n\nconst controller = Controller({\n  providers: [\n    HttpProvider({\n      // Prefix all requests with this url\n      baseUrl: 'https://api.github.com',\n\n      // Any default headers to pass on requests\n      headers: {\n        'Content-Type': 'application/json; charset=UTF-8',\n        'Accept': 'application/json'\n      },\n\n      // When talking to cross origin (cors), pass cookies\n      // if set to true\n      withCredentials: false\n    })\n  ]\n})\n```\n\nYou can update these default options in an action:\n\n```js\nfunction updateDefaultHttpOptions({http}) {\n  http.updateOptions({\n    // Updated options\n  })\n}\n```\n\n### request\n\n```js\nfunction someGetAction ({http}) {\n  return http.request({\n    // Any http method\n    method: 'GET',\n\n    // Url you want to request to\n    url: '/items'\n\n    // Request body as object. Will automatically be stringified if json and\n    // urlEncoded if application/x-www-form-urlencoded\n    body: {},\n\n    // Query as object, will automatically be urlEncoded\n    query: {},\n\n    // If cross origin request, pass cookies\n    withCredentials: false,\n\n    // Any additional http headers, or overwrite default\n    headers: {},\n\n    // A function or signal path (foo.bar.requestProgressed) that\n    // triggers on request progress. Passes {progress: 45} etc.\n    onProgress: null\n  })\n}\n```\n\n### get\n\n*action*\n```js\nfunction someGetAction ({http}) {\n  return http.get('/items', {\n    // QUERY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpGet} from 'cerebral-provider-http'\n\nexport default [\n  httpGet('/items'), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n### post\n\n*action*\n```js\nfunction somePostAction ({http}) {\n  return http.post('/items', {\n    // BODY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpPost} from 'cerebral-provider-http'\nimport {props} from 'cerebral/tags'\n\nexport default [\n  httpPost('/items', {\n    title: props`itemTitle`,\n    foo: 'bar'\n  }), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n### put\n\n*action*\n```js\nfunction somePutAction ({http}) {\n  return http.put('/items/1', {\n    // BODY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpPost} from 'cerebral-provider-http'\n\nexport default [\n  httpPut('/items', {\n    // BODY object\n  }), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n### patch\n\n*action*\n```js\nfunction somePatchAction ({http}) {\n  return http.patch('/items/1', {\n    // BODY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpPost} from 'cerebral-provider-http'\nimport {state, props, string} from 'cerebral/tags'\n\nexport default [\n  httpPatch(string`/items/${props`itemId`}`, state`patchData`), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n### delete\n\n*action*\n```js\nfunction someDeleteAction ({http}) {\n  return http.delete('/items/1', {\n    // QUERY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpPost} from 'cerebral-provider-http'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  httpDelete(string`/items/${state`currentItemId`}`), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n### uploadFile\n\n**COMING SOON**\n\n### response\n\n```js\nfunction someGetAction ({http}) {\n  return http.get('/items')\n    // All status codes between 200 - 300, including 200\n    .then((response) => {\n      response.status // Status code of response\n      response.result // Parsed response text\n      // The response headers are returned as an object with lowercase header\n      // names as keys. Values belonging to the same key are separated by ', '.\n      response.headers // Parsed response headers\n    })\n    // All other status codes\n    .catch((response) => {\n      response.status // Status code of response\n      response.result // Parsed response text\n      response.headers // Parsed response headers\n    })\n}\n```\n\n### abort\nYou can abort any running request, causing the request to resolve as status code **0** and set an **isAborted** property on the response object.\n\n```js\nfunction searchItems({input, state, path, http}) {\n  http.abort('/items*') // regexp string\n  return http.get(`/items?query=${input.query}`)\n    .then(path.success)\n    .catch((response) => {\n      if (response.isAborted) {\n        return path.abort()\n      }\n\n      return path.error(response)\n    })\n}\n\nexport default [\n  searchItems, {\n    success: [],\n    error: [],\n    abort: []\n  }\n]\n```\n\n### cors\nCors has been turned into a \"black box\" by jQuery. Cors is actually a very simple concept, but due to a lot of confusion of \"Request not allowed\", **cors** has been an option to help out. In HttpProvider we try to give you the insight to understand how cors actually works.\n\nCors has nothing to do with the client. The only client configuration related to cors is the **withCredentials** option, which makes sure cookies are passed to the cross origin server. The only requirement for cors to work is that you pass the correct **Content-Type**. Now, this depends on the server in question. Some servers allows any content-type, others require a specific one. These are the typical ones:\n\n- text/plain\n- application/x-www-form-urlencoded\n- application/json; charset=UTF-8\n\nNote that this is only related to the **request**. If you want to define what you want as response, you set the **Accept** header, which is *application/json* by default.\n","title":"cerebral-provider-http"},"firebase":{"raw":"# cerebral-provider-firebase\n\n## Install\n`npm install cerebral-provider-firebase`\n\n## Description\nThe Firebase provider is a Cerebral friendly wrapper around the Firebase client. By default the Firebase client is heavily event based, even just getting some value, handling authentication etc. This is useful in some types of apps, but Cerebral has a very straight forward way of thinking about side effects. You will find that a lot of the API exposed by the Firebase client is simplified!\n\n\n## API\n\n### instantiate\n\n```javascript\nimport {Controller} from 'cerebral'\nimport FirebaseProvider from 'cerebral-provider-firebase'\n\nconst controller = Controller({\n  providers: [\n    FirebaseProvider({\n      config: {\n        apiKey: '{apiKey}',\n        authDomain: '{authDomain}',\n        databaseURL: '{databaseURL}',\n        storageBucket: '{storageBucket}'\n      },\n      // When using tasks and firebase queue you can prefix\n      // the specs triggered. This is useful in development\n      // when multiple developers are working on the\n      // same instance\n      specPrefix: 'CJ'\n    })\n  ]\n})\n```\n\n**Important notes**\n\n- The Cerebral firebase provider uses **dot** notation to keep consistency with Cerebral itself\n\n- All factories supports template tags, allowing you to dynamically create paths and points to values\n\n### set\nWrite data to this database location. This will overwrite any data at this location and all child locations. Passing **null** for the new value is equivalent to calling remove(); all data at this location or any child location will be deleted.\n\n*action*\n```javascript\nfunction someAction({firebase, path}) {\n  return firebase.set('foo.bar', 'baz')\n    .then(path.success)\n    .catch(path.error)\n}\n```\n\n*factory*\n```javascript\nimport {props} from 'cerebral/tags'\nimport {set} from 'cerebral-provider-firebase'\n\nexport default [\n  set('foo.bar', props`foo`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### update\nAs opposed to the set() method, update() can be use to selectively update only the referenced properties at the current location (instead of replacing all the child properties at the current location).\n\n*action*\n```javascript\nfunction someAction({firebase, path}) {\n  return firebase.update('some.path', {\n    'foo': 'bar',\n    'items.item1.isAwesome': true\n  })\n    .then(path.success)\n    .catch(path.error)\n}\n```\n\n*factory*\n```javascript\nimport {props} from 'cerebral/tags'\nimport {update} from 'cerebral-provider-firebase'\n\nexport default [\n  update('some.path', {\n    'foo.bar': props`bar`,\n    'foo.baz': props`baz`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### push\nGenerates a new child location using a unique key and returns its reference from the action. An example being `{key: \"-KWKImT_t3SLmkJ4s3-w\"}`.\n\n*action*\n```javascript\nfunction someAction({firebase, path}) {\n  return firebase.push('users', {\n    name: 'Bob'\n  })\n    .then(path.success)\n    .catch(path.error)\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {push} from 'cerebral-provider-firebase'\n\nexport default [\n  push('users', state`newUser`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### remove\nRemove the data at this database location.\n\n*action*\n```javascript\nfunction someAction({ firebase, path}) {\n  return firebase.remove('foo.bar')\n    .then(path.success)\n    .catch(path.error)\n}\n```\n\n*factory*\n```javascript\nimport {props, string} from 'cerebral/tags'\nimport {remove} from 'cerebral-provider-firebase'\n\nexport default [\n  remove(string`users.${props`userKey`}`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### transaction\nAtomically modifies the data at the provided location.\n\nUnlike a normal set(), which just overwrites the data regardless of its previous value, transaction() is used to modify the existing value to a new value, ensuring there are no conflicts with other clients writing to the same location at the same time.\n\nTo accomplish this, you pass transaction() an update function which is used to transform the current value into a new value. If another client writes to the location before your new value is successfully written, your update function will be called again with the new current value, and the write will be retried. This will happen repeatedly until your write succeeds without conflict or you abort the transaction by not returning a value from your update function.\n\n*action*\n```javascript\nfunction someAction({firebase, path}) {\n\n  function transactionFunction(currentData){\n    if (currentData === null) {\n      return { foo: 'bar' }\n    }\n\n    return // Abort the transaction.\n  }\n\n  return firebase.transaction('some.transaction.path', transactionFunction)\n    .then((result) => {\n      if(result.committed){\n        return path.success({result: result.value})\n      } else {\n        return path.abort()\n      }\n    })\n    .catch(path.error)\n}\n```\n\n*factory*\n```javascript\nimport {transaction} from 'cerebral-provider-firebase'\n\nfunction transactionFunction(currentData){\n  if (currentData === null) {\n    return { foo: 'bar' }\n  }\n\n  return // Abort the transaction.\n}\n\nexport default [\n  transaction('foo.bar', transactionFunction), {\n    success: [],\n    error: []\n  }\n]\n```\n\nNote: Modifying data with set() will cancel any pending transactions at that location, so extreme care should be taken if mixing set() and transaction() to update the same data.\n\nNote: When using transactions with Security and Firebase Rules in place, be aware that a client needs .read access in addition to .write access in order to perform a transaction. This is because the client-side nature of transactions requires the client to read the data in order to transactionally update it.\n\n### value\n\n*action*\n```js\nfunction someAction({ firebase, path }) {\n  return firebase.value('someKey.foo')\n    .then(path.success)\n    .catch(path.error);\n}\n```\nThe result will be available as `{ key: 'foo', value: 'bar' }`. Or `{ error: 'error message'}`.\n\n*factory*\n```javascript\nimport {value} from 'cerebral-provider-firebase'\n\nexport default [\n  value('foo.bar'), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### onValue\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  firebase.onValue('someKey.foo', 'someModule.fooUpdated',  {\n    payload: {}, // Merged with the payload passed on new data\n  });\n}\n```\nThis will **NOT** immediately grab the value and trigger the signal passed, the first event is discarded for more predictable behaviour. To grab existing value, just use `value`.\n\nTo stop listening for updates to the value:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('someKey.foo', 'onValue', 'someModule.fooUpdated');\n}\n```\n\n*factory*\n```javascript\nimport {onValue} from 'cerebral-provider-firebase'\n\nexport default [\n  onValue('foo.bar', 'some.signal')\n]\n```\n\n### onChildAdded\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildAdded('posts', 'posts.postAdded', {\n    payload: {}, // Merged with the payload passed on new data\n    limitToFirst: 5, // Read Firebase docs\n    limitToLast: 5, // Read Firebase docs\n    startAt: 5, // Read Firebase docs\n    endAt: 5, // Read Firebase docs\n    equalTo: 5, // Read Firebase docs\n    orderByChild: 'count', // Read Firebase docs\n    orderByKey: true, // Read Firebase docs\n    orderByValue: true // Read Firebase docs\n  });\n}\n```\nThis will immediately grab and trigger the signal `posts.postAdded` for every post grabbed. Note this is just registering a listener, not returning a value from the action. The signal is triggered with the payload: `{ key: 'someKey', value: {} }`.\n\nTo stop listening for updates to the posts:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildAdded', 'posts.postAdded');\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {onChildAdded} from 'cerebral-provider-firebase'\n\nexport default [\n  onChildAdded('foo.bar', 'some.signal', {\n    orderByChild: 'count',\n    limitToFirst: state`config.limitToFirst`\n  })\n]\n```\n\n### onChildRemoved\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildRemoved('posts', 'posts.postRemoved', {\n    // Same options as above\n  });\n}\n```\nThis will trigger the signal `posts.postRemoved` whenever a post is removed from the selection. The signal is triggered with the payload: `{ key: 'someKey' }`.\n\nTo stop listening:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildRemoved', 'posts.postRemoved');\n}\n```\n\n*factory*\n```javascript\nimport {onChildRemoved} from 'cerebral-provider-firebase'\n\nexport default [\n  onChildRemoved('foo.bar', 'some.signal', {\n    // Same options as above\n  })\n]\n```\n\n### onChildChanged\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildChanged('posts', 'posts.postChanged', {\n    // Same options as above\n  });\n}\n```\nThis will trigger the signal `posts.postChanged` whenever a post is changed in the selection. The signal is triggered with the payload: `{ key: 'someKey', value: {} }`.\n\nTo stop listening:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildChanged', 'posts.postChanged');\n}\n```\n\n*factory*\n```javascript\nimport {onChildChanged} from 'cerebral-provider-firebase'\n\nexport default [\n  onChildChanged('foo.bar', 'some.signal', {\n    // Same options as above\n  })\n]\n```\n\n### task\nIf you are using the [firebase-queue](https://github.com/firebase/firebase-queue) and need to create tasks, you can do that with:\n\n*action*\n```js\nfunction someAction({ firebase, path, state }) {\n  return firebase.task('create_post', {\n    uid: state.get('app.user.uid'),\n    text: state.get('posts.newPostText')\n  })\n    .then(path.success)\n    .catch(path.error);\n}\n```\n\nThis will add a task at `queue/tasks`. There is no output from a resolved task, it just resolves when the action has been processed.\n\n*factory*\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {task} from 'cerebral-provider-firebase'\n\nexport default [\n  task('some_task', {\n    uid: state`user.uid`,\n    data: props`data`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### getUser\nWill resolve to `{user: {}}` if user exists. If user was redirected from Facebook/Google etc. as part of first sign in, this method will handle the confirmed registration of the user.\n\n*action*\n```js\nfunction someAction({ firebase, path }) {\n  return firebase.getUser()\n    .then(path.success)\n    .catch(path.error);\n}\n```\n\n*factory*\n```javascript\nimport {getUser} from 'cerebral-provider-firebase'\n\nexport default [\n  getUser(), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### signInAnonymously\nThis login will method will resolve to existing anonymous or create a new one for you. Resolves to `{user: {}}`.\n\n*action*\n```js\nfunction someAction({ firebase, path }) {\n  return firebase.signInAnonymously()\n    .then(path.success)\n    .catch(path.error);\n}\n```\n\n*factory*\n```javascript\nimport {signInAnonymously} from 'cerebral-provider-firebase'\n\nexport default [\n  signInAnonymously(), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### createUserWithEmailAndPassword\nRegister a new user with email and password. Resolves to `{user: {}}`.\n\n*action*\n```js\nfunction someAction({ firebase, path, state }) {\n  const email = state.get('register.email')\n  const password = state.get('register.password')\n\n  return firebase.createUserWithEmailAndPassword(email, password)\n    .then(path.success)\n    .catch(path.error);\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {createUserWithEmailAndPassword} from 'cerebral-provider-firebase'\n\nexport default [\n  createUserWithEmailAndPassword(state`newUser.email`, state`newUser.password`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### signInWithEmailAndPassword\nSign in a user with email and password. Resolves to `{user: {}}`.\n\n*action*\n```js\nfunction someAction({ firebase, path, state }) {\n  const email = state.get('register.email')\n  const password = state.get('register.password')\n\n  return firebase.signInWithEmailAndPassword(email, password)\n    .then(path.success)\n    .catch(path.error);\n}\n```\n\n*factory*\n```javascript\nimport {props} from 'cerebral/tags'\nimport {signInWithEmailAndPassword} from 'cerebral-provider-firebase'\n\nexport default [\n  signInWithEmailAndPassword(props`email`, props`password`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### signInWith{PROVIDER}\nSign in a user with Facebook, Google or Github. Resolves to `{user: {}}`, or redirects.\n\n*action*\n```js\nfunction someAction({ firebase, path, state }) {\n  return firebase.signInWithFacebook({\n    redirect: false, // Use popup or redirect. Redirect typically for mobile\n    scopes: [] // Facebook scopes to access\n  })\n    .then(path.success)\n    .catch(path.error);\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {signInWithFacebook} from 'cerebral-provider-firebase'\n\nexport default [\n  signInWithFacebook({\n    redirect: state`useragent.media.small`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\nSimilar you can sign in with Google or GitHub.\nJust use `signInWithGoogle` or `signInWithGithub` instead of `signInWithFacebook`.\n\n### linkWithFacebook{PROVIDER}\nLink an anonymous account with Facebook, Google or Github. Resolves to `{user: {}}`, or redirects.\n\n*action*\n```js\nfunction someAction({ firebase, path, state }) {\n  return firebase.linkWithFacebook({\n    redirect: false, // Use popup or redirect. Redirect typically for mobile\n    scopes: [] // Facebook scopes to access\n  })\n    .then(path.success)\n    .catch(path.error);\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {linkWithFacebook} from 'cerebral-provider-firebase'\n\nexport default [\n  linkWithFacebook({\n    redirect: state`useragent.media.small`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\nSimilar you can sign in with Google or GitHub.\nJust use `linkWithGoogle` or `linkWithGithub` instead of `linkWithFacebook`.\n\n### signOut\nSign out user. **getUser** will now not resolve a user anymore.\n\n*action*\n```js\nfunction someAction({ firebase, path }) {\n  return firebase.signOut()\n    .then(path.success)\n    .catch(path.error);\n}\n```\n\n*factory*\n```javascript\nimport {signOut} from 'cerebral-provider-firebase'\n\nexport default [\n  signOut(), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### sendPasswordResetEmail\n\n*action*\n```js\nfunction someAction({ firebase, path, state }) {\n  return firebase.sendPasswordResetEmail(state.get('user.email'))\n    .then(path.success)\n    .catch(path.error);\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {sendPasswordResetEmail} from 'cerebral-provider-firebase'\n\nexport default [\n  sendPasswordResetEmail(state`user.email`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### setOnDisconnect\nSets a value when Firebase detects user has disconnected.\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  firebase.setOnDisconnect(`activeUsers.${state.get('app.user.uid')}`, 'someValue')\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {setOnDisconnect} from 'cerebral-provider-firebase'\n\nexport default [\n  setOnDisconnect(string`activeUsers.${state`app.user.uid`}`, null)\n]\n```\n\n### cancelOnDisconnect\nCancel setting a value when Firebase detects disconnect.\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  firebase.cancelOnDisconnect()\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {cancelOnDisconnect} from 'cerebral-provider-firebase'\n\nexport default [\n  cancelOnDisconnect()\n]\n```\n\n### put\n\nUpload a new file at the given location. Please note that the file is **not** stored inside the realtime database but into Google Cloud Storage (please consult filrebase documentation). This means that you need to take care of storage security as well.\n\nThe options expect a progress field that can be either a signal (that will be called with `progress`, `totalBytes` and `bytesTransferred`) or a state path to directly set `progress` value.\n\nNote that `put` expects a folder as first argument and will use the name of the provided file. If you want to control the filename, add this in the options. In this case, make sure to respect file type and extension...\n\nOn success, `props` contains an `url` and the `filename`.\n\n```js\nimport {props, signal, state, string} from 'cerebral/tags'\nimport {put} from 'cerebral-provider-firebase'\n\n// we expect props.file to contain a file provided by\n// a user in an <input type='file' />\nexport default [\n  put(string`posts.all.${props`postId`}`, props`file`, {\n    progress: signal`gallery.progress`\n  }), {\n    success: [\n      set(state`posts.all.${props`postId`}.imageUrl`, props`url`),\n      set(state`posts.all.${props`postId`}.imageName`, props`filename`),\n    ],\n    error: []\n  }\n]\n```\n\n### delete\n\nUse `delete` to remove an uploaded file. Specify the containing folder and filename.\n\n```js\nimport {props, state, string} from 'cerebral/tags'\nimport {put} from 'cerebral-provider-firebase'\n\nexport default [\n  firebase.delete(\n    string`posts.all.${props`postId`}`,\n    state`posts.all.${props`postId`}.imageName`\n  ), {\n    success: [],\n    error: []\n  }\n]\n```\n","title":"cerebral-provider-firebase"}},"migration":{"index":{"raw":"# From 1.x to 2.x\n\nWhen migrating from 1.x to 2.x you need to take the following under consideration.\n\n- There are no models left to choose from. Cerebral now comes with one model.\n- Services have been removed in favor of function-tree/providers.\n\n## Controller\nInstead of choosing your model and connecting to the *Controller* as in 1.x as shown below\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nconst controller = Controller(Model({\n  // You can add some initial state here if you want\n}))\n\nexport default controller\n```\n\nYou would simply do the following in 2.x\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {\n    // You can add some initial state here if you want\n  }\n})\n\nexport default controller\n```\n\n**controller.getSignals()** is removed from 2.x so favor **controller.getSignal('some.signal')** instead.\n\n## Modules\nIn 1.x you would have done something like this\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  home: Home,\n  admin: Admin\n})\n\nexport default controller\n```\n\nIn 2.x the modules are defined along with the controller\n\n```js\nimport {Controller} from 'cerebral'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller({\n  modules: {\n    home: Home(),\n    admin: Admin()\n  }\n})\n\nexport default controller\n```\n\nSub-modules can be defined by each module in the same way (see below).\n\nIn 1.x you would create your own module like this\n\n```js\n// 1.x\nexport default module => {\n  module.addState({\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  })\n\n  module.addSignals({\n    newItemTitleSubmitted: submitNewItemTitle\n  })\n}\n```\n\naddState, addSignals have been removed, so in 2.x you simply return an object\n\n```js\n// 2.x\nexport default {\n  state: {\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  },\n  modules: {\n    subModule: SubModule()\n  },\n  signals: {\n    newItemTitleSubmitted: submitNewItemTitle\n  }\n}\n```\n\n## Operators\nThe biggest change to Cerebral 2.x is the operators. You can read more about them in the Operators docs. They have become very powerful and you can create your own operators. Operators in Cerebral 2.x has been moved into core Cerebral. You can still use the old operators if you want by installing them via npm.\n\n```js\nnpm install cerebral-operators --save\n```\n\nThe new operators now use tagged template literals and you can reduce number of actions and instead use the new operators. Here is a quick sample. As you can see you import them from 'cerebral/operators'\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  set(state`foo.bar`, props`bar`)\n]\n```\n\nOther operators include: wait, when, equals, debounce, push, pop, shift, toggle, unset, splice\n\n## Signals\nYou handle signals mostly the same way as in 1.x. You can describe signals in a module or in the controller directly.\n\n### 1.x\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral-model-immutable'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller(Model({}))\n\ncontroller.addSignals({\n  buttonClicked: doSomething,\n  fieldChanged: { immediate: true, chain: updateField }\n})\n```\n### 2.x\n```js\nimport {Controller} from 'cerebral'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller({\n  signals: {\n    buttonClicked: doSomething,\n    fieldChanged: updateField\n  }\n})\n```\n\nOne note when using signals is that the **immediate** option is gone. This keeps the api cleaner.\n\n## Actions\nSince cerebral 2.x is using **function-tree** under the hood we have other, more powerful options than before. The state is the same, but output is gone and input is renamed to props. You can just return an object from the action that will be available in the props for the next action. You can also return a **path** that is a new concept in Cerebral 2.x and outdates output. **path** is used to determine the execution path for your chain. You do no longer have services as an argument in the context, use providers instead.\n\n### 1.x\n```js\nfunction myAction({props, state, output, services}) {\n\n}\n```\n\nIn 2.x you have the following. Instead of services you hook up providers that supersedes services.\n\n```js\nfunction myAction({props, state, path /*, myProvider, otherProvider */ }) {\n\n}\n```\n\nWhen you wanted to output to paths in 1.x you would do something like this\n```js\nfunction myAction({state, output}) {\n  if (state.get('app.isAwesome')) {\n    output.awesome()\n  } else {\n    output.notSoAwesome()\n  }\n}\nmyAction.outputs = ['awesome', 'notSoAwesome']\n```\n\nWith the new **path** concept this is simpler. In 2.x you would just do what is stated below. Please note the **return path...**. The same is true with promises. They need to be returned.\n\n```js\nfunction myAction({state, path}) {\n  if (state.get('app.isAwesome')) {\n    return path.awesome()\n  } else {\n    return path.notSoAwesome()\n  }\n}\n```\n\nIf you don't want to take another path in the execution tree you could return a new object that would be available in the props object.\n\n```js\nfunction myAction({state, path}) {\n  return {\n    someData: 'Some new data available at output.someData'\n  }\n}\n```\n\nWhen doing async operations you would do something like this in 1.x\n\n```js\nfunction myAction({output}) {\n  setTimeout(() => {\n    output({ /* optional output */ }) // or output.pathName({ /* optional output */ })\n  }, 1000)\n}\n\nmyAction.async = true\n```\n\nIn Cerebral 2 you you must resolve or reject a returned promise.\n\n```js\nfunction myAction({path}) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({ /* optional output */ }) // or resolve(path.pathName({ /* optional output */ }))\n    }, 1000)\n  })\n}\n```\n\nIn 1.x you could set a path that wasn't defined yet in the state tree. Let's say your state looked like this.\n\n```js\n{\n  app: {\n    nodes: {}\n  }\n}\n```\n\nYou could do this in an action.\n\n```js\nfunction myAction({state}) {\n  state.set('app.nodes.some.state.more', {updated: true})\n}\n```\n\nWith 2.x this is no longer possible. It's easy to mistype paths and therefore this option is no longer available. Your paths need to be in place before setting values to them.\n\nWhen using computed data in an action you could call **state.computed(myComputed())** in the action. This has changed in 2.x in favor of\n**state.compute(myComputed)**. You can also pass props to the compute function.\n\n```js\nfunction myAction({state}) {\n  state.compute(someComputed)\n  state.compute(someComputed.props({foo: 'bar'}))\n}\n```\n\nThis works the same in context for 2.x\n\n```js\nconnect({\n  foo: someComputed,\n  foo2: someComputed.props({foo: 'bar'})\n})\n```\n\n## Providers (outdates services)\n\nIn 1.x you could add services that would be available to you in the actions. Typically, you would do something like this in 1.x\n\n```js\nimport someExternalApi from 'some-external-api'\n\nexport default (options = {}) => module => {\n\n  if (!options.apiKey) {\n    throw new Error('This service needs an apiKey')\n  }\n\n  module.addServices({\n    connect() {\n      return someExternalApi.connect({\n        apiKey: options.apiKey\n      })\n    }\n  })\n\n}\n```\n\nIn 2.x you would use providers instead.\n\n```js\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  providers: [\n    ContextProvider({\n      axios\n    })\n  ]\n})\n```\n\nor manually\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  provider(context) {\n    context.myProvider = {\n      doSomething() {}\n    }\n    return context\n  }\n})\n```\n\nNow instead of having services in the context object in an action you would have the **axios** object.\n\n```js\nfunction myAction({axios}) {\n\n}\n```\n\n## Views\nHow you import view specific packages has changed. In 1.x you would import Container like this.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral-view-react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x you would not import the Container from another package.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nThe same is true when connecting Cerebral to your component. In 1.x you would import it like this.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral-view-react'\n\nexport default connect({\n  isLoading: 'app.isLoading'\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 2.x you would have to use a different import.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 1.x you would first connect state, then signals as separate arguments in connect. In Cerebral 2.x these are combined, tags are used to differentiate between state, signals and props.\n\n```js\n// 2.x\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {props, state, signal} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`,\n  item: state`items.${props`itemId`}`,\n  someSignal: signal`app.someSignal`\n}.\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIf you really want all signals in props as in 1.x you can set this as an option in the controller.\n\n```js\n// 2.x\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  options: {\n     signalsProp: true\n   }\n})\n```\n\n\n##  Model\nThe following functions have been removed from Cerebral 2.x when using state inside an action\n\n- logModel\n- export\n- findWhere\n- keys\n- import\n- toJs\n- toJson\n\n## Strict render mode\nTo setup strict render mode in 1.x for React was specified as follows.\n\n```js\nrender(\n  <Container controller={controller} strict>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x this is the only mode\n\n## Devtools\nThe devtools has changed as well. Go to chrome store and install cerebral2 debugger. The setup has slightly changed from 1.x to 2.x as well as the import.\n\n### 1.x\n```js\nimport Controller from 'cerebral'\nimport Model from 'cerebral/model/immutable'\nimport Devtools from 'cerebral-module-devtools'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools()\n})\n\nexport default controller\n```\n\n### 2.x\n```js\nimport Controller from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools(),\n  modules: {\n    ...\n  }\n})\n\nexport default controller\n```\n","title":"From 1.x to 2.x"}},"api":{"index":{"raw":"# Controller\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  // Defines the top level state\n  state: {},\n\n  // Defines the top level signals\n  signals: {},\n\n  // Defines the top level modules\n  modules: {}\n})\n\nexport default controller\n```\n\n## Errors\nCerebral knows about any errors that happen during a signal execution, synchronous and asynchronous. By default Cerebral just throws these errors to the console, but you can take control if you want to pass them to error tracking services etc.\n\n```js\ncontroller.on('error', function (error, execution, functionDetails) {})\n```\n\n## Methods\n\n### getState(path)\nReturns state from the state tree\n\n```js\nconst someState = controller.getState('some.state')\n```\n\n### getSignal(path)\nReturns signal from Cerebral\n\n```js\nconst someSignal = controller.getSignal('some.signal')\n// Run signal\nsomeSignal({foo: 'bar'})\n```\n\n### getModel()\nReturns the model (state tree) of Cerebral\n\n```js\nconst model = controller.getModel()\n```\n\n### flush(force)\nFlushes out changes to UI based on recent state changes, can be forced\n\n```js\ncontroller.flush()\n```\n\n### runSignal(name, definition, payload)\nAllows you to run an arbitrary function tree definition\n\n```js\ncontroller.runSignal('someSignal', [actionA, actionB], {foo: 'bar'})\n```\n\n## Events\n\n### initialized\nTriggers when Cerebral controller has initialized.\n\n```js\ncontroller.on('initialized', () => {})\n```\n\n### flush\nTriggered whenever Cerebral flushes out changes to the UI. Passes a map of changes.\n\n```js\ncontroller.on('flush', (changes) => {})\n```\n\n### start\nTriggered whenever Cerebral starts a signal execution.\n\n```js\ncontroller.on('start', (execution, payload) => {})\n```\n\n### end\nTriggered whenever Cerebral ends a signal execution.\n\n```js\ncontroller.on('end', (execution, payload) => {})\n```\n\n### pathStart\nTriggered whenever Cerebral starts execution a path in a signal\n\n```js\ncontroller.on('pathStart', (execution, payload) => {})\n```\n\n### pathEnd\nTriggered whenever Cerebral ends execution a path in a signal\n\n```js\ncontroller.on('pathEnd', (execution, payload) => {})\n```\n\n### functionStart\nTriggered whenever Cerebral starts executing an action.\n\n```js\ncontroller.on('functionStart', (execution, functionDetails, payload) => {})\n```\n\n### functionEnd\nTriggered whenever Cerebral ends executing an action.\n\n```js\ncontroller.on('functionEnd', (execution, functionDetails, payload) => {})\n```\n\n### asyncFunction\nTriggered whenever Cerebral executed an async action.\n\n```js\ncontroller.on('asyncFunction', (execution, functionDetails, payload) => {})\n```\n\n### parallelStart\nTriggered whenever Cerebral executes actions in parallel.\n\n```js\ncontroller.on('parallelStart', (execution, payload, functionsToResolveCount) => {})\n```\n\n### parallelProgress\nTriggered whenever Cerebral executes actions in parallel.\n\n```js\ncontroller.on('parallelProgress', (execution, payload, functionsStillResolvingCount) => {})\n```\n\n### parallelEnd\nTriggered whenever Cerebral executes actions in parallel.\n\n```js\ncontroller.on('parallelEnd', (execution, payload, functionsExecutedCount) => {})\n```\n\n### remember\nTriggered whenever Cerebral travels back in time. Passes the timestamp it travelled to.\n\n```js\ncontroller.on('remember', (datetime) => {})\n```\n","title":"Controller"},"devtools":{"raw":"# Devtools\nYou can pass some options to the devtools to balance the processing and memory footprint:\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: process.env.NODE_ENV === 'production' ? null : Devtools({\n    // Connect to Electron debugger (external debugger). It will\n    // fall back to chrome extension if unable to connect\n    remoteDebugger: 'localhost:8585',\n\n    // Time travel\n    storeMutations: true,\n\n    // Warnings on mutating outside \"state\" API\n    preventExternalMutations: true,\n\n    // Shows a warning when you have components with number of\n    // state dependencies or signals above the set number  \n    bigComponentsWarning: 5,\n\n    // Will reset debugger to currently focused application\n    multipleApps: true,\n\n    // In addition to basic JavaScript types Object, Array, String, Number\n    // and Boolean, File, FileList and Blob is allowed to be stored in state\n    // tree. You can add additional types if you know what you are doing :)\n    allowedTypes: []\n  })\n})\n```\n\nTurning these options to false will free up memory and CPU. Typically this is not an issue at all, but if you work with data heavy applications it might make a difference.\n","title":"Devtools"},"context":{"raw":"# Context\n\nWhen actions run they are passed a context. This context is created by Cerebral for every action run.\n\n```js\nfunction iAmAnAction (context) {}\n```\n\nThe context is populated by Cerebral and you can configure this by creating **providers**. By default Cerebral adds the following providers on the context.\n\n## Props\n\nWhen you trigger a signal you can pass it a payload. This payload is the starting point of the props to the signal. Given the signal:\n\n```js\n[\n  actionA,\n  actionB\n]\n```\n\n```js\nsomeSignal({\n  foo: 'bar'\n})\n```\n\nThe first action will receive the payload passed into the signal.\n\n```js\nfunction actionA ({input}) {\n  input // {foo: \"bar\"}\n\n  return {\n    bar: 'baz'\n  }\n}\n```\n\nBy returning a new object the next action will see an extended input:\n\n```js\nfunction actionB ({input}) {\n  input // {foo: \"bar\", bar: \"baz\"}\n}\n```\n\nSo returning an object from actions, either directly or from a promise, extends the input for later actions to handle.\n\n## State\nTo change the state of your application you use the state API. It is available to every action.\n\n```js\nfunction setSomething ({state}) {\n  state.set('some.path.foo', 'bar')\n}\n```\n\nAll common state operations are available as a method. Instead of first pointing to a value and then operate, you operate first and give the path to the value.\n\n```js\n// Traditional approach\nsomeArray.push('newItem')\n// With Cerebral\nstate.push('path.to.array', 'newItem')\n```\n\nThis is the one core concept of Cerebral that gives all its power. This simple approach allows for a few important things:\n\n1. Track mutations in the application so that it can be passed to the debugger\n2. Track mutations so that it can inform components depending on the changes\n3. Only allow mutations through the API, and nowhere else in the application (using freezing during development)\n\n## Path\nThe path on the context is only available if there is actually expressed a path after the action in question:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport actionC from '../actions/actionC'\n\nexport default [\n  actionA,\n  actionB, {\n    foo: [actionC]\n  }\n]\n```\n\nIn this scenario only *actionB* has the path on its context. As explained in **Chains and paths**, the path allows you to diverge execution of the signal.\n\n## Resolve\nWhen you ramp up your game with Cerebral you will most certainly take more advantage of **tags** and **computed** in your actions, typically related to action factories. To resolve an argument passed to a factory you can use resolve:\n\n```js\nfunction someActionFactory(someArgument) {\n  function someAction ({resolve}) {\n    // The argument can be anything, even plain values\n    const value = resolve.value(someArgument)\n  }\n\n  return someAction\n}\n```\n\nYou can also use resolve to check the value type and extract for example the path of tags:\n\n```js\nfunction someActionFactory(someArgument) {\n  function someAction ({resolve}) {\n    if (resolve.isTag(someArgument)) {\n      const path = resolve.path(someArgument)\n    }\n  }\n\n  return someAction\n}\n```\n\n\n## Controller\nYou have access to the controller instance on the context:\n\n```js\nfunction someAction ({controller}) {}\n```\n\n## Execution\nYou have access to function tree execution as well. This holds information about the current execution, mostly used by the devtools to inform the debugger.\n\n```js\nfunction someAction ({execution}) {}\n```\n","title":"Context"},"state":{"raw":"# State\n\n## Get state\nThe only way to get state in your application is by connecting it to a component or grabbing it in an action.\n\n```js\nfunction someAction({state}) {\n  // Get all state\n  const allState = state.get()\n  // Get by path\n  const stateAtSomePath = state.get('some.path')\n}\n```\n\n\n## Updating state\nThe only way to update the state of your application is in an action. Here is a list of all possible state mutations you can do:\n\n```js\nfunction someAction({state}) {\n  // Set or replace a value\n  state.set('some.path', 'someValue')\n  // Unset a key and its value\n  state.unset('some.path')\n  // Merge the keys and their values into existing object. Handled as a\n  // change on all paths merged in\n  state.merge('some.path', {\n    some: 'value'\n  })\n  // Pushes a value to the end of the array\n  state.push('some.path', 'someValue')\n  // Puts the value at the beginning of the array\n  state.unshift('some.path', 'someValue')\n  // Removes last item in array\n  state.pop('some.path')\n  // Removes first item in array\n  state.shift('some.path')\n  // Concats passed array to existing array\n  state.concat('some.path', ['someValueA', 'someValueB'])\n  // Splices arrays\n  state.splice('some.path', 2, 1)\n}\n```\n\n## Special values support\nWhen building an application you often need to keep things like files and blobs in your state for further processing. Cerebral supports these kinds of values because they will never change, or changing them can be used with existing state API. This is the list of supported types:\n\n- **File**\n- **FilesList**\n- **Blob**\n\nIf you want to force Cerebral to support other types as well, you can do that with a devtools option. This is perfectly okay, but remember all state changes has to be done through the state API.\n","title":"State"},"tags":{"raw":"# Tags\nTags allows you to target things in Cerebral. They are based on [template literal tags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals). They can be used by **operators**, **connect** and **compute**. Some of them can also be used with other Cerebral modules. The great thing about tags is their composability. For example:\n\n```js\nimport {state, props} from 'cerebral/tags'\n\nstate`items.${state`currentItemKey`}`\n\nstate`items.${props`itemKey`}`\n```\n\nThis allows you to express signals and component dependencies a lot more effectively. There are 5 tags in Cerebral.\n\n- **state** - Used in signals and connect to target state\n- **props** - Used in signals to target payload and in connect to target component props\n- **signal** - Used in signals and connect to target a signal\n- **string** - Used in signals to evaluate a composed string\n","title":"Tags"},"container":{"raw":"# Container\nExposes the controller to your components, allowing you to connect to it.\n\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Controller} from 'cerebral'\nimport {Container} from 'cerebral/react'\nimport App from './components/App'\n\nconst controller = Controller()\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n","title":"Container"},"connect":{"raw":"# Connect\n\n## Exposing state\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`\n},\n  function App(props) {\n    props.isLoading\n  }\n)\n```\n\nExpose state based on props passed to component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, props} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`${props`module`}.isLoading`\n},\n  function App(props) {\n    props.isLoading\n  }\n)\n```\n\n## Exposing signals\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {signal} from 'cerebral/tags'\n\nexport default connect({\n  clicked: signal`app.somethingClicked`\n},\n  function App(props) {\n    props.clicked\n  }\n)\n```\n\nExpose signals based on props passed to component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {signal, props} from 'cerebral/tags'\n\nexport default connect({\n  clicked: signal`${props.module}.somethingClicked`\n},\n  function App(props) {\n    props.clicked\n  }\n)\n```\n\n## Optimize rendering\nDue to Cerebrals \"render on path change\" it is possible to optimize component rendering.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  array: state`app.array.*`,\n  map: state`app.map.*`,\n},\n  function App (props) {\n    props.list // [0, 1, 2, 3]\n    props.map // ['foo', 'bar']\n  }\n)\n```\n\nThis component will only render when any keys are added or removed, meaning that nested change to a child does not cause a new render.\n","title":"Connect"},"modules":{"raw":"# Modules\n\nA module is basically an object. Modules helps you structure your state and signals. You can think of them as namespaces for state and signals.\n\n```js\nexport default {\n  // Define module state, namespaced by module path\n  state: {},\n  // Define module signals, namespaced by module path\n  signals: {},\n  // Define submodules, namespaced by module path\n  modules: {},\n  // Add a global provider when module instantiates\n  provider(context, functionDetails, payload) {}\n}\n```\n\nIt is also possible to define a module using a function.\n\n```js\nexport default (module) => {\n  module.name // Name of module\n  module.path // Full path to module\n  module.controller // The controller the module is attached to\n\n  return {\n    state: {},\n    signals: {},\n    modules: {},\n    provider(context, functionDetails, payload) {}\n  }\n}\n```\n\nYou attach a module simply by referencing it:\n\n```js\nimport {Controller} from 'cerebral'\nimport FeedModule from './modules/Feed'\n\nconst controller = Controller({\n  modules: {\n    feed: FeedModule\n  }\n})\n```\n","title":"Modules"},"operators":{"raw":"# Operators\nYou can call operators to create actions for you. These actions will help you change state and control the flow of execution.\n\n## State operators\n\nThe methods for changing state within actions is also available as operators. All state operators support using both **state** and **props** tags as values.\n\nAll operators are imported as members of the 'cerebral/operators' module. For example, this imports **state** and **set**:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n```\n\n### concat\n\nConcatenate a value to an array\n\n```js\nconcat(state`some.list`, ['foo', 'bar'])\n```\n\n### merge\n\nMerge objects into existing value. If no value exists, an empty object will be created. Merge supports using operator tags on key values:\n\n```js\nmerge(state`clients.$draft`, props`newDraft`, {\n  foo: 'bar',\n  bar: props`baz`\n})\n```\n\n### pop\n\nPop a value off an array (removes last element from array).\n\n```js\npop(state`some.list`)\n```\n\n### push\n\nPush value into an array (adds the element at the end of the array).\n\n```js\npush(state`some.list`, 'foo')\n```\n\n### set\n\nSet a target value in the state or props.\n\n```js\nset(state`foo.bar`, true),\nset(props`foo`, true)\n```\n\n### shift\n\nShift a value off an array (removes first element in array).\n\n```js\nshift(state`some.list`),\n```\n\n### splice\n\nSplice an array in place.\n\n```js\nsplice(state`some.list`, 0, 2)\n```\n\n### toggle\n\nToggle a boolean value.\n\n```js\ntoggle(state`user.$toolbar`)\n```\n\n### unset\n\nUnset key from object.\n\n```js\nunset(state`clients.all.${props`key`}`)\n```\n\n### unshift\n\nUnshift a value into an array (adds the element at the start of the array).\n\n```js\nunshift(state`some.list`, 'foo')\n```\n\n## Flow control operators\n\nThese operators help control the execution flow.\n\n### equals\n\nThis operator chooses a specific path based on the provided value.\n\n```js\nimport {equals} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  equals(state`user.role`), {\n    admin: [],\n    user: [],\n    otherwise: [] // When no match\n  }\n],\n```\n\n### debounce\n\nHold action until the given amount of time in milliseconds has passed. If the\nsignal triggers again within this time frame, the previous signal goes down the\n\"discard\" path while the new signal holds for the given time. This is\ntypically used for typeahead functionality. For a debounce that is shared\nacross different signals, you can use `debounce.shared()` (see example below).\n\nPlease note that the `discard` path has to be present even if it is most often\nempty because debounce is a flow operator that routes the flow depending on\ntime and action trigger.\n\n```js\nimport {debounce} 'cerebral/operators'\n\nexport default [\n  debounce(200), {\n    continue: [runThisAction],\n    discard: []\n  },\n]\n```\n\n`debounce.shared()` is typically used with factories, for example to show\nnotifications where a previous notification should be cancelled by a new one.\n\n```js\nimport {debounce, set, unset} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nconst sharedDebounce = debounce.share()\nfunction showNotificationFactory(message, ms) {\n  return [\n    set(state`notification`, message),\n    sharedDebounce(ms), {\n      continue: [unset(state`notification`)],\n      discard: []\n    }\n  ]\n}\n```\n\nNow when this notification factory is used in different signals, the call to\n`debounceShared` will share the same debounce execution state:\n\n```js\nimport showNotification from './showNotification'\n\nexport default [\n  // ... user log in, etc\n  ...showNotification('User logged in', 5000)\n]\n```\n\n### wait\n\nWait for the given time in milliseconds and then continue chain.\n\n```js\nimport {wait} from 'cerebral/operators'\n\nexport default [\n  wait(200),\n  doSomethingAfterWaiting\n]\n```\n\nIf you need to wait while executing in parallel, you should use a `continue`\npath to isolate the actions to be run:\n\n```js\nimport {wait} from 'cerebral/operators'\n\nexport default [\n  [ // this runs in parallel\n    wait(200), {\n      continue: [doSomethingAfterWaiting]\n    },\n    otherActionInParallel\n  ]\n]\n```\n\n### when\n\nRun signal path depending on a truth value or function evaluation.\n\n```js\nimport {when} from 'cerebral/operators'\n\nexport default [\n  when(state`foo.isAwesome`), {\n    true: [],\n    false: []\n  },\n  // You can also pass your own function\n  when(state`foo.isAwesome`, (value) => value.length === 3 ), {\n    true: [],\n    false: []\n  }\n]\n```\n\nWhen used with a truth function, the `when` operator supports more then a single\n\"value\" argument. The truth function must come last.\n\n```js\nimport {when} from 'cerebral/operators'\nimport {props, state} from 'cerebral/tags'\n\nexport default [\n  when(state`clients.$draft.key`, props`key`,\n    (draftKey, updatedKey) => draftKey === updatedKey\n  ), {\n    true: [\n      // Another person edited client, reset form to new value\n      set(state`clients.$draft`, props`value`)\n    ],\n    false: []\n  }\n]\n```\n","title":"Operators"},"providers":{"raw":"# Providers\n\nProviders are functions that runs before any action in any signal. Their purpose is to define and sometimes manipulate the context passed into every action. The providers run before every action, meaning that each action has a unique context object.\n\n## Context provider\nThe context provider allows you to attach any third party library to the context of all actions. Typically:\n\n\n```js\nimport {Controller} from 'cerebral'\nimport {ContextProvider} from 'cerebral/providers'\nimport axios from 'axios'\n\nconst controller = Controller({\n  providers: [\n    ContextProvider({\n      axios\n    })\n  ]\n})\n```\n\nNow axios will be available on the context of any action. The context provider also wraps any methods and sends information to the debugger about their use.\n\nLook at the **community tools** for other providers that can be used, or create your own.\n\n## Creating a provider\n\nAn example of a provider is the **PropsProvider**.\n\nIt looks something like this:\n\n```js\nfunction PropsProvider(context, functionDetails, payload) {\n  context.props = payload\n\n  return context\n}\n```\n\nThe providers are called by **function-tree** with some arguments.\n\n- **context** is the current context object that will be passed into the function (action)\n- **functionDetails** gives information about the function (action) that will run\n- **payload** the current payload of the execution (signal)\n\nYou can create a standalone provider simply by defining a function like the **PropsProvider** in the first example. But you can also define a provider on a module. This allows you to combine providers and signals.\n\n```js\nexport default (module) => {\n  const MODULE_PATH = module.path.join('.')\n\n  return {\n    state: {\n      foo: true\n    },\n    signals: {\n      somethingHappened: [\n        toggle(state`${MODULE_PATH}.foo`)\n      ]\n    },\n    provider(context) {\n      context.myProvider = {\n        doSomeSideEffect() {\n          someSideEffect().then(() => {\n            module.controller.getSignal(`${MODULE_PATH}.somethingHappened`)()\n          })\n        }\n      }\n\n      return context\n    }\n  }\n}\n```\n\nNow any action can:\n\n```js\nfunction someAction({myProvider}) {\n  myProvider.doSomeSideEffect()\n}\n```\n\nYou should think twice when considering a provider though. Always favor signal composition and actions as those will always end up more readable and better visualized in the debugger. Providers are typically used for general enhancements, not application specific.\n\n## Already on the context\nThere are some things already available on the context.\n\n```js\nfunction MyProvider(context) {\n  context.execution // Information on the function tree execution\n  context.controller // The Cerebral controller\n  context.debugger // If devtools is added, you can send messages to the debugger\n  context.props // Current payload\n  context.path // If any paths are defined after the action to be executed\n  context.state // The state API\n  context.resolve // Resolve values and tag paths\n\n  return context\n}\n```\n","title":"Providers"},"compute":{"raw":"# Compute\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default compute(\n  state`user.name`,\n  (name) => {\n    return `Hi ${name}`\n  }  \n)\n```\n\nA compute takes any number and type of arguments, where each argument is passed to the next function argument.\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\nimport someOtherComputed from './someOtherComputed'\n\nexport default compute(\n  state`user.name`,\n  'foo',\n  (name, foo) => {\n    return `Hi ${name}`\n  },\n  someOtherComputed,\n  (computedHello, someOtherComputedValue) => {\n    return `${computedHello} - ${someOtherComputedValue}`\n  }\n)\n```\n\nThat last argument of each function is **get**, it allows you to manually extract state and props.\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default compute(\n  state`user.id`,\n  (userId, get) => {\n    return get(state`projects.${user.id}`).length > get(props`limit`)\n  }  \n)\n```\n","title":"Compute"},"statecontainer":{"raw":"# StateContainer\n\n\"Can I use Cerebral on the server?\". Yes, technically you can, but you actually should not. Cerebral is a framework for building applications with user interfaces. Running code related to talking to a server on the server does not really make sense. What does make sense though is pre-rendering and handle complex flows on server side logic.\n\n## Pre-rendering\nBoth [react](https://facebook.github.io/react/) and [inferno](https://github.com/trueadm/inferno) supports rendering your application on the server. But that does not mean your application runs on the server. The only thing you need to pre-render your application is state. The **StateContainer** allows you to render your application by just passing an object as the state of your app:\n\n```js\nimport {StateContainer} from 'cerebral/react'\nimport {renderToString} from 'react-dom/server'\n\nconst html = renderToString(\n  <StateContainer state={someServerCreatedState}>\n    <App />\n  </StateContainer>\n)\n```\n\nInstead of passing the Cerebral controller to the container, you just pass it the state of the application. This will render your application in the correct state. How you produce this state is up to you though. Applications are very different related to producing state on the server so there is not \"one answer\" here.\n\nIt might be a good idea to define the state of your application in one file, instead of using modules:\n\n```js\nexport default {\n  app: {},\n  posts: {}\n}\n```\n\nThis way you can import the same state file on your client and on the server. On the server you just populate the missing state.\n\n## Business logic\nYou might also be tempted to use Cerebral to handle server side business logic. But Cerebral is actually a small wrapper around [function-tree](https://github.com/cerebral/function-tree). Function-tree has its own debugger and gives you more flexibility in handling complexities on the server as well.\n","title":"StateContainer"}}}