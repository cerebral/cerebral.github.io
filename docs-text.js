{"introduction":{"index":{"raw":"# The architecture\n\n## Vision\nThe architecture of Cerebral is driven by the goal to give you insight. The single state tree and the way state is connected to the components all support this vision. Creating a Cerebral application allows you and your team members to never question what actually happens when a page loads, a specific button is clicked, etc. Decoupling of state, components and state updates also makes it an overall better experience when scaling up an application as the components will be just a dumb layer that transforms a given state to a user interface.\n\nThe Cerebral debugger is what gives you this insight and answers your questions on what state changes and side effects have been run in any given situation. It is a powerful tool that makes it easier to reason about the application and increases productivity in planning out logic and implementation.\n\nCerebral is based on the simple concept of three things your application does in order to function. **Store state**, **render state** and **update state**.\n\n## Store state\nWhere to store the state of an application is a highly debated subject. Should we allow the components to store state? Should we have multiple models? Stores? Reducers? Services? There are many concepts that can store state. In Cerebral you store all your state in \"a single state tree\". That means you do not create classes or other abstractions around state, it is all basically one big object of plain JavaScript types. Objects, arrays, strings, numbers and booleans:\n\n```js\n{\n  auth: {\n    isLoggedIn: false,\n    user: {\n      prefs: {\n        style: 'light'\n      },\n      friends: [],\n      info: {\n        email: '',\n        name: ''\n      }\n    }\n  },\n  posts: {\n    list: [],\n    selectedPostIndex: 0\n  }\n}\n```\n\nWith this approach we get some benefits not possible with other approaches.\n\n1. **Simple and consistent API** - Typically a state update changes a value, pushes an item in a list, or merges an object into another. With a single state tree we can create an API that does exactly that:\n```js\nstate.set('auth.user.prefs.style', 'dark')\nstate.push('auth.user.friends', 'Joe')\nstate.merge('auth.user.info', {\n    email: 'cheetah@jungle.com',\n    name: 'Cheetah'\n})\n```\nWith a single state tree we can point to parts of the state using paths (the first argument). We use dot notation to point to nested paths, like **auth.user.name**.\n\n2. **Optimized rendering** - Cerebral does not look at the updates in your application as \"value updates\", but as \"path updates\". This allows Cerebral to make optimizations not possible in other frameworks:\n\n  1. There is no need for immutability in Cerebral because a change to a path means that any component depending on that path should render (no value comparison). In applications with large data structures, immutability has a high cost. There is no need to hack objects and arrays to observe changes to them either. There is nothing special about the state you put into Cerebral's state tree.\n\n  2. Since there is no value comparison in Cerebral it uses what we call **strict render**. This allows us to do render optimizations not possible with other solutions. For example you can say that a component that depends on a list is only interested in added/removed items of the list or whether the list itself is being replaced.\n\n3. **Visualize the entire app state** - When the state of the application is a single object, we can use an object inspector to visualize the whole state of your application. With the Cerebral debugger it is easy to build a mental image of application state. You can even make changes directly to state to see how it affects the view layer.\n\n\n## Render state\nSince Cerebral stores all the state of the application in a single state tree, we need a way to expose that state to the components. In some frameworks this is done by passing the whole model or collection of models/stores from the top of the application and down from one component to the next. This can become very tedious and fragile as all nested components completely depend on their parent. In Cerebral, the state of the application is directly connected to each component (here shown with **React**):\n\n```js\nconnect({\n  userName: state`auth.user.info.name`\n},\n  function User(props) {\n    props.userName // \"some name\" (value stored in 'app.user.name')\n  }\n)\n```\n\n**connect** tells Cerebral that the component is interested in a path where the user name happens to be. When that path changes, then the component will be rendered. The component is now completely independent of other components. You can move it to wherever you desire in the component tree and it will still work.\n\n## Update state\nThis is where Cerebral differs most from other approaches to application development. Updating the state of an application can be anything from:\n\n- flipping a **true** to a **false**\n- setting some value, like a filter\n- reading (and storing) something in local storage\n- requesting data from the server and, depending on the status code of the response, doing something with that response which might lead to new requests and/or setting up a listener for data on the server\n- etc...\n\nThe point is, updating state can be a very complex flow of operations. This is often where spaghetti code comes from, and we use abstractions to hide it. The problem with abstractions hiding too much logic is that it becomes rigid, making it difficult to reuse logic and compose existing logic together in new ways.\n\nTo handle everything from a simple toggle to very complex operations, Cerebral has the concept of **signals**. Signals allows you to compose functions together into a **flow**. You can define different execution paths based on whatever you want (a status code, an error, some state, etc). This allows you to write decoupled code, while still bringing everything together in the form of a higher abstraction which helps developers understand how things relate to one another (in what order they will run, when they will run, etc). Under the hood, signals are based on [function-tree](https://github.com/cerebral/cerebral/tree/master/packages/node_modules/function-tree), a project that came out of the initial experimentations in the first version of Cerebral.\n\n## Demo\n\nTo get straight into some code, have a look at this sandbox:\n\n```marksy\n<CodeSandbox url=\"https://codesandbox.io/embed/l4q49q73nq?view=preview\" />\n```","title":"The architecture"},"install":{"raw":"# Install\nTo install Cerebral you need to use the Node Package Manager. NPM is part of [Node](https://nodejs.org/en/), so please install that on your computer first. You should install Node version 5 or later.\n\n## Command line\n\n`npm install cerebral`\n\n## Instant project\n\n```marksy\n<CodeSandbox url=\"https://codesandbox.io/embed/lp5rjr0z4z\" />\n```\n","title":"Install"},"debugger":{"raw":"# Debugger\n\nCerebral has a powerful development tool. It knows about all the state in your application, all the state updates, side effects run, state paths currently active in your components and when they render. All the things Cerebral helps you with, it visualizes in the debugger.\n\nBecause Cerebral can run on different environments and you might want to manage multiple apps, the debugger is a standalone application. This also opens up for further helpful tools beyond just debugging. It is an [Electron](https://electron.atom.io/) application that connects to your application through websockets. You can add multiple apps to it and if you are using function-tree on the server you can even merge execution data on client and the server.\n\n## Install\n[Download the Debugger](https://github.com/cerebral/cerebral-debugger/releases) for your target OS: Mac, Windows or Linux. The debugger will automatically notify you and self-update.\n\n## Signals\nThe signals tab in the debugger gives you a chronological list of signals triggered. Every signal tells you what actions were run, what mutations were run related to the action and what other side effects like HTTP and Firebase was triggered. You will also see how your signals are composed together in different action groups, parallel execution.\n\n![signals](/images/signals.png)\n\n## Mutations\nThe mutations tab gives you a chronological list of mutations performed. Since signals can be asynchronous, mutations might happen cross signals. In this list you can double click a mutation to time travel to that point in time.\n\n![mutations](/images/mutations.png)\n\n## Components\nThe components tab gives you a list of all currently connected components in your app and what state dependencies they have. You also have a list of latest renders. This list contains what paths changed and what components was affected by the change.\n\n![components](/images/components.png)\n\n## State tree\nThe state tree tab gives you complete overview of the state of your application. You can explore it and make changes to the state directly to see how it affects your application.\n\n![state tree](/images/state_tree.png)\n\n## Initialize\nYou initialize the devtools by adding it to the controller.\n\n```js\nimport {Controller} from 'cerebral'\nimport app from './app'\nimport Devtools from 'cerebral/devtools'\n\n\n\n// You do not want to load or run the devtools in production as it\n// requires processing and memory to send data from\n// your application. \"IS_DEVELOPING\", or similar,  can be made available\n// in your build flow\nlet devtools = null\nif (IS_DEVELOPING) {\n  devtools = require('cerebral/devtools').default({\n    // Some environments might require 127.0.0.1 or computer IP address\n    host: 'localhost:8585',\n\n    // By default the devtools tries to reconnect\n    // to debugger when it can not be reached, but\n    // you can turn it off\n    reconnect: true\n  })\n}\n\n\nconst controller = Controller(app, {\n  devtools\n})\n\nexport default controller\n```\n\nThere are additional options you can read about in the API section.\n","title":"Debugger"},"modules":{"raw":"# Modules\n\n```marksy\n<Youtube url=\"https://www.youtube.com/embed/QJnDxez9qtY\" />\n```\n\nThe base structuring building block of Cerebral is the **Module**. The Cerebral modules can be looked at as namespaces for logic. While they do encapsulate, they do not isolate. That means any module can change the state of any other module.\n\n```js\nimport { Module } from 'cerebral'\n\nexport default Module({\n  state: {\n    foo: 'bar'\n  }\n})\n```\n\nYou attach the root module to the controller:\n\n```js\nimport { Controller } from 'cerebral'\nimport app from './app'\n\nexport default Controller(app)\n```\n\nYou can also define your module as a function, returning a module definition. This function will receive the **name** of the module, the **path** to it and also the **controller** instance.\n\n```js\nimport { Module } from 'cerebral'\n\nexport default Module(({ name, path, controller }) => {\n  return {\n    state: {}\n  }\n})\n```\n\nThis information can be useful in more complex setups where your module wants to listen for the *initialized* event of the controller for example.\n\n## Submodules\nA module can also use a **modules** property to attach nested modules.\n\n```js\nimport foo from './modules/foo'\n\nexport default {\n  state: {},\n  modules: {\n    foo\n  }\n}\n```\n\n```marksy\n<CodeSandbox url=\"https://codesandbox.io/embed/q4qz00wkp6?view=editor\" />\n```","title":"Modules"},"state":{"raw":"# State\n\n```marksy\n<Youtube url=\"https://www.youtube.com/embed/OIKz6iASp1A\" />\n```\n\nCerebral uses a single state tree to store all the state of your application. It is just a single object:\n\n```js\n{}\n```\n\nThat's it.\n\nYou will normally store other objects, arrays, strings, booleans and numbers in it. Forcing you to think of your state in this simple form gives us benefits.\n\n1. The state of the application is exposed as simple values. There are no classes or other abstractions hiding the state of your application\n2. The state can be stored on the server, local storage and passed to the debugger. It is what we call **serializable** state\n3. All the state of your application can be inspected through one object\n4. All state is related to a path. There is no need to import and/or pass around model instances into other model instances to access state\n\nTo define the initial state of any application all we need to do is to add a root module to our **Controller** in *controller.js*\n\n\n```js\nimport { Controller, Module } from 'cerebral'\n\nconst app = Module({\n  state: {\n    title: 'Cerebral Tutorial'\n  }\n})\n\nexport default Controller(app)\n```\n\nLater you will learn more about **modules** which help you structure your application.\n\n```marksy\n<CodeSandbox url=\"https://codesandbox.io/embed/oqx7po71nz?view=editor\" />\n```","title":"State"},"signals":{"raw":"# Signals\n\n```marksy\n<Youtube url=\"https://www.youtube.com/embed/o2ULoHp22BE\" />\n```\n\n## Actions\n\nAn action is just a function. What makes an action different from a normal function though is that it receives only one argument, created by Cerebral. It is called the **context**. Actions are \"low level\" and imperative. There is no declarative code without some imperative code behind it.\n\n```js\nexport function iAmAnAction (context) {\n\n}\n```\n\nWhatever side effect you need to run or state changes that needs to be made, you do it from the context. It means you do not need any API to define an action or import any other modules to define business logic. This makes actions highly testable and easy to write.\n\nHere is an example of an action changing the state of the application:\n\n```js\nexport function iAmAnAction ({ state }) {\n  state.set('foo', 'bar')\n}\n```\n\nOr running an http request:\n\n```js\nexport function iAmAnAction ({ http }) {\n  return http.get('/user')\n}\n```\n\n## Sequences\n\nYou trigger a signal when something happens in your application. For example a button is clicked, but also if a websocket connection receives a message. The signal runs one or more **sequences** of business logic. The sequences compose together actions which runs state changes, side effects and other logic in one coherent flow.\n\nThis is an example of a sequence that grabs a user and sets it.\n```js\nimport * as actions from './actions'\n\nexport const initialize = [\n  actions.getUser,\n  actions.setUser,\n]\n```\n\nSignals are added to your application in the modules:\n\n```js\nimport { Module } from 'cereral'\nimport * as sequences from './sequences'\n\nexport default Module({\n  signals: {\n    initialized: sequences.initialize\n  }\n})\n```\n\nCerebral uses the [function-tree](https://github.com/cerebral/cerebral/tree/master/packages/node_modules/function-tree) project to implement its signals. A function-tree allows you to define a tree of functions to be executed. In Cerebral we call these **actions**.\n\n\n\n## Paths\nIt is possible to diverge execution down specific paths.\n\n```js\nimport * as actions from './actions'\n\nexport const initialize = [\n  actions.getUser, {\n    success: actions.setUser,\n    error: actions.setError\n  }\n]\n```\n\nThe **getUser** action could look like this:\n\n```js\nexport function getUser ({ http, path }) {\n  return http.get('/user')\n    .then(response => path.success({ user: response.result }))\n    .catch(error => path.error({ error }))\n}\n```\n\n## Props\n\nWhen a signal is executed a payload can be passed into it, called **props**. That means every action in the defined signal has access to these props.\n\nImagine a signal is triggered from a component with the payload `{foo: 'bar'}`. Now the whole flow of the signal has access to **props.foo**. An action in this signal could now use this prop to for example update the state of the application.\n\n```js\nexport function updateFoo ({ state, props }) {\n  state.set('foo', props.foo)\n}\n```\n\n### Update props\nYou update the props on the signal by returning an object from the action. This object will be merged with existing props.\n\n```js\nexport function iAmAnAction () {\n  return {\n    newProp: 'someValue'\n  }\n}\n```\n\n### Async\nWhen actions return a promise the signal will hold execution until it is resolved. any resolved values will be merged in with props.\n\n```js\nexport function iAmAnAction () {\n  return new Promise((resolve) => {\n    resolve({\n      newProp: 'someValue'\n    })\n  })\n}\n```\n\nYou can also use `async` functions:\n\n```js\nexport async function iAmAnAction ({ http }) {\n  const response = await http.get('/user')\n\n  return { user: response.result }\n}\n```\n\n## Parallel execution\nYou can run actions in parallel. You do that by using the **parallel** function:\n\n```js\nimport { parallel } from 'cerebral'\nimport * as actions from './actions'\n\nexport const mySequence = [\n  parallel([\n    actions.actionA,\n    actions.actionB\n  ]),\n  actions.actionC\n]\n```\n\nIf *actionA* returns a promise *actionB* will still be run instantly, meaning that they run in parallel. When both *actionA* and *actionB* is done, *actionC* is run.\n\n## Composing\nActions and a sequence of actions can be composed into other sequences of actions. This is a powerful concept that allows you to decouple a lot of your logic and compose it together wherever it is needed:\n\n```js\nimport * as actions from './actions'\n\nexport const authenticate = [\n  actions.getUser,\n  actions.setUser\n]\n\nexport const initialize = [\n  authenticate,\n  actions.setCurrentPage\n]\n```\n\nThe debugger will show **authenticate** as its own sequence, meaning that composition is visualized in the debugger. If you want you could even name this authenticate sequence, giving even more debugging information.\n\n```js\nimport { sequence } from 'cerebral'\nimport * as actions from './actions'\n\nexport const authenticate = sequence('authenticate', [\n  actions.getUser,\n  actions.setUser\n])\n\nexport const initialize = [\n  authenticate,\n  actions.setCurrentPage\n]\n```\n\n## Operators\n\nCerebral also ships with what we call operators. Operators are just action factories that you can use to express logic without creating actions. Operators has a \"declarative cost\", meaning that you need to interpret what an operator does by reading its arguments. This opposed to just reading the name of an action. The benefit of operators is that you do not have to write the imperative logic for them. Read more about patterns to decide on your approach.\n\nThe most common operators you will use changes the state of your application.\n\n```js\nimport { set } from 'cerebral/operators'\nimport { state } from 'cerebral/tags'\n\nexport const mySequence = [\n  set(state`foo`, 'bar')\n]\n```\n\nWith the help of [tagged template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals) we are able to express that we want to set the state path **foo** to have the value **\"bar\"**.\n\nAnd this is how you go about using operators:\n\n```js\nimport { merge, push, pop } from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport const mySequence = [\n  merge(state`some.object`, {foo: 'bar'}),\n  push(state`some.list`, 'foo'),\n  pop(state`some.otherList`)\n]\n```\n\n```marksy\n<CodeSandbox url=\"https://codesandbox.io/embed/pm6lp6o4pj?view=editor\" />\n```","title":"Signals"},"providers":{"raw":"# Providers\n\n```marksy\n<Youtube url=\"https://www.youtube.com/embed/Fa8XcfnQl_o\" />\n```\n\nProviders are added to the context of every action executed by a signal. Providers can be everything from a tool you are already using, to something Cerebral specific. **The point of providers is to separate side effects from execution**. That means you can create all the logic you want in actions without creating any dependencies to other tools. This makes them highly testable and generally gives you more flexibility.\n\n## The default providers\nCerebral has a set of default providers:\n\n- **props** - The data passed into execution and/or returned from actions\n- **state** - The API that changes the state of your application\n- **module** - Change the state of the module running the signal\n- **controller** - Access to the controller instance inside an action\n- **resolve** - Ability to resolve tags and computed inside actions\n\nAll these can be accessed inside an action:\n\n```js\nexport function someAction ({ props, state, controller, resolve }) {}\n```\n\nThe [devtools](/docs/api/devtools) also adds its own provider called **debugger**.\n\n## Adding a provider\nIf you are using libraries where you want access to everything they provide you can simply add them as a provider using an object:\n\n```js\nimport { Module } from 'cerebral'\nimport axios from 'axios'\nimport uuid from 'uuid'\n\nexport default Module({\n  state: {},\n  signals: {},\n  providers: {\n    axios,\n    uuid\n  }\n})\n```\n\nThough you will get benefits by using the **Provider** factory from Cerebral. This will track its usage and also encourages you to create a specific API for your application to run the side effects. For example:\n\n```js\nimport { Controller, Provider } from 'cerebral'\nimport axios from 'axios'\n\nconst http = Provider({\n  get(...args) {\n    return axios.get(...args)\n  },\n  post(...args) {\n    return axios.post(...args)\n  }\n})\n\nexport default Module({\n  state: {},\n  signals: {},\n  providers: {\n    http\n  }\n})\n```\n\n**It does not matter what module exposes the provider, all providers are global. That means any provider defined is available in any action in the application.**\n\nYou can use providers for pretty much anything, though typically it is to handle some kind of side effect. Examples of providers are [@cerebral/storage](https://github.com/cerebral/cerebral/tree/master/packages/node_modules/@cerebral/storage), [@cerebral/firebase](https://github.com/cerebral/cerebral/tree/master/packages/node_modules/@cerebral/firebase) and [@cerebral/http](https://github.com/cerebral/cerebral/tree/master/packages/node_modules/@cerebral/http).\n\nAs mentioned above we use providers to separate side effects from execution, allowing us to provide our own custom API to our application.\n\n```marksy\n<CodeSandbox url=\"https://codesandbox.io/embed/mq5k42x5nj?view=editor\" />\n```","title":"Providers"},"errors":{"raw":"# Errors\n\n```marksy\n<Youtube url=\"https://www.youtube.com/embed/UdVjsKQLybw\" />\n```\n\nHandling complex asynchronous flows is a challenging task for error handling. If things are not done correctly errors can be swallowed and you will have a hard time figuring out why your application does not work.\n\nError handling in Cerebral signals are done for you. Wherever you throw an error, it will be caught correctly and thrown to the console unless you have explicitly said you want to handle it. And even when you do explicitly handle it Cerebral will still show the error in the debugger as a **caught** error, meaning you can never go wrong. The action in question is highlighted red, you will see the error message, the code related and even what executed related to you catching the error.\n\n![debugger error](/images/debugger_error.png)\n\n## Catching errors\nYou catch errors in module:\n\n```js\nimport { Module } from 'cerebral'\nimport { FirebaseProviderError } from '@cerebral/firebase'\nimport * as sequences from './sequences'\n\nexport default Module({\n  state: {},\n  signals: {\n    somethingHappened: sequences.doSomething\n  },\n  catch: [\n    [FirebaseProviderError, sequences.catchFirebaseError]\n  ]\n})\n```\n\nWe basically tell the module that we are interested in any errors thrown by the Firebase Provider. Then we point to the sequence of actions we want to handle it. An error will be passed in to the sequence of actions handling the error:\n\n```js\n{\n  foo: 'bar', // already on payload\n  error: {\n    name: 'FirebaseProviderError',\n    message: 'Could not connect',\n    stack: '...'\n  }\n}\n```\n\n## Creating an error type\nCerebral ships with a base error class of **CerebralError**. It extends **Error** and adds some functionality to give more details about the error and show it correctly in the debugger. You can extend this error class to create your own error types.\n\n```js\nimport { CerebralError } from 'cerebral'\n\nexport class AppError extends CerebralError {}\n```\n\nYou can extend the error with your own name and props.\n\n```js\nimport { CerebralError } from 'cerebral'\n\nexport class AuthError extends CerebralError {\n  constructor(message, code) {\n    super(message)\n\n    this.name = 'AuthError'\n    this.code = code\n  }\n}\n```\n\n```marksy\n<CodeSandbox url=\"https://codesandbox.io/embed/61902m93w3?view=editor\" />\n```\n","title":"Errors"},"views":{"raw":"# Views\n\nIn Cerebral you connect state to components (views) where you need it. This give some benefits:\n\n1. Cerebral will optimize the component\n2. The debugger will know about this component and visualize its state dependencies and when it renders\n3. Increased readability as every component explicitly tells you what state and signals it needs and where it gets it from\n4. You can safely move the component wherever you want without breaking chain of props passing\n\nCerebral supports numerous view layers. They conceptually work the same way, but has different implementation details. Choose the view layer that makes sense to you and your team. We will move on using **React**, but have a look at the VIEWS section to find out more about the other supported views.\n\nWhen you render your application you use the **Container** component, or similar, to expose the controller to the rest of your components...\n\n```js\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { Container } from '@cerebral/react'\nimport controller from './controller'\nimport App from './App'\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\nWhen you connect a component like this...\n\n```js\nimport React from 'react'\nimport { connect } from '@cerebral/react'\nimport { state } from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`\n},\n  function MyComponent ({title}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n      </div>\n    )\n  }\n)\n```\n\n...the component will be registered to Cerebral. Cerebral actually has a register of all *connected* components in your application. This information is passed to the debugger and whenever Cerebral flushes out changes made to different state paths, it will know what components should render.\n\nAll connected components are automatically optimized, meaning that they will only render if a parent component passes a changed prop or Cerebral explicitly tells it to render.\n\nTo get more in-depth information about **connect**, please visit the [VIEWS section](/docs/views/react.html#@cerebral/react-connect).\n","title":"Views"},"compute":{"raw":"# Compute\nNormally you use state directly from the state tree, but sometimes you need to compute values. Typically filtering lists, grabbing the projects of a user, or other derived state. It is a good idea not to put this kind of logic inside your view layer, cause by creating a computed you can reuse the logic anywhere.\n\nCerebral allows you to compute state that can be used in multiple contexts. Let us look at the signature:\n\n```js\nimport { Compute } from 'cerebral'\n\nexport default Compute(() => {\n  return 'foo'\n})\n```\n\nYou can now use this with **connect**:\n\n```js\nimport computedFoo from '../computedFoo'\n\nconnect({\n  foo: computedFoo\n})\n```\n\nYou can use it with operators in a signal:\n\n```js\nimport computedFoo from '../computedFoo'\nimport { set } from 'cerebral/operators'\nimport { state } from 'cerebral/tags'\n\nexport const mySequence = [\n  set(state`foo`, computedFoo)\n]\n```\n\nOr you can resolve it inside an action if you need to:\n\n```js\nimport computedFoo from '../computedFoo'\n\nexport function myAction ({resolve}) {\n  const foo = resolve.value(computedFoo)\n}\n```\n\nYou can even compose it into a Tag:\n\n```js\nimport computedFoo from '../computedFoo'\nimport { state } from 'cerebral/tags'\nimport { set } from 'cerebral/operators'\n\nexport const mySequence = [\n  set(state`${computedFoo}.bar`, 'baz')\n]\n```\n\nThe compute signature is very flexible. It allows you to put in any number of arguments which will be evaluated. For example here we go and grab some state and props, before using their values to produce a new value.\n\n```js\nimport { Compute } from 'cerebral'\nimport { state, props } from 'cerebral/tags'\n\nexport default Compute(state`foo`, props`bar`, (foo, bar) => {\n  return foo + bar\n})\n```\n\nWe can even keep adding arguments and produce yet another value:\n\n```js\nimport { Compute } from 'cerebral'\nimport { state, props } from 'cerebral/tags'\n\nexport default Compute(\n  state`foo`,\n  props`bar`,\n  (foo, bar) => {\n    return foo + bar\n  },\n  state`baz`,\n  (computedFooBar, baz) => {\n    return computedFooBar + baz\n  }\n)\n```\n\nThat means you can compose computeds, lets try by splitting them up into two:\n\n```js\nimport { Compute } from 'cerebral'\nimport { state, props } from 'cerebral/tags'\n\nconst fooBar = Compute(\n  state`foo`,\n  props`bar`,\n  (foo, bar) => {\n    return foo + bar\n  }\n)\n\nconst fooBarBaz = Compute(\n  state`baz`,\n  (computedFooBar, baz) => {\n    return computedFooBar + baz\n  }\n)\n\nexport default Compute(fooBar, fooBarBaz)\n```\n\nThere is one last thing to computeds and that is the **get** argument, which is always the last argument passed into the callback of a computed. This argument can be used to manually extract state and props, very useful to optimize computed lists.\n\nFor example we have items with an array of user ids. We create a computed taking in **itemKey** as a prop, extracts the item and then iterates the userIds to grab the actual users.\n\n\n```js\nimport { Compute } from 'cerebral'\nimport { state, props } from 'cerebral/tags'\n\nconst computedItemUsers = Compute(\n  state`items.${props`itemKey`}`,\n  (item, get) => {\n    return item.userIds.map((userId) => get(state`users.${userId}`))\n  }\n)\n\n// In connect\nconnect({\n  users: computedItemUsers\n})\n```\n\nIt uses the *itemKey* property from the component to grab the actual item. It then grabs each user based on the userIds of the item. Then we could add additional computed to only get certain users.\n\n```js\nconnect({\n  item: Compute(filteredList, onlyAwesome)\n})\n```\n\nTypically you can get away with most things using Tags, but compute will help you with any other scenarios where more \"umph\" is needed.\n","title":"Compute"},"patterns":{"raw":"# Patterns\n\nThe patterns explained here are not \"one or the other\". You can mix and match whatever makes sense to you and your project.\n\n## Declarative for the win\n\n### File structure\n```js\nsrc/\n  app/\n    modules/\n      ...\n    actions.js\n    factories.js\n    sequences.js\n    errors.js\n    index.js\n  controller.js\n```\n\nThis pattern favors a single file for each type of composable component of a signal. This allows you to create less files and less import statements, though the individual files will have multiple definitions.\n\n### Actions\n```js\nexport function actionA ({ state }) {\n  state.set('foo', 'bar')\n}\n\nexport function actionB ({ state }) {\n  state.set('foo', 'bar')\n}\n```\n\nYou export multiple actions from each modules *actions.js* file. You will create an action or a factory for every single piece of logic. This will make your sequences more declarative, though you will need to write more custom logic.\n\nIf you prefer arrow functions, you can write:\n\n```js\nexport const actionA = ({ state }) => state.set('foo', 'bar')\n\nexport const actionB = ({ state }) => state.set('foo', 'bar')\n```\n\n### Factories\n\nFactories are similar to actions:\n\n```js\n// Normal function\nexport function setLoadingApp (isLoading) {\n  return function setLoadingApp({ state }) {\n    state.set('isLoading', isLoading)\n  }\n}\n\n// Arrow function\nexport const setLoadingApp = (isLoading) => function setLoadingApp({ state }) {\n  state.set('isLoading', isLoading)\n}\n```\n\n### Sequences\n\nYou import all actions and factories into the *sequences.js* file. This will give you autosuggestions on available actions and factories. Notice in this pattern that all sequence logic is fully declarative.\n\n```js\nimport * as actions from './actions'\nimport * as factories from './factories'\n\nexport const initialize = [\n  factories.setLoadingApp(true),\n  actions.getUser,\n  actions.setUser,\n  factories.setLoadingApp(false),\n]\n```\n\n### Modules\n\nYou import all your sequences into the modules file, attaching them to the signals definition.\n\n```js\nimport { Module } from 'cerebral'\nimport * as sequences from './sequences'\nimport * as errors from './errors'\n\nexport default Module({\n  state: {\n    isLoading: false\n  },\n  signals: {\n    initialized: sequences.initialize\n  },\n  catch: [\n    [errors.AuthError, sequences.catchAuthError]\n  ]\n})\n```\n\n## Clean and easy\n\nThe *\"Declarative for the win\"* pattern does not include the operators of Cerebral. The reason is that operators has a cost. The cost is less declarative code in favor of less action implementations. That said operators are still declarative and it ends up being a preference choice. Also the previous pattern puts multiple definitions into one file, you might prefer separating them.\n\n### File structure\n```js\nsrc/\n  app/\n    modules/\n    actions/\n    factories/\n    sequences/\n    errors.js\n    index.js\n  controller.js\n```\n\n### Actions\nEach action is put into its own file.\n\n```js\nfunction actionA ({ state }) {\n  state.set('foo', 'bar')\n}\n\nexport default actionA\n```\n\n### Factories\n\nFactories are similar to actions:\n\n```js\nfunction setLoadingAppFactory (isLoading) {\n  return function setLoadingApp({ state }) {\n    state.set('isLoading', isLoading)\n  }\n}\n\nexport default setLoadingAppFactory\n```\n\n### Sequences\n\nYou import individual actions and factories into the sequence file and combine them with operators.\n\n```js\nimport { set } from 'cerebral/operators'\nimport { state, props } from 'cerebral/tags'\nimport getUser from '../actions/getUser'\n\nexport const initialize = [\n  set(state`isLoading`, true),\n  getUser,\n  set(state`user`, props`user`),\n  set(state`isLoading`, false)\n]\n```\n\n### Modules\n\nYou import all your sequences into the modules file, attaching them to the signals definition.\n\n```js\nimport { Module } from 'cerebral'\nimport * as sequences from './sequences'\nimport * as errors from './errors'\n\nexport default Module({\n  state: {\n    isLoading: false\n  },\n  signals: {\n    initialized: sequences.initialize\n  },\n  catch: [\n    [errors.AuthError, sequences.catchAuthError]\n  ]\n})\n```\n","title":"Patterns"},"test":{"raw":"# Test\n\n## Snapshot testing (beta)\n\nSnapshot testing allows you to use the Cerebral debugger to create your tests. Just trigger a signal in your application, select it in the debugger and click \"Create signal test\". The test will now run the signal as normal with mocked providers. Any provider usage and mutations related to the original signal execution is handled by the test.\n\n[Read more in the API section](/docs/api/test)\n\n## Traditional assertion\n\nYou can also use a more traditional approach where you assert signal execution.\n\n[Read more in the API section](/docs/api/test)\n","title":"Test"},"typescript":{"raw":"# Typescript\n\nAlthough Cerebral does provide type definitions, it is encouraged to use the [@cerebral/fluent](/docs/addons/fluent) addon. This package exposes a signals API that gives you full type safety. It also uses [mobx](https://mobx.js.org/) for state management, meaning you get type safety and auto suggestions throughout your whole app as well.\n\nRead through [the Typescript guide](/docs/guides/typescript) to learn more about how it works!","title":"Typescript"}},"contribute":{"index":{"raw":"# Introduction\n\nOpen source would never work without contributions, but it is difficult to get a sense of where you can put in an effort to help out on a project. Where is help needed? How does the project work? How do I create a pull request? On this page you will hopefully get the information you need to contribute to the Cerebral project.\n\n## Contribute to documentation\n\nContributing with missing explanations and wrong documentation is the **most important** contribution you can make to any project.\n\n```marksy\n<Youtube url=\"https://www.youtube.com/embed/5UXmyClZkjU\" />\n```\n\n## Contribute to website\n\nNew documentation like guides is a really great way to contribute as it will help others with specific use cases.\n\n```marksy\n<Youtube url=\"https://www.youtube.com/embed/yhDTzXSOD7E\" />\n```\n\n## Contribute to codebase\n\nBug fixes, refactors, typescript typings and new features is also a really great way to contribute. Mostly because you get insight into the code and get more ownership.\n\n```marksy\n<Youtube url=\"https://www.youtube.com/embed/TYkylI7Aado\" />\n```","title":"Introduction"},"issues":{"raw":"# Issues\n\nThis is an overview of current issues that requires a **pull request**. They have been commented with a recommended approach.","title":"Issues"}},"guides":{"index":{"raw":"# Composing\n\nComposing, or composition, is a term we use in programming to explain the \"lego blockyness\" of our code. To give you an example think of a function:\n\n```js\nfunction myFunction () {}\n```\n\nFunctions are composable. You can call the same function multiple times:\n\n```js\nfunction myFunction () {}\n\nmyFunction()\nmyFunction()\n```\n\nYou can pass the function into an other function and call it from there:\n\n```js\nfunction myFunction () {}\nfunction someOtherFunction (func) {\n  func()\n}\n\nsomeOtherFunction(myFunction)\n```\n\nAnd you can even call a function which returns a function:\n\n```js\nfunction createFunction () {\n  return function myCreatedFunction () {}\n}\n\nconst func = createFunction()\nfunc()\n```\n\nFunctions are awesome, but there is actually a hidden requirement here. For these functions to keep their composability they need to be pure. If the function would do:\n\n```js\nlet someState = 0\nfunction myFunction() {\n  someState++\n  doThis()\n  doThat()\n}\n```\n\nIt would loose its composability because it would run differently every time and you would be forced to run **doThis** and **doThat**.\n\n## Cerebral actions\n\nWhen running a signal in Cerebral you run a sequence of actions. For example:\n\n```js\n[\n  doThis,\n  doThat\n]\n```\n\nEven though actions in Cerebral are not 100% pure, they do inherit all the benefits of composition as explained above. We kinda force you to write your code in a composable manner. So let us explore a bit more the benefits this gives you.\n\n```marksy\n<Twitter text=\"Even though actions in Cerebral are not 100% pure, they do inherit all the benefits of composition as explained above.\" hashtags=\"cerebral\"/>\n```\n\n## Scoping for composition\nWhen we want to make code reusable we need to scope it to a single task. That way we can build more complex tasks by composing together smaller ones. This is easy and intuitive in Cerebral:\n\n```js\nfunction getUser({http}) {\n  return http.get('/user')\n}\n\nexport default getUser\n```\n\nThis action can now be used in any sequence.\n\n```js\nimport getUser from './actions/getUser'\n\nexport default [\n  getUser\n]\n```\n\nIn Cerebral you are encouraged to put your actions in individual files or group actions related to each in one file and export them individually.\n\nSo every action should just do one single thing.\n\n## Sequences\n\nSo let us imagine that we build a sequence like this:\n\n*updateUser.js*\n```js\nimport getUser from './actions/getUser'\nimport setUser from './actions/setUser'\n\nexport default [\n  getUser,\n  setUser\n]\n```\n\nWe can just as easily compose this sequence into an existing sequence:\n\n```js\nimport doThis from './actions/doThis'\nimport updateUser from './updateUser'\n\nexport default [\n  updateUser,\n  doThis\n]\n```\n\nFor Cerebral it does not matter if you insert a single action or a sequence of actions, they compose just fine.\n\n## Action factories\nAn other powerful concept in the introduction is the concept of a factory, a function that creates a function. This allows us to create more generic action factories in Cerebral. For example:\n\n```js\nfunction httpGetFactory (url) {\n  function httpGet ({http}) {\n    return http.get(url)\n  }\n  \n  return httpGet\n}\n\nexport default httpGetFactory\n```\n\nNow instead of having a **getUser** action, we can use **httpGet** for any kind of get request we want to run:\n\n```js\nimport httpGet from './factories/httpGet'\nimport setUser from './actions/setUser'\n\nexport default [\n  httpGet('/user'),\n  setUser\n]\n```\n\nActually most packages and also Cerebral itself takes advantage of this concept and call them operators:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpGet('/user'),\n  set(state`user`, props`result`)\n]\n```\n\nThat means you can write a lot of your business logic without creating a single action.\n\n## Sequence factories\nBut since sequences and actions can be composed together you can also create factories for sequences. A typical example of that is to dynamically run sequences. For example:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\nimport {set, when} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nfunction authenticate(continueSequence) {\n  return [\n    when(state`user`) {\n      'true': continueSequence,\n      'false': [\n        httpGet('/user'),\n        set(state`user`, props`result`),\n        continueSequence\n      ]\n    }\n  ]\n}\n\nexport default authenticate\n```\n\nAnd in some other sequence:\n\n```js\nimport doThis from './actions/doThis'\nimport authenticate from './factories/authenticate'\n\nexport default authenticate([\n  doThis\n])\n```\n\n## Composing signals\n\nYou might get into a situation where it seems natural to think that you want to compose by firing off a signal from an other signal. For example:\n\n```js\n[\n  doThis,\n  doThat,\n  function nextSignal ({controller}) {\n    controller.getSignal('some.signal')()\n  }\n]\n```\n\nThis is not a good idea because this will run two separate processes. If you rather compose their sequences together:\n\n```js\nimport someSignal from './someSignal'\n\n[\n  doThis,\n  doThat,\n  someSignal\n]\n```\n\nYou will get the same execution, only it is composed together. This is also now reflected as one execution in the debugger. If this needs to be dynamic in nature you can use factories.\n\n## Summary\n\nThe anatomy of a Cerebral action gives you the power of composability while running side effects. That means you are not forced writing completely pure input/output functions, but run side effects as you please.","title":"Composing"},"http":{"raw":"# Http\n\nMost application needs some sort of standard requests going to a server, even using alternative solution like Firebase or Graphql. Cerebral HTTP provider is a simple JSON first based HTTP library that conforms to the functional nature of Cerebral.\n\n## Configuring the provider\n\n```js\nimport {Module} from 'cerebral'\nimport HttpProvider from '@cerebral/http'\n\nexport default Module({\n  providers: {\n    http: HttpProvider()\n  }\n})\n```\n\nBy default you really do not have to configure anything. By adding the provider we are ready to make requests inside our actions:\n\n```js\nfunction someAction ({http}) {\n  return http.get('/something')\n}\n```\n\nYou might need to set some default headers, or maybe you need to pass cookies to 3rd party urls:\n\n```js\nimport {Module} from 'cerebral'\nimport HttpProvider from '@cerebral/http'\n\nexport default Module({\n  providers: {\n    http: HttpProvider({\n      headers: {\n        'Authorization': 'token whatevah'\n      },\n      withCredentials: true\n    })\n  }\n})\n```\n\nThis configuration makes sure every request has an *Authorization* header and cookies are passed to any request, also outside the origin.\n\n## Per request configuration\n\nThese options are also available when doing specific requests. For example we want to post some data using the older url encoded format:\n\n```js\nfunction getUser({http, state}) {\n  return http.post('/user', state.get('form'), {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }\n  })\n}\n```\n\n## Handling responses\n\nWhen you make a request with the HTTP provider it will return an object of:\n\n```js\n{\n  status: 200,\n  headers: {},\n  result: {}\n}\n```\n\nWhen using an action you typically want to name the result and output it to the signal execution:\n\n```js\nfunction getUser({http}) {\n  return http.get('/user')\n    .then(({result}) => ({user: result}))\n}\n```\n\nYou might also want to diverge execution based on the status:\n\n```js\nfunction getUser({http, path}) {\n  return http.get('/user')\n    .then(({status, result}) => {\n      switch (status) {\n        case 404:\n          return path.notFound()\n        case 401:\n          return path.unauthorized()\n        case 200:\n          return path.success({user: result})\n        default:\n          return path.error()\n      }\n    })\n}\n```\n\n## Taking advantage of operators\n\nOperators allows you to handle HTTP requests directly in the sequence of actions:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\n\nexport default [\n  httpGet('/user')\n]\n```\n\nThe operator outputs the response to the signal, meaning that **status**, **result** and **headers** will now be available for the next actions. That means you could easily combine this with a Cerebral operator:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpGet('/user'),\n  set(state`app.user`, props`response.result`)\n]\n```\n\nThe HTTP operators are actually pretty smart. You can optionally use paths to diverge execution. So if you wanted to speficially handle **success** and **error**, you could do this instead:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpGet('/user'), {\n    success: set(state`app.user`, props`response.result`),\n    error: set(state`app.error`, props`response.result`)\n  }\n\n]\n```\n\nYou can even use status codes as paths by default:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpGet('/user'), {\n    401: set(state`app.isAuthorized`, false)\n    success: set(state`app.user`, props`response.result`),\n    error: set(state`app.error`, props`response.result`)\n  }\n]\n```\n\n## Dynamic urls\n\nWhen using operators it is quite restrictive to use a static url, you might want to build the url based on some state, or maybe a property passed into the signal. You can use tags for this:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\nimport {set} from 'cerebral/operators'\nimport {state, string} from 'cerebral/tags'\n\nexport default [\n  httpGet(string`/items/${state`app.currentItem.id`}`)\n]\n```\n\n## Catching errors\n\nNow, it is encouraged that you write your sequences of actions vertically for readability. So when you do:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpGet('/user'),\n  set(state`app.user`, props`response.result`)\n]\n```\n\nYou will need a way to handle errors. The HTTP provider actually throws an error in this scenario if something goes wrong and you can catch that error in either a signal specific error handler or a global. Typically you want a global error handler, so let us explore that:\n\n```js\nimport {Module} from 'controller'\nimport HttpProvider, {HttpProviderError} from '@cerebral/http'\nimport httpErrorThrown from './signals/httpErrorThrown'\n\nexport default Module({\n  providers: {\n    http: HttpProvider()\n  },\n  catch: [\n    [HttpProviderError, httpErrorThrown]\n  ]\n})\n```\n\nWhat we basically do here is map HTTP provider errors to a signal. So whenever one of your requests gets into problems, you will be able to handle it inside the **HttpErrorThrown** signal.\n\nThe data you get passed in is something similar to:\n\n```js\n{\n  name: 'HttpProviderError',\n  message: 'Some potential error message',\n  response: {\n    body: 'Message or response body',\n    status: 200,\n    isAborted: false,\n    headers: {},\n  },\n  stack: '...'  \n}\n```\n\n## Aborting requests\n\nSometimes you might need to abort requests, a typical example of this is typeahead. Let us just write out an example here first:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, props, string} from 'cerebral/tags'\nimport {httpGet, httpAbort} from '@cerebral/http'\n\n[\n  set(state`searchValue`, props`value`),\n  httpAbort('/search*'),\n  debounce(250), {\n    continue: [\n      httpGet(string`/search?value=${state`searchValue`}`), {\n        success: set(state`searchResult`, props`response.result`),\n        error: [],\n        abort: []\n      }\n    ],\n    discard: []\n  }\n]\n```\n\nAnd that is it, you have a typeahead. The **httpAbort** operator just takes a regexp string to decide what possibly running requests that will be aborted.\n\n## File upload\n\nYou can also upload files from your signals. Either a file you pass in as props to a signal or directly from the state tree. Files are one of the special value types Cerebral supports. We say special value types because files are not serializable by default.\n\nUpload a file is as simple as:\n\n```js\nimport {httpUploadFile} from '@cerebral/http/operators'\nimport {props} from 'cerebral/tags'\n\nexport default [\n  httpUploadFile('/upload', props`file`)\n]\n```\n\nTypically with file upload you want to track the upload progress. You can do this by passing the path of a progress signal you have created as an option:\n\n```js\nimport {httpUploadFile} from '@cerebral/http/operators'\nimport {props} from 'cerebral/tags'\n\nexport default [\n  httpUploadFile('/upload', props`file`, {\n    onProgress: 'files.uploadProgressed'\n  })\n]\n```\n\nThe progress signal will get the payload of:\n\n```js\n{\n  progress: 45 // The percentage completed\n}\n```\n\nAdditional options for setting the name, passing additional data and headers are also available:\n\n```js\nimport {httpUploadFile} from '@cerebral/http/operators'\nimport {props} from 'cerebral/tags'\n\nexport default [\n  httpUploadFile('/upload', props`file`, {\n    name: 'newImage.png',\n    data: state`files.currentMetaData`,\n    headers: {},\n    onProgress: 'files.uploadProgressed'\n  })\n]\n```\n\nYou can of course choose to do this at action level instead. It is the same api:\n\n```js\nfunction uploadFile ({props, http}) {\n  return http.uploadFile('/upload', props.file)\n}\n```\n\n## Summary\nThe Cerebral http provider is a simple provider that gives you access to the most common functionality. You can use any other http library if you want to by just exposing it as a provider. For example:\n\n```js\nimport {Provider} from 'cerebral'\nimport axios from 'axios'\n\nexport default Provider({\n  get(...args) {\n    return axios.get(...args)\n  },\n  // And so on\n})\n```\n\nThe operators of http provider though makes it a natural choice when working with Cerebral.\n","title":"Http"},"operators":{"raw":"# Operators\n\nA common concept in programming is factories. A factory is basically a function that creates a function:\n\n```js\nfunction createMessager (name) {\n  function message (msg) {\n    return `${name}, ${msg}`\n  }\n  \n  return message\n}\n\nconst message = createMessager('Bob')\n\nmessage('what is happening?') // \"Bob, what is happening?\"\n```\n\nCreating a factory gives you the possibility to configure what a function should do before it is run. This is a perfect concept for Cerebral, it is such a perfect concept that we highlight as a core feature called **operators**.\n\n## Some example operators\n\nSo the typical operators you use with Cerebral are the state operators:\n\n```js\nimport {set, push} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, 'bar'),\n  push(state`list`, 'foo')\n]\n```\n\nBut operators are also available in other packages, like [@cerebral/http](https://www.npmjs.com/package/@cerebral/http):\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\n\nexport default [\n  httpGet('/items')\n]\n```\n\nSo how does these operators actually work? Let us digest one of them.\n\n## Dissecting an operator\n\nOur example above was using the **httpGet** operator. To support the syntax above it would have to look like this:\n\n```js\nfunction httpGetFactory (url) {\n  function httpGet ({http}) {\n    return http.get(url)\n  }\n  \n  return httpGet\n}\n```\n\nWhen **httpGet** is called it will return a function, an action, for us. This action is configured with a url and when it is called it will run the http provider with the configured url.\n\nBut **httpGet** actually has more features than this. You can use a *string tag* instead of a normal string.\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\nimport {string, props} from 'cerebral/tags'\n\nexport default [\n  httpGet(string`items/${props`itemId`}`)\n]\n```\n\nHere we have configured our function to produce the url based on the property **itemId** passed through the signal. How do we handle that inside our operator?\n\n### Resolve values\n\nInstead of using the url directly, like we do here:\n\n```js\nfunction httpGetFactory (url) {\n  function httpGet ({http}) {\n    return http.get(url)\n  }\n  \n  return httpGet\n}\n```\n\nWe can rather resolve it, using the **resolve** provider:\n\n```js\nfunction httpGetFactory (url) {\n  function httpGet ({http, resolve}) {\n    return http.get(resolve.value(url))\n  }\n  \n  return httpGet\n}\n```\n\nBy using the resolver we evaluate the tag used to \"configure\" the returned action. It can still be just a plain string, no worries, but now we can also use tags and even a computed.\n\n### Optional paths\n\nThe operators of the **@cerebral/http** package has a pretty cool feature which allows you to optionally use paths. For example:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\n\nexport default [\n  httpGet('/items')\n]\n```\n\nOr:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\n\nexport default [\n  httpGet('/items'), {\n    sucess: [],\n    error: []\n  }\n]\n```\n\nYou can even base the paths on status codes:\n\n```js\nimport {httpGet} from '@cerebral/http/operators'\n\nexport default [\n  httpGet('/items'), {\n    success: [],\n    404: [],\n    error: []\n  }\n]\n```\n\nThis gives a lot of flexibility, but how does it work? Let us do some more digesting:\n\n```js\nfunction httpGetFactory (url) {\n  function httpGet ({http, resolve, path}) {\n    if (path) {\n      // More to come\n    } else {\n      return http.get(resolve.value(url))\n    }\n  }\n  \n  return httpGet\n}\n```\n\nWe can actually check if **path** exists on the context of the action. If it does not exist, it means that the action can not diverge execution down a path:\n\n```js\nfunction httpGetFactory (url) {\n  function httpGet ({http, resolve, path}) {\n    if (path) {\n      return http.get(resolve.value(url))\n        .then((response) => {\n          return path.success({response})\n        })\n        .catch((error) => {\n          return path.error({error})\n        })\n    } else {\n      return http.get(resolve.value(url))\n    }\n  }\n  \n  return httpGet\n}\n```\n\nSo based on the path existing or not we call the expected *success* and *error* paths respectively. \n\nBut what about the status codes? Lets extend our example:\n\n```js\nfunction httpGetFactory (url) {\n  function httpGet ({http, resolve, path}) {\n    if (path) {\n      return http.get(resolve.value(url))\n        .then((response) => {\n          return (\n            path[response.status] ?\n              path[response.status]({response})\n            :\n              path.success({response})\n          )\n        })\n        .catch((error) => {\n          return (\n            path[error.status] ?\n              path[error.status]({error})\n            :\n              path.error({error})\n          )\n        })\n    } else {\n      return http.get(resolve.value(url))\n    }\n  }\n  \n  return httpGet\n}\n```\n\n### Resolve tag paths\n\nYou can also resolve the paths of a tag. For example:\n\n```js\nstate`foo.bar`\n```\n\nThe path in this example is **foo.bar**. Or:\n\n```js\nstate`items.${props`itemId`}`\n```\n\nThis might resolve to **items.123**.\n\nResolving the path instead of the value within the path gives some contextual power. For example the core Cerebral operators uses this feature:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, props`foo`)\n]\n```\n\nSo here we are using two tags, **state** and **props**, and they have two different contextual meanings. The **state** tag is used to identify *where* to put a value, and the **props** tag is used to identify *what* value.\n\nSo this is a simple implementation of that:\n\n```js\nfunction setFactory (target, value) {\n  function set ({state, resolve}) {\n    // First we identify that we have the tag\n    // type we want\n    const isStateTag = resolve.isTag(target, 'state')\n    \n    // We use the type of tag to identify\n    // where we want to do a \"set\"\n    if (isStateTag) {\n      // We extract the path, \"foo\", so that\n      // we know where to set the value\n      const statePath = resolve.path(target)\n      \n      // We do a normal \"state.set\" with the\n      // resolved path and value\n      state.set(statePath, resolve.value(value))\n    } else {\n      throw new Error('Target must be a state tag')\n    }\n  }\n  \n  return set\n}\n\nexport default setFactory\n```\n\nAs you can see we used `resolve.path` for the **state** tag and `resolve.value` for the **props** tag. This is because the \"target tag\" is used to identify at what target and where we want to put a value, and the \"value tag\" is used to extract the actual value.\n\n## Enhancing your action factories\n\nYou will very likely create a lot of action factories in your application. This drys up your code and makes your signals more expressive. If you start using the **resolver** you can make your action factories even more expressive, as they basically get the same behaviour as operators. One such action factory could be notifying the user:\n\n```js\nimport notify from '../factories/notify'\nimport {string} from 'cerebral/tags'\n\nexport default [\n  notify(string`Sorry ${state`user.name`}, this does not work :(`)\n]\n```\n\nSince the string tag can not look up a value, unlike **state** and **props**, both `resolve.path` and `resolve.value` resolves to the path. Meaning that the **notify** factory could look something like this:\n\n```js\nfunction notifyFactory (message) {\n  function notify ({state, resolve}) {\n    state.set('message', resolve.value(message))\n  }\n  \n  return notify\n}\n```\n\n## Summary\nYou might build your whole application without taking advantage of tags in your action factories, but it is a powerful concept that can express more logic in your signal definitions making your code even more readable.\n\n","title":"Operators"},"routing":{"raw":"# Routing\n\nIf you are not familiar with how Cerebral does its routing we can start off by telling you that it is different than traditional routing. Traditional routers map url changes to views/components. The Cerebral router maps urls to signals. So, why change the behaviour?\n\nEvery event in your application triggers a signal that normally leads to one or multiple state changes. This is not special to Cerebral, this is how all applications work. A url change is also an event in your application, just like a button click or a websocket message. In Cerebral you treat URL changes the same way as any other event in your application, with a signal. The router does not affect your view/components layer at all. The benefit of this approach is consistency and flexibility. You can make a url change be anything you want.\n\n## Adding the router\n\nThe router is its own package, **@cerebral/router**. You instantiate it simply by adding it to the root Cerebral module:\n\n*app/index.js*\n```js\nimport {Module} from 'cerebral'\nimport Router from '@cerebral/router'\n\nconst router = Router({\n  routes: [{\n    path: '/',\n    signal: 'rootRouted' \n  }]\n})\n\nexport default Module({\n  modules: {router}\n})\n```\n\nThis means that when the root url is hit the signal **rootRouted** will trigger.\n\n## Simple page transitions\n\nLet us imagine that our application has 2 pages:\n\n*app/index.js*\n```js\nimport {Module} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst router = Router({\n  routes: [{\n    path: '/',\n    signal: 'rootRouted'\n  }, {\n    path: '/items',\n    signal: 'itemsRouted'\n  }]\n})\n\nexport default Module({\n  modules: {router}\n})\n```\n\nHow do we make our components render each page? Well, first of all we need a state that tells our components what page to display. Let us also add the two signals which will set the correct page:\n\n*app/index.js*\n```js\nimport {Module} from 'cerebral'\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\nimport router from './router'\n\nexport default Module({\n  modules: {router},\n  state: {\n    currentPage: 'home'\n  },\n  signals: {\n    homeRouted: set(state`currentPage`, 'home'),\n    itemsRouted: set(state`currentPage`, 'items')\n  }\n})\n```\n\nAs you can see we moved the router to its own file, this is recommended. We now have state that represents what page we are on, let us use it in a component to display the correct page:\n\n*App.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nimport Home from './Home'\nimport Items from './Items'\n\nconst pages = {\n  home: Home,\n  items: Items\n}\n\nexport default connect({\n  currentPage: state`currentPage`\n},\n  function App ({currentPage}) {\n    const Page = pages[currentPage]\n    \n    return (\n      <div>\n        <Page />\n      </div>\n    )\n  }\n)\n```\n\nThe url triggers an event, which triggers a signal, which sets the application in the correct state. The components now update and renders based on the current state of the application. With Cerebral you think about url changes as any other event in your application.\n\n## Loading data on url change\n\nThe great thing about urls firing off signals is that you can run any side effect you need, also deciding when the page change actually occurs. Lets say the items page needed to grab the items to be listed. We add a couple of new states related to this and update our signal:\n\n*app/index.js*\n```js\nimport {Module} from 'cerebral'\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\nimport HttpProvider, {httpGet} from '@cerebral/http/operators'\nimport router from './router'\n\nexport default Module({\n  modules: {router},\n  providers: {\n    http: HttpProvider()\n  },\n  state: {\n    currentPage: 'home',\n    items: [],\n    isLoadingItems: false\n  },\n  signals: {\n    homeRouted: set(state`currentPage`, 'home'),\n    itemsRouted: [\n      set(state`currentPage`, 'items'),\n      set(state`isLoadingItems`, true),\n      httpGet('/items'),\n      set(state`items`, props`result`),\n      set(state`isLoadingItems`, false)\n    ]\n  }\n})\n```\n\nSo now we change the page immediately and we indicate that we are loading the items before getting them. But we could flip this around:\n\n*app/index.js*\n```js\nimport {Module} from 'cerebral'\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\nimport HttpProvider, {httpGet} from '@cerebral/http/operators'\nimport router from './router'\n\nexport default Module({\n  modules: {router},\n  providers: {\n    http: HttpProvider()\n  },\n  state: {\n    currentPage: 'home',\n    items: [],\n    isLoadingPageData: false\n  },\n  signals: {\n    homeRouted: set(state`currentPage`, 'home'),\n    itemsRouted: [\n      set(state`isLoadingPageData`, true),\n      httpGet('/items'),\n      set(state`items`, props`result`),\n      set(state`isLoadingPageData`, false),\n      set(state`currentPage`, 'items')\n    ]\n  }\n})\n```\n\nNow we rather indicate with a state that we are preparing some data for a page. This could for example show a progress animation at the top of the page, typically what you see on Youtube and linkedIn. When the data is ready, the page is changed.\n\nThis already shows you the flexibility of treating url changes as events in your app instead of making it part of your component tree.\n\n## Dry up code with factories\n\nFactories is an important concept in Cerebral and we can clean up our code a little bit:\n\n*app/index.js*\n```js\nimport {Module} from 'cerebral'\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\nimport HttpProvider, {httpGet} from '@cerebral/http/operators'\nimport router from './router'\n\nfunction changePage (page, continueSequence = []) {\n  return [\n    set(state`currentPage`, page),\n    continueSequence\n  ]\n}\n\nexport default Module({\n  modules: {router},\n  providers: {\n    http: HttpProvider()\n  },\n  state: {\n    currentPage: 'home',\n    items: [],\n    isLoadingItems: false\n  },\n  signals: {\n    homeRouted: changePage('home'),\n    itemsRouted: changePage('items', [\n      set(state`isLoadingItems`, true),\n      httpGet('/items'),\n      set(state`items`, props`result`),\n      set(state`isLoadingItems`, false)\n    ])\n  }\n})\n```\n\nWe have now created a factory that allows us to define what page to change to. We did not clean up a lot here, but the **changePage** factory might do many different things related to moving from one page to an other.\n\n## Initial data\n\nWe have already looked at how to load data on a specific url event, the **/items** url, where we load the items. But sometimes you want to load some initial data no matter what url is triggered. We could implement this logic into **changePage** like this:\n\n*changePage.js*\n```js\nimport {set, when} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\nimport {httpGet} from '@cerebral/http/operators'\n\nfunction changePage (page, continueSequence = []) {\n  return [\n    set(state`currentPage`, page),\n    when(state`hasLoadedInitialData`), {\n      'true': continueSequence,\n      'false': [\n        httpGet('/initialdata'),\n        set(state`initialData`, props`result`),\n        set(state`hasLoadedInitialData`, true),\n        continueSequence\n      ]\n    }\n  ]\n}\n\nexport default changePage\n```\n\nBut you might not want to load initial data on all page changes. Maybe you have a welcome page, or an about page. Going directly to those should not load the initial data. To solve it you would just create a separate factory for it:\n\n*app/index.js*\n```js\nimport {Module} from 'cerebral'\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\nimport HttpProvider, {httpGet} from '@cerebral/http/operators'\nimport router from './router'\nimport changePage from './factories/changePage'\nimport withInitialData from './factories/withInitialData'\nimport itemsRouted from './signals/itemsRouted'\n\nexport default Module({\n  modules: {router},\n  providers: {\n    http: HttpProvider()\n  },\n  state: {\n    currentPage: 'home',\n    items: [],\n    isLoadingItems: false,\n    hasInitialData: false,\n    initialData: null\n  },\n  signals: {\n    homeRouted: changePage('home'),\n    itemsRouted: changePage('items', withInitialData(itemsRouted))\n  }\n})\n```\n\n## Authentication\n\nIn our simple application we want the user to be authenticated only when moving to **/items**.\n\n*app/index.js*\n```js\nimport {Module} from 'cerebral'\nimport router from './router'\nimport HttpProvider from '@cerebral/http/operators'\nimport changePage from './factories/changePage'\nimport authenticate from './factories/authenticate'\nimport itemsRouted from './signals/itemsRouted'\n\nexport default Module({\n  modules: {router},\n  providers: {\n    http: HttpProvider()\n  },\n  state: {\n    user: null,\n    currentPage: 'home',\n    items: [],\n    isLoadingItems: false\n  },\n  signals: {\n    homeRouted: changePage('home'),\n    itemsRouted: authenticate(changePage('items', itemsRouted))\n  }\n})\n```\n\nAs you can see we again use a factory, only we wrap **changePage**. That way we do not even change the page if the authentication fails. The authenticate factory could look something like this:\n\n*authenticate.js*\n```js\nimport {set, when} from 'cerebral/operators'\nimport {redirect} from '@cerebral/router/operators'\nimport {state} from 'cerebral/tags'\n\nfunction authenticate (continueSequence) {\n  return [\n    when(state`user`), {\n      'true': continueSequence,\n      'false': redirect('/')\n    }\n  ]\n}\n\nexport default authenticate\n```\n\nWe just check to see if we have a user and continue the sequence of actions if we do. If not, we redirect back to front page. This is of course simplified and you might do lots of different things here, but the point is that you can easily compose this factory into whatever signal you want to prevent it from moving on when the user is not authenticated.\n\n## Nested routes\n\nSo what if we wanted to bind a route to show a single item? The single item is not a page by its own, it is a modal inside our **items** page. The way we solve this is simply by composing. We run the same logic as opening the **items** and then we add the logic for opening a single item:\n\n*app/index.js*\n```js\nimport {Module} from 'cerebral'\nimport router from './router'\nimport HttpProvider from '@cerebral/http'\nimport changePage from './factories/changePage'\nimport authenticate from './factories/authenticate'\nimport itemsRouted from './signals/itemsRouted'\nimport itemRouted from './signals/itemRouted'\n\nexport default Module({\n  modules: {router},\n  providers: {\n    http: HttpProvider()\n  },\n  state: {\n    user: null,\n    currentPage: 'home',\n    items: [],\n    isLoadingItems: false,\n    isLoadingItem: false,\n    currentItemId: null\n  },\n  signals: {\n    homeRouted: changePage('home'),\n    itemsRouted: authenticate(changePage('items', itemsRouted)),\n    itemRouted: authenticate(changePage('items', [itemsRouted, itemRouted]))\n  }\n})\n```\n\n*router.js*\n```js\nimport Router from '@cerebral/router'\n\nexport default Router({\n  routes: [{\n    path: '/',\n    signal: 'rootRouted'\n  }, {\n    path: '/items',\n    signal: 'itemsRouted'\n  }, {\n    path: '/items/:id',\n    signal: 'itemRouted'\n  }]\n})\n```\n\nThere are thousands of way to handle urls, related side effects and UI. The Cerebral router gives you freedom to compose how all this fits together without constraints. It is up to you to build your “lego blocks” and put them together in a way that makes sense for your application.\n\n## Animate transitions\n\nSo a fancy feature of routing is to transition one route to the next with an animation. This is not integrated into the Cerebral router, because there is no need to. You would handle this like any state transition. For example with a React Transition Group we could change our **App** component to animate between the pages instead:\n\n*App.js*\n```jsx\nimport React from 'react'\nimport CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nimport Home from './Home'\nimport Items from './Items'\n\nconst pages = {\n  home: Home,\n  items: Items\n}\n\nexport default connect({\n  currentPage: state`currentPage`\n},\n  function App ({currentPage}) {\n    const Page = pages[currentPage]\n    \n    return (\n      <div>\n        <CSSTransitionGroup\n          transitionName=\"example\"\n          transitionEnterTimeout={500}\n          transitionLeaveTimeout={300}\n        >\n          <Page />\n        </CSSTransitionGroup>\n      </div>\n    )\n  }\n)\n```\n\nThere really is nothing more to it.\n\n## Summary\n\nIn this article we looked into what a simple, yet powerful concept the Cerebral Router is. You map urls to signals and compose these signals in a way that makes sense for your application. When mapping to a signal you are free to run any state changes and side effects needed to resolve the url. Animations are introduced in the components like any other state change. The concept of factories allows you to compose together pieces of logic, even into new factories. No matter how complex this composition becomes it will all be displayed as one coherent flow in the debugger.\n","title":"Routing"},"ssr":{"raw":"# Server Side Rendering\n\nServer side rendering is tricky business. There are numerous considerations to take and how you execute on these considerations depends on the application. Cerebral supports server side rendering and in this article we will look at the typical strategies to make this work.\n\n## The flow\nWhen you want to deliver content to your users as fast as possible, like with a progressive web app, or you just want to search engine optimize the application, you will need to render the UI on the server and return it on the initial request.\n\nLet us imagine a user going to **www.example.com**. This request goes to the server and it will return some HTML, here showing example with Node express, manually returning the HTML string:\n\n```js\napp.get('/', (req, res) => {\n  res.send(`<!DOCTYPE html>\n<html>\n  <head></head>\n  <body>\n    <div id=\"app\"></div>\n    <script src=\"/app.js\"></script>\n  </body>\n</html>`)\n})\n```\n\nThis response is now displayed in the browser and the Cerebral application is ready to take over and your view library of choice will populate the `<div id=\"app\"></div>` with the HTML of the app.\n\nNow lets lay out the considerations we need to take regarding server side rendering:\n\n1. **Render components** - The minimum requirement is to actually render the components on the server inside the same `<div id=\"app\"></div>` as the client will.\n\n2. **Universal Controller** - When your client fires up it might need some initial data from the server to display the content. With the help of the **Universal Controller** we can automate this process.\n\n3. **Synchronize with router** - If your application uses the Cerebral router it is not only initial data that possibly needs to be synchronized, but also the state that is related to what URL you are on.\n\n```marksy\n<Twitter text=\"There are several considerations you need to take evaluating SSR for your application\" hashtags=\"cerebral\"/>\n```\n\n## Render components\n\nTo render the components on the server they should be as pure as possible. By default components in a Cerebral app are kept pure because all business logic is contained in signals. That means it is safe to grab your root component on the server and render it:\n\n```js\nimport App from '../client/components/App'\nimport {renderToString} from 'react-dom/server'\n\napp.get('/', (req, res) => {\n  const appHtml = renderToString(<App/>)\n  \n  res.send(`<!DOCTYPE html>\n<html>\n  <head></head>\n  <body>\n    <div id=\"app\">${appHtml}</div>\n    <script src=\"/app.js\"></script>\n  </body>\n</html>`)\n})\n```\n\nA good workflow for working with server side rendered components requires some packages and configuration. This is one approach to such a setup.\n\n### Configure babel\nFirst install babel dependencies with `npm install babel-loader babel-preset-es2015 babel-preset-react babel-plugin-transform-define`. Instead of configuring babel options inside your webpack config, you should do so in a `.babelrc` file:\n\n```js\n{\n  \"presets\": [\"es2015\", \"react\"],\n  \"env\": {\n    \"development\": {\n      \"plugins\": []\n    },\n    \"production\": {\n      \"plugins\": [\n        [\"transform-define\", {\n          'process.env.NODE_ENV': 'production'\n        }]\n      ]\n    }\n  }\n}\n```\n\nNow everything related to babel, it being webpack, node or direct babel build will use the same configuration.\n\n### Development script\n\nYou will need to run both your server and the webpack development server for your client. This can be accomplished by `npm install concurrently webpack-dev-server babel-watch`. The webpack dev server will actually be your main development server, but it will proxy requests to your Node server as well. To configure this:\n\n*webpack.config.js*\n```js\nconst path = require('path')\n\nconst rules = [{\n  test: /\\.js?$/,\n  include: [path.resolve('src', 'client')],\n  use: [{\n    loader: require.resolve('babel-loader')\n  }]\n}]\n\nmodule.exports = {\n  entry: path.resolve('src', 'client', 'index.js'),\n  output: {\n    path: path.resolve('public'),\n    filename: 'app.js',\n    publicPath: '/',\n  },\n  module: {\n    rules: rules,\n  },\n  devServer: {\n    port: 3000,\n    proxy: {\n      '/': 'http://localhost:3001',\n    },\n    hot: false,\n    inline: false,\n  }\n}\n```\n\nAnd your startup script in **package.json** should look like:\n\n```js\n{\n  \"scripts\": {\n    \"start\": \"concurrently --prefix \\\"[{name}]\\\" --names \\\"CLIENT,SERVER\\\" -c \\\"white.bold,gray.bold\\\" \\\"webpack-dev-server\\\" \\\"babel-watch src/server/index.js --watch src\\\"\"\n  },\n  \"build:client\": \"webpack\",\n  \"build:server\": \"babel src/server --out-dir server-build\"\n}\n```\n\nWhat the *start* line does is fire up two processes, *webpack-dev-server* and *babel-watch* , then it watches `src` folder for changes. Now any changes to your client or server files will allow you to just refresh your browser and the updates are there.\n\nYou build production bundles for your client and server separately.\n\n## Universal Controller\n\nCerebrals universal controller allows you to mount your client side initial state on the server, execute logic to change that state and inject it with the server rendered app so that your client does not need to refetch the data.\n\nTo prepare your application for server side rendering it is a good idea to define the modules in its own file, that way you can reuse them on the server.\n\n*modules/index.js*\n```js\nexport {default as app} from './app'\nexport {default as admin} from './admin'\n```\n\n*controller.js*\n```js\nimport {Controller} from 'controller'\nimport app from './app'\n\nexport default Controller(app)\n```\n\nNow on your server you can prepare your universal controller the same way:\n\n```js\nimport {UniversalController} from 'cerebral'\nimport app '../client/app'\nimport App from '../client/components/App'\nimport {renderToString} from 'react-dom/server'\n\napp.get('/', (req, res) => {\n  const controller = UniversalController(app)\n  const appHtml = renderToString(<App/>)\n  \n  res.send(`<!DOCTYPE html>\n<html>\n  <head></head>\n  <body>\n    <div id=\"app\">${appHtml}</div>\n    <script src=\"/app.js\"></script>\n  </body>\n</html>`)\n})\n```\n\nThis means that when the app is rendered it will have the same initial state, both on the client and the server. To actually produce some new state we need to execute logic and we do that using the **run** method:\n\n```js\nimport {UniversalController} from 'cerebral'\nimport {Container} from 'cerebral/react'\nimport app from '../client/app'\nimport App from '../client/components/App'\nimport {renderToString} from 'react-dom/server'\n\nfunction setInitialState ({state, props}) {\n  state.set('app.user', props.user) \n}\n\napp.get('/', (req, res) => {\n  const controller = UniversalController(app)\n\n  db.getUser()\n    .then((user) => {\n      return controller.run(setInitialState, {user})\n    })\n    .then(() => {\n      const appHtml = renderToString(\n        <Container controller={controller}>\n          <App/>\n        </Container>\n      )\n      const stateScript = controller.getScript()\n  \n      res.send(`<!DOCTYPE html>\n<html>\n  <head>\n    ${stateScript}\n  </head>\n  <body>\n    <div id=\"app\">${appHtml}</div>\n    <script src=\"/app.js\"></script>\n  </body>\n</html>`)\n    })\n})\n```\n\nLets summarize the changes:\n\n1. We create a sequence, which is just one action, that expects to receive a user as a prop. This user is then put into the state\n\n2. Before we start rendering our application we go and grab a user from the database. When this user is fetched we run the controller passing in the user, making it available on the props\n\n3. When the execution is done we render the application by using the **Container** component which provides the controller to the components\n\n4. Now we can extract the script that contains the exact state changes made. The client will automatically pick up this script and produce the correct initial state of the application\n\n5. We put the script in the head\n\nThis is what you need to do if you want to put the client side application in a different state than the default one. There can be any number of reason for this, but beware... it is not strictly necessary. You might rather want to render your application in a \"skeleton version\" and then fetch the data needed from the client instead.\n\n## Synchronize with router\n\nIf your whole application is run from a single route, **/**, you do not have to worry about this. But if you want to combine server side rendering with a router you need to make sure that the server does not diverge from what the router will do when it triggers on client load. Let us imagine we have the following router setup:\n\n```js\nimport {Controller, Module} from 'cerebral'\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\nimport Router from '@cerebral/router'\n\nconst router = Router({\n  routes: [{\n    path: '/',\n    signal: 'homeRouted'\n  }, {\n    path: '/admin',\n    signal: 'adminRouted'\n  }]\n})\n\nconst app = Module({\n  modules: { router },\n  state: {\n    currentPage: 'home'\n  },\n  signals: {\n    homeRouted: set(state`currentPage`, 'home'),\n    adminRouted: set(state`currentPage`, 'admin')\n  }\n})\n\nexport default Controller(app)\n```\n\nThis is a pretty basic setup. When the router triggers it will, based on the url, change the **currentPage** state. That means when your user hits your server on either urls, the server needs to also set the correct state based on the url.\n\n```js\nimport {UniversalController, Module} from 'cerebral'\nimport App from '../client/components/App'\nimport {Container} from 'cerebral/react'\nimport {renderToString} from 'react-dom/server'\n\nfunction setInitialState ({state, props}) {\n  let page\n  if (props.path === '/') {\n    page = 'home'\n  } else if (props.path === '/admin') {\n    page = 'admin'\n  }\n  state.set('page', page)\n}\n\napp.get('*', (req, res) => {\n  const app = Module({\n    state: {\n      page: 'home'\n    }\n  })\n  const controller = UniversalController(app)\n  const mip = `hmm ${foo} ha`\n  \n  controller.run(setInitialState, {path: req.path})\n    .then(() => {\n      const appHtml = renderToString(\n        <Container controller={controller}>\n          <App/>\n        </Container>\n      )\n      const stateScript = controller.getScript()\n  \n      res.send(`<!DOCTYPE html>\n<html>\n  <head>\n    ${stateScript}\n  </head>\n  <body>\n    <div id=\"app\">${appHtml}</div>\n    <script src=\"/app.js\"></script>\n  </body>\n</html>`)\n  })\n})\n```\n\nYou would very likely create more specific routes and better handling of rendering the correct page, but this is just to give you an idea of how it works.\n\n## Summary\n\nRendering on the server is not straight forward. It depends heavily on the app. Do you do routing, or do you want a skeleton app and do data fetching on client? How beneficial is it to grab state on server and inject it compared to making those requests from the client? There is no one right answer to this. But with Cerebral you have the tools you need to produce state on the server and rehydrate that state on the client, if you want to.","title":"Server Side Rendering"},"typescript":{"raw":"# Typescript\n\nTo get full type safety with Cerebral you need to install the **@cerebral/fluent** addon.\n\n`npm install @cerebral/fluent`\n\nThis addon exposes its own set of Cerebral APIs that allows for type safety. In this guide we will go through how you would structure an application with this API.\n\n## Tsconfig\n\nA typical **tsconfig.json** looks like this:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"fluent\": [\"src/fluent.ts\"]\n    },\n    \"outDir\": \"dist\",\n    \"module\": \"esnext\",\n    \"target\": \"es5\",\n    \"sourceMap\": true,\n    \"strict\": true,\n    \"strictPropertyInitialization\": false,\n    \"jsx\": \"react\"\n  },\n  \"exclude\": [\"node_modules\"]\n}\n```\n\nThe **fluent.ts** file will be explained below.\n\n## Controller\n\nInstantiate the **Controller** exposed by `fluent`:\n\n```ts\nimport Devtools from 'cerebral/devtools'\nimport { Controller } from '@cerebral/fluent'\nimport { State, Signals } from './fluent'\n\nexport const controller = Controller<State, Signals>(app.module, {\n  devtools: Devtools(...),\n  // If you are migrating from existing app, add this option to\n  // allow for the legacy state api\n  useLegacyStateApi: true\n})\n```\n\nIt is optional to define the **State** and **Signals** type on the controller. This is only useful if you point to the state or the signal on the controller itself:\n\n```ts\ncontroller.state\ncontroller.signals\n```\n\n## Exposing the controller to React\n\nYou expose the controller using the **Container** from **fluent**:\n\n```ts\nimport * as React from 'react'\nimport { render } from 'react-dom'\nimport { controller } from './controller'\nimport { Container } from '@cerebral/fluent'\nimport { App } from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App />\n  </Container>,\n  document.querySelector('#app')\n)\n```\n\nYou will later see examples of how you actually connect components.\n\n## Creating the fluent file\n\nTo ease development it is recommended to create a **fluent.ts** file which configures your application. It is recommended to create an alias to your fluent\nfile for easier imports. This can be done in your **tsconfig.json** file:\n\n```ts\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // This must be specified if \"paths\" is.\n    \"paths\": {\n      \"fluent\": [\"src/fluent.ts\"] // This mapping is relative to \"baseUrl\"\n    }\n  }\n}\n```\n\nFrom now on when we point to `'fluent'` it is this file:\n\n```ts\nimport { IContext, IBranchContext, SequenceFactory, SequenceWithPropsFactory, ConnectFactory } from '@cerebral/fluent'\nimport { Provider as RouterProvider } from '@cerebral/router';\nimport { State, Signals } from './app/types'\n\n// Create an interface where you compose your providers together\ninterface Providers {\n  router: RouterProvider,\n  state: State\n}\n\n// Create a type used with your sequences and actions\nexport type Context<Props = {}> = IContext<Props> & Providers;\n\n// This type is used when you define actions that returns a path\nexport type BranchContext<Paths, Props = {}> = IBranchContext<Paths, Props> & Providers;\n\n// This function is used to connect components to Cerebral\nexport const connect = ConnectFactory<State, Signals>();\n\n// This function is used to define sequences\nexport const sequence = SequenceFactory<Context>();\n\n// This function is used to define sequences that expect to receive some initial\n// props\nexport const sequenceWithProps = SequenceWithPropsFactory<Context>();\n```\n\n## Creating a module with types\n\nYou will typically create a separate file for the types. This will hold the types for the state and signals of the given module.\n\n*src/app/types.ts*\n```ts\nimport { Dictionary, ComputedValue } from '@cerebral/fluent'\nimport * as signals from './sequences'\n\n// This is a shortcut where all exported sequences are\n// defined as signals\nexport type Signals = {\n  [key in keyof typeof signals]: typeof signals[key]\n};\n\n// Alternatively you would have to do this for each signal\nexport type Signals = {\n  doThis: typeof signals.doThis\n};\n\nexport type State = {\n  foo: string,\n  stringDictionary: Dictionary<string>,\n  isAwesome: ComputedValue<boolean>,\n  upperFoo: string\n};\n```\n\n## Creating the app module\n\n*src/app/index.ts*\n```ts\nimport { Module, Dictionary, Computed } from '@cerebral/fluent'\nimport Router from '@cerebral/router'\nimport * as a from './modules/a'\nimport * as b from './modules/b'\nimport * as signals from './sequences'\nimport * as computed from './computed'\nimport { State } from './types'\n\nconst state: State = {\n  // Just a normal state value\n  foo: 'bar',\n  // Dynamic objects, meaning you want to add/remove\n  // keys will need to be a Dictionary.\n  stringDictionary: Dictionary({}),\n  // Computed values receives both the module state and the\n  // root state. Normally you will use this for computational things like\n  // sorting, filtering etc. Where you want to avoid doing the calculation\n  // everytime the value is used. It is used like this: state.isAwesome.get()\n  isAwesome: Computed(computed.isAwesome),\n  // A getter allows you to make state values derived from other state\n  // values. There is no caching involved, but if used it will be observed for\n  // changes like normal values. It is used like this: state.upperFoo\n  get upperFoo () {\n    return this.foo.toUpperCase()\n}\n}\n\nexport const module = Module({\n  state,\n  signals,\n  modules: {\n    a: a.module,\n    b: b.module,\n    router: Router({...})\n  }\n})\n```\n\nBy defining your state in its own variable you will get easier to read error reporting from Typescript.\n\n\n## Scaling up to submodules\n\nThe module definition above has two custom submodules. When you have submodules you will need to compose in the complete state and signals. You do this in the **fluent** file like this:\n\n```ts\nimport { IContext, IBranchContext, SequenceFactory, SequenceWithPropsFactory, ConnectFactory } from '@cerebral/fluent'\nimport { Provider as RouterProvider } from '@cerebral/router';\nimport * as app from  './app/types'\nimport * as admin from './app/modules/admin/types'\nimport * as dashboard from './app/modules/dashboard/types'\n\ntype State = app.State & {\n  admin: admin.State,\n  dashboard: dashboard.State\n}\n\ntype Signals = app.Signals & {\n  admin: admin.Signals,\n  dashboard: dashboard.Signals\n}\n\ninterface Providers {\n  router: RouterProvider,\n  state: State\n}\n\nexport type Context<Props> = IContext<Props> & Providers;\n\nexport type BranchContext<Paths, Props> = IBranchContext<Paths, Props> & Providers;\n\nexport const connect = ConnectFactory<State, Signals>();\n\nexport const sequence = SequenceFactory<Context>();\n\nexport const sequenceWithProps = SequenceWithPropsFactory<Context>();\n```\n\nThe **fluent** file is where you describe your complete application with types.\n\n## Creating sequences\n\n```ts\n// remember this is alias to the fluent.ts file\nimport { sequence } from 'fluent'\n\nexport const changeFoo = sequence(s => s\n  .action(({ state }) => { state.foo = 'bar2' })\n)\n```\n\nThis sequence gives you full type safety and autosuggestions. If anything is changed you will be notified by Typescript if your sequence does not work. Though inlining actions like this works it is recommended to split them out. The reason is that your sequences will read better and you actions will be composable with other sequences by default. Like this:\n\n```ts\nimport { sequence } from 'fluent'\nimport * as actions from './actions'\n\nexport const changeFoo = sequence(s => s\n  .action(actions.changeFoo)\n)\n```\n\nYou can branch out to paths by using the **branch** method:\n\n```ts\nimport { sequence } from 'fluent'\n\nexport const submitUser = sequence(s => s\n  .action(actions.setSubmittingUser(true))\n  .branch(actions.submitNewUser)\n  .paths({\n    success: s => s\n      .action(actions.addNewUser),\n    error: s => s\n      .action(actions.showError)\n  })\n  .action(actions.setSubmittingUser(false))\n)\n```\n\nIf your sequence expects to have props available you can define that:\n\n```ts\nimport { sequenceWithProps } from 'fluent'\nimport * as actions from './actions'\n\nexport const changeFoo = sequenceWithProps<{ foo: string }>(s => s\n  .action(actions.changeFoo)\n)\n```\n\nYou can also define expected props to be produced through the sequence:\n\n```ts\nimport { sequence, sequenceWithProps } from 'fluent'\nimport * as actions from './actions'\n\nexport const doThis = sequence<{ foo: string }>(s => s\n  // This action must return { foo: 'some string' } for the\n  // sequence to be valid\n  .action(actions.doSomething)\n)\n\nexport const changeFoo = sequenceWithProps<{ foo: string }, { bar: number }>(s => s\n  // This action must return { bar: 123 } to give a valid sequence\n  .action(actions.changeFoo)\n)\n```\n\nAny sequences used as signals will require the signal to be called with the defined props, for example:\n\n```ts\nimport { sequence, sequenceWithProps } from 'fluent'\nimport * as actions from './actions'\n\nexport const doThis = sequenceWithProps<{ foo: string }>(s => s\n  .action(actions.doSomething)\n)\n```\n\nWhen you call the signal it will require you to call it with:\n\n```ts\nsignals.doThis({\n  foo: 'bar'\n})\n```\n\n## Creating actions\n\n```ts\nimport { Context, BranchContext } from 'fluent'\nimport { User } from './types'\n\n// Now you have made this function composable with any\n// other sequence, meaning that you can safely reuse it\n// wherever you want and instantly be notified if there is a mismatch,\n// for example that the action will indeed not receive the name property\n// by a previous action, sequence or calling the signal\n// Context<Props>\nexport function changeNewUserName ({ state, props }: Context<{ name: string }>) {\n  state.newUserName = props.name\n}\n\n// With the BranchContext type you ensure that this action has\n// the defined paths available in the sequence it is composed into\n// BranchContext<Paths, Props>\nexport function submitNewUser ({ state, http, path }: BranchContext<{\n  success: { user: User },\n  error: {}\n  }>) {\n  return http.post('/users', {\n    userName: state.newUserName\n  })\n    .then(response => path.success({ user: response.result }))\n    .catch(() => path.error({}))\n}\n```\n\nBoth **Context** and **BranchContext** as optional **Props**.\n\n## Connecting components\n\nThe **connect** factory you defined in the *fluent.ts* file is used to connect to components like this:\n\n```ts\nimport * as React from 'react'\nimport { connect } from 'fluent'\n\ntype ExternalProps {\n  foo: string\n}\n\nexport default connect<ExternalProps>()\n  .with(({ state, signals, props }) => ({\n    foo: state.foo,\n    onClick: signals.doThis\n  }))\n  .to(\n    function MyComponent ({ foo, onClick }) {\n      return <div></div>\n    }\n  )\n```\n\nThe **ExternalProps** are used when the component receives props from a parent. This is optional. It is important to take notice that the **with** method has to return the exact observable values you are using in your component. Meaning that:\n\n```ts\nimport * as React from 'react'\nimport { connect } from 'fluent'\n\nexport default connect()\n  .with(({ state }) => ({\n    user: state.user\n  }))\n  .to(\n    function UserName ({ user }) {\n      return <div>{user.name}</div>\n    }\n  )\n```\n\nwould actually not work. You would have to:\n\n```ts\nimport * as React from 'react'\nimport { connect } from 'fluent'\n\nexport default connect()\n  .with(({ state }) => ({\n    user: { name: state.user.name }\n  }))\n  .to(\n    function UserName ({ user }) {\n      return <div>{user.name}</div>\n    }\n  )\n```\n\nThis is because you have to grab (observe) the values being used in the component. This has the benfit of being explicit and allows for easy extending the connect to work with other view layers. You could also do:\n\n```ts\nimport * as React from 'react'\nimport { connect } from 'fluent'\n\nexport default connect()\n  .with(({ state }) => ({\n    user: { ...state.user }\n  }))\n  .to(\n    function UserName ({ user }) {\n      return <div>{user.name}</div>\n    }\n  )\n```\n\nAs this would indeed \"get\" all the properties on the user, starting to observe them.\n\nTo connect to a class:\n\n```ts\nimport * as React from 'react'\nimport { connect } from 'fluent'\n\nexport default connect()\n  .with(({ state }) => ({\n    user: { ...state.user }\n  }))\n  .toClass(props =>\n    class UserName extends React.Component<typeof props> {\n      render () {\n        return <div>{this.props.user.name}</div>\n      }\n    }\n  )\n```\n\nConnecting to a class gives a callback with the prop which you can **typeof** into the component class. This gives type safety and auto suggestions on the props in the component itself.\n\n## Dictionary\nTypically your state objects are used to define other specifc state, like:\n\n```ts\ntype State = {\n  settings: {\n    isAwesome: boolean,\n    hasBananas: boolean\n  }\n}\n\nconst state: State = {\n  settings: {\n    isAwesome: true,\n    hasBananas: false\n  }\n}\n```\n\nThe **settings** object will never have keys added or removed from it. But a state like:\n\n```ts\ntype User = {\n  name: string\n}\n\ntype State = {\n  users: { [id: string] : User}\n}\n\nconst state: State = {\n  users: {}\n}\n```\n\nWill dynamically have keys added and removed. That is where you have to use a **Dictionary**:\n\n```ts\nimport { Dictionary } from '@cerebral/fluent\n\ntype User = {\n  name: string\n}\n\ntype State = {\n  users: Dictionary<User>\n}\n\nconst state: State = {\n  users: Dictionary({})\n}\n```\n\nThe dictionary is an **ObservableMap** from Mobx. It has its own API surface:\n\n```ts\nfunction someAction ({ state }) {\n  const user = state.users.get('123')\n  state.users.set('123', { name: 'John ' })\n  state.users.delete('123')\n  state.users.clear()\n  state.users.merge({\n    '456': { name: 'Bob' },\n    '789': { name: 'Derek' }\n  })\n}\n```\n\nWhenever you have this dynamic nature, use a **Dictionary**. Typescript will of course give you hints about this when you point to it.\n\n## Computing values\n\nTypically you will just use a getter when you are deriving state:\n\n```ts\ntype State = {\n  foo: string,\n  upperFoo: string\n}\n\nconst state: State = {\n  foo: 'bar',\n  get upperFoo() {\n    return this.foo.toUpperCase()\n  }\n}\n```\n\nThere is really no computational power needed to do this. When you have more complex getters it is a good idea to move them into their own files:\n\n```ts\nimport * as getters from './getters'\n\ntype State = {\n  foo: string,\n  upperFoo: string\n}\n\nconst state: State = {\n  foo: 'bar',\n  get upperFoo() {\n    return getters.upperFoo(this)\n  }\n}\n```\n\nWhen you are doing more heavy calulations though it is nice to compute. So for example if we created a color based on the text of **foo**:\n\n```ts\nimport stringToColor from 'string-to-color'\nimport { ComputedValue } from '@cerebral/fluent\n\ntype State = {\n  foo: string,\n  fooColor: ComputedValue<string>\n}\n\nconst state: State = {\n  foo: 'bar',\n  fooColor: Computed((state) => {\n    return stringToColor(state.foo)\n  })\n}\n```\n\nThere is really no reason to recalculate the color everytime we grab **fooColor**, unless **foo** itself actually changed. This is where a computed helps. It caches the returned value until any of the depending state has changed.\n","title":"Typescript"}},"api":{"index":{"raw":"# Action\n\nWhen actions run they are passed a context. This context is created by Cerebral for every action run.\n\n```js\nfunction iAmAnAction (context) {}\n```\n\nThe context is populated by Cerebral and you can configure this by creating **providers**. By default Cerebral adds the following providers on the context.\n\n## Props\n\nWhen you trigger a signal you can pass it a payload. This payload is the starting point of the props to the signal. Given the signal:\n\n```js\n[\n  actionA,\n  actionB\n]\n```\n\n```js\nsomeSignal({\n  foo: 'bar'\n})\n```\n\nThe first action will receive the payload passed into the signal.\n\n```js\nfunction actionA ({ props }) {\n  props // {foo: \"bar\"}\n\n  return {\n    bar: 'baz'\n  }\n}\n```\n\nBy returning a new object the next action will see an extended payload:\n\n```js\nfunction actionB ({ props }) {\n  props // {foo: \"bar\", bar: \"baz\"}\n}\n```\n\nSo returning an object from actions, either directly or from a promise, extends the payload for later actions to handle.\n\n## State\nTo change the state of your application you use the state API. It is available to every action.\n\n```js\nfunction setSomething ({ state }) {\n  state.set('some.path.foo', 'bar')\n}\n```\n\nAll common state operations are available as a method. Instead of first pointing to a value and then operate, you operate first and give the path to the value.\n\n```js\n// Traditional approach\nsomeArray.push('newItem')\n// With Cerebral\nstate.push('path.to.array', 'newItem')\n```\n\nThis is the one core concept of Cerebral that gives all its power. This simple approach allows for a few important things:\n\n1. Track mutations in the application so that it can be passed to the debugger\n2. Track mutations so that it can inform components depending on the changes\n3. Only allow mutations through the API, and nowhere else in the application (using freezing during development)\n\n## Module\nThis is the same as **state**, though the path already points to the module running the signal. So you give a relative path.\n\n```js\nfunction setSomething ({ module }) {\n  // Already points to some.module\n  module.set('foo', 'bar')\n}\n```\n\n## Path\nThe path on the context is only available if there is actually expressed a path after the action in question:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport actionC from '../actions/actionC'\n\nexport default [\n  actionA,\n  actionB, {\n    foo: actionC\n  }\n]\n```\n\nIn this scenario only *actionB* has the path on its context. That means in any action you can check if path is available and what paths can be taken by looking at its keys.\n\n## Resolve\n**Tags** and **Compute** needs resolving. In most scenarios you do not have to think about this, but you might want to do this manually in an action. This is typically related to action factories. To resolve an argument passed to a factory you can use resolve:\n\n```js\nfunction someActionFactory(someArgument) {\n  function someAction ({ resolve }) {\n    // The argument can be anything, even plain values\n    const value = resolve.value(someArgument)\n  }\n\n  return someAction\n}\n```\n\nYou can also use resolve to check the value type and extract for example the path of tags:\n\n```js\nfunction someActionFactory(someArgument) {\n  function someAction ({ resolve }) {\n    if (resolve.isTag(someArgument)) {\n      const path = resolve.path(someArgument)\n    }\n  }\n\n  return someAction\n}\n```\n\n\n## Controller\nYou have access to the controller instance on the context:\n\n```js\nfunction someAction ({ controller }) {}\n```\n","title":"Action"},"compute":{"raw":"# Compute\nComputes calculate and cache derived state values. Using computes helps to keep logic out of the application view components, can improve performance and make applications easier to test.\n\n```js\nimport { Compute } from 'cerebral' // upperCase since version 4.0\nimport { state } from 'cerebral/tags'\n\nexport default Compute(\n  state`user.name`,\n  (name) => {\n    return `Hi ${name}`\n  }\n)\n```\n\nA compute takes any number and type of arguments, where each argument is passed to the next function argument (**compute function**). Tag and compute arguments will be resolved to a value when the compute executes, all other arguments are forwarded. The **compute functions** are called whenever the compute is executed, all preceding values (resolved or forwarded) will be passed with an additional **get** argument.\n\n```js\nimport { Compute } from 'cerebral'\nimport { state } from 'cerebral/tags'\nimport someOtherComputed from './someOtherComputed'\n\nexport default Compute(\n  state`user.name`,\n  'foo',\n  (name, foo) => {\n    return `Hi ${name}`\n  },\n  someOtherComputed,\n  (computedHello, someOtherComputedValue) => {\n    return `${computedHello} - ${someOtherComputedValue}`\n  }\n)\n```\n\nThat last argument of each function is **get**, it allows you to manually extract state and props.\n\n```js\nimport { Compute } from 'cerebral'\nimport { state, props } from 'cerebral/tags'\n\nexport default Compute(\n  state`user.id`,\n  (userId, get) => {\n    return get(state`projects.${userId}`).length > get(props`limit`)\n  }  \n)\n```\n","title":"Compute"},"controller":{"raw":"# Controller\n\n```js\nimport { Controller } from 'cerebral'\nimport app from './app' // The root module\n\n// Signature changed since version 4.0\nexport default Controller(app, {\n  // The devtools\n  devtools: null,\n  // Also logs error handling to console.\n  throwToConsole: true,\n  // A map of state changes to run before instantiation,\n  // where the key is the path and value is the state value\n  stateChanges: {}\n})\n```\n\n## Methods\n\n### getState\nReturns state from the state tree\n\n```js\nconst someState = controller.getState('some.state')\n```\n\n### getSignal\nReturns signal from Cerebral\n\n```js\nconst someSignal = controller.getSignal('some.signal')\n// Run signal\nsomeSignal({foo: 'bar'})\n```\n\n### getModel\nReturns the model (state tree) of Cerebral\n\n```js\nconst model = controller.getModel()\n```\n\n### flush\nFlushes out changes to UI based on recent state changes, can be forced\n\n```js\ncontroller.flush()\n```\n\n### runSignal\nAllows you to run an arbitrary function tree definition\n\n```js\ncontroller.runSignal('someSignal', [actionA, actionB], {foo: 'bar'})\n```\n\n### addModule\nAllows you to add modules to the controller after instantiation (lazy)\n\n```js\ncontroller.addModule('someModule', module)\n```\n\n### removeModule\nAllows you to remove modules from the controller\n\n```js\ncontroller.removeModule('someModule')\n```\n\n## Events\n\n### initialized:model\nTriggers when Cerebral model has initialized.\n\n```js\ncontroller.on('initialized:model', () => {})\n```\n\n### initialized\nTriggers when Cerebral controller has initialized.\n\n```js\ncontroller.on('initialized', () => {})\n```\n\n### flush\nTriggered whenever Cerebral flushes out changes to the UI. Passes a map of changes.\n\n```js\ncontroller.on('flush', (changes) => {})\n```\n\n### start\nTriggered whenever Cerebral starts a signal execution.\n\n```js\ncontroller.on('start', (execution, payload) => {})\n```\n\n### end\nTriggered whenever Cerebral ends a signal execution.\n\n```js\ncontroller.on('end', (execution, payload) => {})\n```\n\n### pathStart\nTriggered whenever Cerebral starts execution a path in a signal\n\n```js\ncontroller.on('pathStart', (execution, payload) => {})\n```\n\n### pathEnd\nTriggered whenever Cerebral ends execution a path in a signal\n\n```js\ncontroller.on('pathEnd', (execution, payload) => {})\n```\n\n### functionStart\nTriggered whenever Cerebral starts executing an action.\n\n```js\ncontroller.on('functionStart', (execution, functionDetails, payload) => {})\n```\n\n### functionEnd\nTriggered whenever Cerebral ends executing an action.\n\n```js\ncontroller.on('functionEnd', (execution, functionDetails, payload, result) => {})\n```\n\n### asyncFunction\nTriggered whenever Cerebral executed an async action.\n\n```js\ncontroller.on('asyncFunction', (execution, functionDetails, payload) => {})\n```\n\n### parallelStart\nTriggered whenever Cerebral executes actions in parallel.\n\n```js\ncontroller.on('parallelStart', (execution, payload, functionsToResolveCount) => {})\n```\n\n### parallelProgress\nTriggered whenever Cerebral executes actions in parallel.\n\n```js\ncontroller.on('parallelProgress', (execution, payload, functionsStillResolvingCount) => {})\n```\n\n### parallelEnd\nTriggered whenever Cerebral ends executing actions in parallel.\n\n```js\ncontroller.on('parallelEnd', (execution, payload, functionsExecutedCount) => {})\n```\n\n### remember\nTriggered whenever Cerebral travels back in time. Passes the timestamp it travelled to.\n\n```js\ncontroller.on('remember', (datetime) => {})\n```\n\n### mutation\n*since version 4.0*\nTriggered whenever Cerebral mutated the state\n\n```js\ncontroller.on('mutation', (mutation) => {})\n```\n","title":"Controller"},"devtools":{"raw":"# Devtools\nYou can pass some options to the devtools to balance the processing and memory footprint:\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\nimport app from './app'\n\nexport default Controller(app, {\n  devtools: process.env.NODE_ENV === 'production' ? null : Devtools({\n    // Connect to Electron debugger (external debugger). It will\n    // fall back to chrome extension if unable to connect\n    host: 'localhost:8585',\n\n    // By default devtools connects to \"ws://\". This option should be set to true\n    // when browser operates on https. Follow debugger instructions for\n    // further configuration\n    https: false,\n\n    // By default the devtools tries to reconnect\n    // to debugger when it can not be reached, but\n    // you can turn it off\n    reconnect: true,\n\n    // Time travel\n    storeMutations: true,\n\n    // Shows a warning when you have components with number of\n    // state dependencies or signals above the set number  \n    bigComponentsWarning: 5,\n\n    // Warnings when passing objects and arrays as props to child\n    // components. They should rather be connected directly\n    warnStateProps: true,\n\n    // In addition to these basic JavaScript types: Object, Array, String, Number\n    // and Boolean, types of File, FileList, Blob, ImageData and RegExp is allowed to be stored in state\n    // tree. You can add additional types if you know what you are doing :)\n    allowedTypes: [\n     Blob\n    ]\n  })\n})\n```\n\nTurning these options to false will free up memory and CPU. Typically this is not an issue at all, but if you work with data heavy applications it might make a difference.\n","title":"Devtools"},"error":{"raw":"# Error\n*since version 4.0*\nThe **CerebralError** allows you to create your own error types to be used to catch errors in your signals.\nThe **catch** handler defined on the module will propagate up to parent modules. That means if a nested module does not catch an error, one of the parent modules can catch it if configured to do so.\n\n```js\nimport { CerebralError } from 'cerebral'\n\nexport class MyError extends CerebralError {}\n```\n\nThe error is thrown like this:\n\n```js\nimport { MyError } from './errors'\n\nfunction someAction () {\n  throw new MyError('Some message', {\n    // any details\n  })\n}\n```\n\nAnd caught like this:\n\n```js\nimport { Module } from 'cerebral'\nimport { MyError } from './errors'\nimport * as sequences from './sequences'\n\nexport default Module({\n  signals: {\n    somethingHappened: sequences.doThis\n  },\n  catch: [\n    [MyError, sequences.handleError]\n  ]\n})\n```\n","title":"Error"},"module":{"raw":"# Module\n*since version 4.0*\n\nModules are the core building blocks of your application. This is where you define state, signals, submodules etc.\n\n# Module object\n\n```js\nimport { Module } from 'cerebral'\n\nexport default Module({\n  // Define module state, namespaced by module path\n  state: {},\n  // Define module signals, namespaced by module path\n  signals: {},\n  // Define submodules, namespaced by module path\n  modules: {},\n  // Add a global providers when module instantiates\n  providers: {},\n  // Add error catchers\n  catch: []\n})\n```\n\nYou add the root module to the controller:\n\n```js\nimport { Controller } from 'cerebral'\nimport app from './app'\n\nexport default Controller(app)\n```\n\n# Module function\nIt is also possible to define a module using a function.\n\n```js\nimport { Module } from 'cerebral'\n\nexport default Module((module) => {\n  module.name // Name of module\n  module.path // Full path to module\n  module.controller // The controller the module is attached to\n\n  return {\n    state: {},\n    signals: {},\n    modules: {},\n    providers: {},\n    catch: []\n  }\n})\n```\n\n\n# Module factory\nWith the use of a factory it is possible to make reusable modules.\n\n```js\nimport { Module } from 'cerebral'\n\nexport default (options) => {\n  return Module({\n    state: {\n      location: options.of\n    }\n  })\n}\n```\n\nYou then configure the module when you attach it:\n\n```js\nimport { Controller } from 'cerebral'\nimport Location from './modules/Location'\n\nconst controller = Controller({\n  modules: {\n    location1: Location({of: 'Europe'}),\n    location2: Location({of: 'Africa'})\n  }\n})\n```\n","title":"Module"},"operators":{"raw":"# Operators\nYou can call operators to create actions for you. These actions will help you change state and control the flow of execution.\n\nRead more about operators in the [Cerebral in depth - Operators](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_operators) article.\n\n## State operators\n\nThe methods for changing state within actions are also available as operators. All state operators support using **state**, **module** and **props** tags as values.\n\nAll operators are imported as members of the 'cerebral/operators' module. For example, this imports **state** and **set**:\n\n```js\nimport { set } from 'cerebral/operators'\nimport { state } from 'cerebral/tags'\n```\n\n### concat\n\nConcatenate a value to an array\n\n```js\nconcat(state`some.list`, ['foo', 'bar'])\n```\n\n### increment\n\nIncrement an integer value by another integer value into an array. The default increment is 1, and a negative value effectively does a decrement.\n\n```js\nincrement(state`some.integer`)\nincrement(state`some.integer`, -5)\nincrement(state`some.integer`, state`some.otherInteger`)\nincrement(state`some.integer`, props`some.otherInteger`)\n```\n\n### merge\n\nMerge objects into existing value. If no value exists, an empty object will be created. Merge supports using operator tags on key values:\n\n```js\nmerge(state`clients.$draft`, props`newDraft`, {\n  foo: 'bar',\n  bar: props`baz`\n})\n```\n\n### pop\n\nPop a value off an array (removes last element from array).\n\n```js\npop(state`some.list`)\n```\n\n### push\n\nPush value into an array (adds the element at the end of the array).\n\n```js\npush(state`some.list`, 'foo')\n```\n\n### set\n\nSet a target value in the state or props.\n\n```js\nset(state`foo.bar`, true),\nset(props`foo`, true)\n```\n\n### shift\n\nShift a value off an array (removes first element in array).\n\n```js\nshift(state`some.list`),\n```\n\n### splice\n\nSplice an array in place.\n\n```js\nsplice(state`some.list`, 0, 2)\n```\n\n### toggle\n\nToggle a boolean value.\n\n```js\ntoggle(state`user.$toolbar`)\n```\n\n### unset\n\nUnset key from object.\n\n```js\nunset(state`clients.all.${props`key`}`)\n```\n\n### unshift\n\nUnshift a value into an array (adds the element at the start of the array).\n\n```js\nunshift(state`some.list`, 'foo')\n```\n\n## Flow control operators\n\nThese operators help control the execution flow.\n\n### debounce\n\nHold action until the given amount of time in milliseconds has passed. If the\nsignal triggers again within this time frame, the previous signal goes down the\n\"discard\" path while the new signal holds for the given time. This is\ntypically used for typeahead functionality. For a debounce that is shared\nacross different signals, you can use `debounce.shared()` (see example below).\n\nPlease note that the `discard` path has to be present even if it is most often\nempty because debounce is a flow operator that routes the flow depending on\ntime and action trigger.\n\n```js\nimport { debounce } from 'cerebral/operators'\n\nexport default [\n  debounce(200), {\n    continue: [runThisAction],\n    discard: []\n  },\n]\n```\n\n`debounce.shared()` is typically used with factories, for example to show\nnotifications where a previous notification should be cancelled by a new one.\n\n```js\nimport { debounce, set, unset } from 'cerebral/operators'\nimport { state } from 'cerebral/tags'\n\nconst sharedDebounce = debounce.shared()\nfunction showNotificationFactory(message, ms) {\n  return [\n    set(state`notification`, message),\n    sharedDebounce(ms), {\n      continue: [unset(state`notification`)],\n      discard: []\n    }\n  ]\n}\n```\n\nNow when this notification factory is used in different signals, the call to\n`debounceShared` will share the same debounce execution state:\n\n```js\nimport showNotification from './showNotification'\n\nexport default [\n  // ... user log in, etc\n  ...showNotification('User logged in', 5000)\n]\n```\n\n### equals\n\nThis operator chooses a specific path based on the provided value.\n\n```js\nimport { equals } from 'cerebral/operators'\nimport { state } from 'cerebral/tags'\n\nexport default [\n  equals(state`user.role`), {\n    admin: [],\n    user: [],\n    otherwise: [] // When no match\n  }\n],\n```\n\n### wait\n\nWait for the given time in milliseconds and then continue chain.\n\n```js\nimport { wait } from 'cerebral/operators'\n\nexport default [\n  wait(200),\n  doSomethingAfterWaiting\n]\n```\n\nIf you need to wait while executing in parallel, you should use a `continue`\npath to isolate the actions to be run:\n\n```js\nimport { wait } from 'cerebral/operators'\nimport { parallel } from 'cerebral'\n\nexport default\n  someAction,\n  parallel('my parallel with wait', [\n    wait(200), {\n      continue: [doSomethingAfterWaiting]\n    },\n    otherActionInParallel\n  ])\n]\n```\n\n### when\n\nRun signal path depending on a truth value or function evaluation.\n\n```js\nimport { when } from 'cerebral/operators'\n\nexport default [\n  when(state`foo.isAwesome`), {\n    true: [],\n    false: []\n  },\n  // You can also pass your own function\n  when(state`foo.isAwesome`, (value) => value.length === 3 ), {\n    true: [],\n    false: []\n  }\n]\n```\n\nWhen used with a truth function, the `when` operator supports more then a single\n\"value\" argument. The truth function must come last.\n\n```js\nimport { when } from 'cerebral/operators'\nimport { props, state } from 'cerebral/tags'\n\nexport default [\n  when(state`clients.$draft.key`, props`key`,\n    (draftKey, updatedKey) => draftKey === updatedKey\n  ), {\n    true: [\n      // Another person edited client, reset form to new value\n      set(state`clients.$draft`, props`value`)\n    ],\n    false: []\n  }\n]\n```\n","title":"Operators"},"providers":{"raw":"# Providers\n*since version 4.0*\n\nA provider exposes functionality to your actions. Typically to run side effects. Each action has a unique context object where the providers are populated.\n\nThis provider is automatically wrapped by the debugger, where available.\n\n```js\nimport { Provider } from 'cerebral'\n\nexport default Provider({\n  greet() {\n    return 'hello'\n  }\n})\n```\n\n```js\nimport { Controller, Module } from 'cerebral'\nimport greeter from './providers/greeter'\n\nconst app = Module({\n  providers: { greeter }\n})\n\nexport default Controller(app)\n```\n\nYou also have access to the context inside your provider. This will allow you to leverage existing providers. The context is exposed as `this.context`. This keeps the API concise and under the hood we can do prototypal optimizations.\n\n\n```js\nimport { Provider } from 'cerebral'\n\nexport default Provider({\n  triggerSignalOnNativeEvent(event, signalPath) {\n    window.addEventListener(event, () => {\n      this.context.controller.getSignal(signalPath)()\n    })\n  }\n})\n```\n","title":"Providers"},"signal":{"raw":"# Signal\n\nSignals are just sequences which are expressed as arrays:\n\n```js\nexport const mySequence = []\n```\n\nYou populate these arrays with actions:\n\n```js\nexport const mySequence = [\n  actions.someAction\n]\n```\n\nYou can attach sequences to signal definitions in the modules:\n\n```js\nimport { Module } from 'cerebral'\nimport * as sequences from './sequences'\n\nexport default Module({\n  signals: {\n    somethingHappened: sequences.doSomething\n  }\n})\n```\n\n## Async\nBy default signals run completely synchronous, but an action might run asynchronously thus making the signal async. When an action returns a promise it means it runs async.\n\n```js\nexport function myAction () {\n  return Promise.resolve()\n}\n```\n\nYou could also use an **async** function:\n\n```js\nexport async function myAction () {\n  return { foo: 'bar' }\n}\n```\n\n## Sequence\nSimple format of a sequence is to use an array literal, as explained above. Actions are run one after the other. If the action returns a promise Cerebral will wait until it resolves before moving to the next action:\n\n```js\nimport * as actions from '../actions'\n\nexport const mySequence = [\n  actions.someAction\n]\n```\n\nThe array is converted to a sequence, but you can also be explicit about it:\n```js\nimport { sequence } from 'cerebral'\nimport * as actions from '../actions'\n\nexport const mySequence = sequence([\n  actions.someAction\n])\n```\n\nYou can name a sequence, which will be displayed in debugger:\n```js\nimport { sequence } from 'cerebral'\nimport * as actions from '../actions'\n\nexport const mySequence = sequence('my sequence', [\n  actions.someAction\n])\n```\n\nYou can compose a sequence into existing sequence. The debugger will show this composition:\n```js\nimport someAction from '../actions/someAction'\nimport * as actions from '../actions'\n\nexport const myOtherSequence = [\n  actions.doThis\n]\n\nexport const mySequence = [\n  actions.someAction,\n  myOtherSequence\n]\n```\n\n## Parallel\nCerebral can not truly run actions in parallel (JavaScript is single threaded), but it can trigger multiple asynchronous actions at the same time, just like **Promise.all**. That means when Cerebral triggers actions defined within a parallel, it will not wait if a promise is returned, it will just move on to the next action. When all actions within a parallel is resolved it will move to the action after the parallel definition, if any:\n\n```js\nimport { parallel } from 'cerebral'\nimport * as actions from './actions'\n\nexport const mySequence = parallel([\n  actions.someAsyncAction,\n  actions.someOtherAsyncAction\n])\n```\n\nYou can name a parallel, which will be displayed in debugger:\n```js\nimport { parallel } from 'cerebral'\nimport * as actions from './actions'\n\nexport const mySequence = parallel('my parallel', [\n  actions.someAsyncAction,\n  actions.someOtherAsyncAction\n])\n```\n\nYou can compose parallel into any existing sequence:\n```js\nimport { parallel } from 'cerebral'\nimport * as actions from './actions'\n\nexport const mySequence = [\n  actions.someAction,\n  parallel('my parallel', [\n    actions.someAsyncAction,\n    actions.someOtherAsyncAction\n  ])\n]\n```\n\n## Paths\nYou can diverge execution by defining paths in your signal.\n\n```js\nimport * as actions from './actions'\n\nexport const mySequence = [\n  actions.getItems, {\n    success: [],\n    error: []\n  }\n]\n```\n\nThe action returned by **getItems** will now have access to a success and an error path and can call those based on the result of the http request.\n\nYou can define any path to execute:\n\n```js\nimport * as actions from './actions'\n\nexport const mySequence = [\n  actions.myAction, {\n    foo: [],\n    bar: [],\n    bananas: [],\n    apples: []\n  }\n]\n```\n\nWhen these paths are defined you will have access to corresponding paths in the action preceding the paths:\n\n```js\nfunction myAction ({ path }) {\n  path.foo\n  path.bar\n  path.bananas\n  path.apples\n}\n```\n\nTo actually diverge down the path you have to call it and return it from the action:\n\n```js\nfunction myAction ({ path }) {\n  return path.foo()\n}\n```\n\nOptionally pass a payload:\n\n```js\nfunction myAction ({ path }) {\n  return path.bananas({ foo: 'bar' })\n}\n```\n\nWith promises you just return it the same way:\n\n```js\nfunction myAction ({ someProvider, path }) {\n  return someProvider.doAsync()\n    .then((result) => path.bananas({ data: result.data }))\n}\n```\n","title":"Signal"},"state":{"raw":"# State\n\n## Get state\nThe only way to get state in your application is by connecting it to a component or grabbing it in an action.\n\n```js\nfunction someAction({ state, module }) {\n  // Get all state\n  const allState = state.get()\n  // Get by path\n  const stateAtSomePath = state.get('some.path')\n  // Get from module running this signal\n  const moduleState = module.get('isLoading')\n}\n```\n\n\n## Updating state\nThe only way to update the state of your application is in an action. Here is a list of all possible state mutations you can do:\n\n```js\nfunction someAction({ state, module }) {\n  // Concats passed array to existing array\n  state.concat('some.path', ['someValueA', 'someValueB'])\n  // Increment value at given path (default increment is 1)\n  state.increment('some.path', 1)\n  // Merge the keys and their values into existing object. Handled as a\n  // change on all paths merged in\n  state.merge('some.path', {\n    some: 'value'\n  })\n  // Removes last item in array\n  state.pop('some.path')\n  // Pushes a value to the end of the array\n  state.push('some.path', 'someValue')\n  // Set or replace a value\n  state.set('some.path', 'someValue')\n  // Removes first item in array\n  state.shift('some.path')\n  // Splices arrays\n  state.splice('some.path', 2, 1)\n  // Toggle a boolean value\n  state.toggle('some.path')\n  // Unset a key and its value\n  state.unset('some.path')\n  // Puts the value at the beginning of the array\n  state.unshift('some.path', 'someValue')\n\n  // Module has the same API surface, though the path is relative\n  // to the module path running this action\n  module.set('foo', 'bar')\n}\n```\n\n**NOTE!** You should not extract state and change it directly in your actions or components. This will not be tracked by Cerebral. That means a render will not be triggered and the debugger will not know about it. Treat your state as if it was immutable and only change it using the **state API**.\n\n## Special values support\nWhen building an application you often need to keep things like files and blobs in your state for further processing. Cerebral supports these kinds of values because they will never change, or changing them can be used with existing state API. This is the list of supported types:\n\n- **File**\n- **FilesList**\n- **Blob**\n- **ImageData**\n- **RegExp**\n\nIf you want to force Cerebral to support other types as well, you can do that with a devtools option. This is perfectly okay, but remember all state changes has to be done through the state API.\n","title":"State"},"tags":{"raw":"# Tags\nTags allow you to reference things in Cerebral. They are based on [template literal tags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals). They can be used by **operators**, **connect** and **compute**. Some of them can also be used with other Cerebral modules. The great thing about tags is their composability. For example:\n\n```js\nimport { state, props } from 'cerebral/tags'\n\nstate`items.${state`currentItemKey`}`\n\nstate`items.${props`itemKey`}`\n```\n\n- **state** - Used in signals and connect to target state\n- **module** - Used in signals to target state of the module running the signal\n- **props** - Used in signals to target payload and in connect to target component props\n- **signal** - Used in signals and connect to target a signal\n- **signals** - Used in connect to target all the signals of the specified module\n- **string** - Used in signals to evaluate a composed string\n\n## Compatibility\n\n- **operators**: state, module, props, signal and string\n- **connect**: state, props, signal and signals\n- **compute**: state and props\n","title":"Tags"},"test":{"raw":"# Test\n\n## Snapshot testing (beta)\n\nSnapshot testing requires your application to be written in Cerebral version 4 or up. All the providers you use needs to be defined using the `Provider` API, or you will have to mock out things yourself.\n\n### Introduction\n\n**1. Run the signal**\n\nOpen up your app and run the signal you want to test.\n\n**2. Create test in debugger**\n\nIn the debugger there is a button in the signal list called \"Create signal test\". Select the signal you just triggered and click this button. The test is copied to the clipboard.\n\n**3. Run test**\n\nIt is recommended to use [JEST](https://facebook.github.io/jest/). Just paste what you have in your clipboard and it will look something like this.\n\n```js\ntest('should filter on all', () => {\n  return Snapshot(app) // app is the root module\n    .run('filterClicked', { filter: 'all' })\n    .then(snapshot => {\n      expect(snapshot.get()).toMatchSnapshot()\n    })\n})\n```\n\nRun the test to create the first snapshot. Any changes to your app that affects this signal will be yelled at you by Jest.\n\n### Snapshot\n\nCreates the test and returns a promise. Pass it the root module of your application.\n\n```js\nSnapshot(app)\n```\n\n### run\n\nRuns a signal with an optional payload. It returns a promise, passing the snapshot.\n\n```js\nSnapshot(app).run('some.signal', { foo: 'bar' }).then(snapshot => {})\n```\n\n### mutate\n\nRuns a mutation in the state store before the signal runs.\n\n```js\nSnapshot(app).mutate('set', 'some.state.path', 'someValue')\n```\n\n### mock\n\nMocks out a provider that will be called in the signal. Can give an optional return value. If provider is called multiple times, you will need multiple calls to mock.\n\n```js\nSnapshot(app).mock('someProvider.someMethod', 'someReturnedValue')\n```\n\n### mockResolvedPromise\n\nMocks out a provider with a returned promise that resolves with an optional value.\n\n```js\nSnapshot(app).mockResolvedPromise('someProvider.someMethod', 'someReturnedValue')\n```\n\n### mockRejectedPromise\n\nMocks out a provider with a returned promise that rejects with an optional value.\n\n```js\nSnapshot(app).mockRejectedPromise('someProvider.someMethod', 'someReturnedValue')\n```\n\n## Assertion\n\n### Components\nThe **Container** you use to expose Cerebral to your components can also be used when testing. This is beneficial if you want to test\na section of your UI interacts correctly with the controller.\n\n```js\nimport React from 'react'\nimport { mount } from 'enzyme'\nimport assert from 'assert'\nimport { Container } from '@cerebral/react'\nimport { Controller, Module } from 'cerebral'\n\nimport Button from './Button'\n\ndescribe('<Button />', () => {\n  it('should pass foo state on click', () => {\n    const testModule = Module({\n      state: {\n        foo: 'bar'\n      },\n      signals: {\n        clicked: ({ props }) => assert.equal(props.foo, 'bar')\n      }  \n    })\n    const controller = Controller(app)\n    const wrapper = mount(\n      <Container controller={controller}>\n        <Button />\n      </Container>\n    )\n    expect(wrapper.find('.foo')).to.have.length(1)\n  })\n})\n```\n\n### Computes\n\nThe `runCompute` test helper accepts the `compute` and `fixture` arguments and returns the compute output.\n\n```js\nimport { props, state } from 'cerebral/tags'\nimport { runCompute } from 'cerebral/test'\n\nimport multiply from './multiply'\n\nit('should multiply by the specified number', () => {\n  const result = runCompute(multiply, {\n    state: { number: 5 },\n    props: { multiplyBy: 2 }\n  })\n\n  assert.equal(result, 10)\n})\n```\n\n### Actions\n\nThe `runAction` test helper accepts the `action` and `fixture` arguments and returns a promise.\n\n```js\nimport {state} from 'cerebral/tags'\nimport {runAction} from 'cerebral/test'\n\nimport increment from './increment'\n\nit('should increment numbers in state', () => {\n  return runAction(increment, { state: { number: 1 } })\n    .then(({state}) => assert.equal(state.number, 2))\n})\n```\n\nThe `result` object passed when the promise resolves contains `state`, `controller`, `props` and `output` properties.\n\n```js\n{\n  state,\n  controller,\n  props: {\n    // props data received by action\n  },\n  output: {\n    // action output data\n  }\n}\n```\n\n### Signals\n\nThe `CerebralTest` factory returns `runSignal`, `setState` and `getState` functions as well as the controller.\n\n```js\nimport { CerebralTest } from 'cerebral/test'\nimport math from './math'\n\nit('should accumulate a count', () => {\n  const cerebral = CerebralTest(math) // Expects a Module\n\n  cerebral.setState('count', 0)\n\n  return cerebral.runSignal('plusOne')\n    .then(({ state }) => {\n      assert.equal(state.count, 1)\n\n      return cerebral.runSignal('plus', { value: 2 })\n        .then(() => {\n          assert.equal(cerebral.getState('count'), 3)\n        })\n  })\n})\n```\n\nNote that state initialized in a module takes precedence over the state property of a fixture. Example:\n\n```js\nconst fixture = {\n  // Override default state in modules\n  state: {\n    app: {    \n      showNavigation: true    \n    }\n  },\n  modules: {\n    app\n  }\n}\n```\n\n#### Options\nThe optional `options` argument contain the the following options:\n\n`recordActions: true|false|'byName'`\n\n```js\nimport { CerebralTest } from 'cerebral/test'\nimport math from './math'\n\nit('should accumulate a count', () => {\n  const cerebral = CerebralTest(math, {\n    recordActions: 'byName'\n  })\n\n  cerebral.setState('count', 0)\n\n  return cerebral.runSignal('plusOne', {\n    incrementBy: 1\n  })\n    .then(({ increment }) => {\n      assert.equal(increment.props.incrementBy, 1)\n  })\n})\n```\n\nWhen `recordActions: true` is specified each action will record its props/output against its index within the signal action chain. When `recordActions: 'byName'` is specified each action will record its output against an named property in the result.\n\nThe `result` object passed when the promise resolves contains `state`, `controller` and an object for each named action in the signal chain with the same name as the actions with `props` and `output` properties.\n","title":"Test"},"universalcontroller":{"raw":"# Universal Controller\nThe Universal Controller allows you to put your application in its initial state on the server. In combination with your chosen view layer you can now render the application on the server and show it near instantly in the context of the current user. When the client side application loads it will piggyback on the existing DOM and effectively rehydrate the minimal state from the server to make it up to date, meaning that the pure HTML responded from your server and the loading of the actual application is transparent.\n\nRead more about server side rendering in the [Cerebral in depth - SSR](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_ssr) article.\n\n**Note** that when using JSX syntax it is wise to also transpile your server side code, which this example shows.\n\n```js\nimport { UniversalController } from 'cerebral'\nimport app from './app'\n\nconst controller = UniversalController(app)\n```\n\n## Methods\n### runSequence\nIf you need to update the state of the controller you can run a signal execution for doing so:\n\n```js\nimport { UniversalController } from 'cerebral'\nimport app from './app'\n\nconst controller = UniversalController(app)\n\ncontroller.runSequence([\n  function myAction ({ state, props }) {\n    state.set('app.isAwesome', props.isAwesome)\n  }\n], {\n  isAwesome: true\n})\n  .then(() => {\n    // I am done running\n  })\n```\n\nYou can run a predefined signal, which is defined inside a controller module as well:\n```js\nimport { UniversalController } from 'cerebral'\nimport app from './app'\n\nconst controller = UniversalController(app)\n\ncontroller\n  .runSequence('app.aSignal', {isAwesome: true})\n  .then(() => {\n    // I am done running\n  })\n```\n\n**NOTE!** You should instantiate the controller for each run you want to do.\n\n### setState\nFinally, you can (synchronously) set a value inside the state directly, using a path:\n\n```js\nimport { UniversalController } from 'cerebral'\nimport app from './app'\n\nconst controller = UniversalController(app)\n\ncontroller.setState('app.foo', 123)\n```\n\n### getChanges\nReturns a map of the changes made.\n\n```js\nimport { UniversalController } from 'cerebral'\nimport app from './app'\n\nconst controller = UniversalController(app)\n\ncontroller\n  .runSequence('app.aSignal', {isAwesome: true})\n  .then(() => {\n    controller.getChanges() // {\"app.isAwesome\": true}\n  })\n```\n\n### getScript\nWhen the client side application loads it will do its first render with the default state, meaning that if the server updated the state this is now out of sync. Using the **getScript** method you will get a script tag you can inject into the *HEAD* of the returned HTML. Cerebral will use this to bring your client side application state up to date with the server.\n\n```js\nimport { UniversalController } from 'cerebral'\nimport app from './app'\nimport fs from 'fs'\n\n/*\n  <!DOCTYPE html>\n  <html>\n    <head>\n      {{CEREBRAL_SCRIPT}}\n    </head>\n    <body>\n      <div id=\"app\">{{APP}}</div>\n    </body>\n  </html>\n*/\nconst indexTemplate = fs.readFileSync('index.template.html').toString()\n\nconst controller = UniversalController(app)\n\ncontroller.run([\n  function myAction ({ state, props }) {\n    state.set('app.isAwesome', props.isAwesome)\n  }\n], {\n  isAwesome: true\n})\n  .then(() => {\n    const index = indexTemplate\n      .replace('{{CEREBRAL_SCRIPT}}', controller.getScript())\n  })\n```\n\n## Render\nDepending on the view layer of your choice you can bring all of this together:\n\n```js\nimport React from 'react'\nimport express from 'express'\nimport fs from 'fs'\nimport { renderToString } from 'react-dom/server'\nimport { UniversalController } from 'cerebral'\nimport { Container } from 'cerebral/react'\nimport app from '../client/app'\nimport App from '../client/components/App'\nimport loadApp from './loadApp'\n\nconst server = express()\nconst indexTemplate = fs.readFileSync('index.template.html').toString()\n\nserver.get('/', (req, res) => {\n  const controller = UniversalController(app)\n\n  controller.run(loadApp, {\n      query: req.query,\n      useragent: req.headers['user-agent']\n    })\n      .then(() => {\n        const index = indexTemplate\n          .replace('{{CEREBRAL_SCRIPT}}', controller.getScript())\n          .replace('{{APP}}', renderToString(\n            <Container controller={controller}><App /></Container>\n          ))\n\n        res.send(index)\n      })\n})\n\nserver.listen(3000)\n```\n\n## ES6 on server\nTake a look at the [demo application](https://github.com/cerebral/cerebral/tree/master/demos/universal) to see how you can run modern javascript, also with JSX, on the server. Demo does not include building for production, but you would typically use Webpack as normal for the client and just babel for the server. Or you can use Webpack there as well. If you are not using JSX you will probably get away with no transpiling on the server.\n","title":"Universal Controller"}},"views":{"index":{"raw":"# @cerebral/angular\n\n[Angular](https://angular.io/) view for Cerebral.\n\n## Install\n\n`npm install @cerebral/angular @angular/core @angular/platform-browser babel-plugin-transform-decorators-legacy`\n\n## CerebralService\nThe Cerebral service exposes the Cerebral controller to your application.\n\n```ts\nimport { NgModule } from '@angular/core'\nimport { BrowserModule } from '@angular/platform-browser'\n\nimport { provide } from 'cerebral'\nimport { ControllerService } from '@cerebral/angular'\n\nimport { AppComponent }  from './app.component.ts'\nimport { SomeAngularService } from './SomeAngularService'\n\n// Create a factory to instantiate Cerebral. It can receive\n// dependencies which you can \"provide\" to Cerebral to be used\n// within signals\nexport function configureController(someAngularService : SomeAngularService) {\n  return new ControllerService({\n    // We use the \"provide\" function to an angular service to the signals\n    // of Cerebral\n    providers: [\n      provide('someAngularService', someAngularService)\n    ]\n  })\n})\n\n@NgModule({\n  imports:      [ BrowserModule ],\n  declarations: [ AppComponent ],\n  bootstrap:    [ AppComponent ],\n  providers: [\n     {\n      provide: ControllerService,\n      useFactory: configureController,\n      deps: [SomeAngularService]\n    },\n  ]\n})\nexport class AppModule {}\n```\n\n## connect decorator\nThe connect decorator connects state and signals to your components.\n\n```ts\nimport { Component, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core'\nimport { signal, state } from 'cerebral/tags'\nimport { connect, ControllerService, CerebralComponent } from '@cerebral/angular'\n\n@Component({\n  selector: 'app-component',\n  template: `\n    <div (click)=\"onClick()\">{{foo}}</div>\n  `,\n  // Change detection needs to be set to \"OnPush\"\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\n@connect({\n  // For AOT to work you will have to use the array version of template\n  // tags\n  myName: state(['foo']),\n  onClick: signal(['clicked'])\n})\nexport class AppComponent extends CerebralComponent {\n  // You have to inject \"ChangeDetectionRef\" and \"ControllerService\" and pass\n  // them to parent for connect to do its work\n  constructor(cdr: ChangeDetectorRef, controller: ControllerService) {\n    super(cdr, controller)\n    controller.getSignal('onClick')()\n  }\n}\n```\n","title":"@cerebral/angular"},"angularjs":{"raw":"# @cerebral/angularjs\n\n[Angularjs](https://angularjs.org) view for Cerebral.\n\n## Install\n\n`npm install @cerebral/angularjs angular`\n\n## Config\n```js\nimport angular from 'angular'\nimport {addModule, connect} from '@cerebral/angularjs'\nimport {Controller} from 'cerebral'\nimport {state, signal} from 'cerebral/tags'\n\naddModule(angular)\n\nconst rootModule = Module({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  },\n  services: ['MyAngularService']  // Root module only. Added as providers with same name\n})\n\nconst controller = Controller()\n\nangular.module('app', ['cerebral'])\n  .config(function (cerebralProvider) {\n    cerebralProvider.configure(controller)\n  })\n  ...\n```\n\n## connect\n```js\nimport angular from 'angular'\nimport {addModule, connect} from '@cerebral/angularjs'\nimport {state, signal} from 'cerebral/tags'\n\nangular.module('app', ['cerebral'])\n  .config(...)\n  .component('myComponent', {\n    template: '<div ng-click=\"$ctrl.click()\">{{$ctrl.foo}}</div>',\n    controller: connect({\n      foo: state`foo`,\n      click: signal`clicked`\n    }, 'MyComponent', ['cerebral', function MyController (cerebral) {\n\n      // In some cases you might need access to cerebral's controller.\n      // You can inject the cerebral angular service and\n      // access it's controller property anywhere in your app\n      cerebral.controller.getSignal('mySignal')()\n\n      // Optionally add custom behaviour to controller\n    }])\n  })\n```\n\nSince angular doesn't expose the component name,\nyou will need to provide one to `connect` for the\ncomponent to be given a name in cerebral.\n\nYou can call connect in the following ways:\n```js\nconnect(dependencies)\nconnect(dependencies, name)\nconnect(dependencies, controller)\nconnect(dependencies, name, controller)\n```\n","title":"@cerebral/angularjs"},"inferno":{"raw":"# @cerebral/inferno\n\n[Inferno](http://infernojs.org) view for Cerebral.\n\n## Install\n\n`npm install @cerebral/inferno inferno babel-plugin-inferno`\n\n## Container\n```js\nimport { render } from 'inferno'\nimport {Controller} from 'cerebral'\nimport {Container} from '@cerebral/inferno'\nimport App from './App'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n## connect\n```js\nimport { Component } from 'inferno'\nimport {connect} from '@cerebral/inferno'\nimport {state, signal} from 'cerebral/tags'\n\n// Stateless\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  function MyComponent ({foo, click}) {\n    return <div onClick={() => click()}>{foo}</div>\n  }\n)\n\n// Stateful\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  class MyComponent extends Component {\n    render () {\n      return <div onClick={() => this.props.click()}>{this.props.foo}</div>\n    }\n  }\n)\n```\n","title":"@cerebral/inferno"},"preact":{"raw":"# @cerebral/preact\n\n[Preact](https://github.com/developit/preact) view for Cerebral.\n\n## Install\n`npm install @cerebral/preact preact babel-preset-preact`\n\n## Container\n```js\nimport {h, render} from 'preact'\nimport {Controller} from 'cerebral'\nimport {Container} from '@cerebral/preact'\nimport App from './App'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n## connect\n```js\nimport {h, Component} from 'preact'\nimport {connect} from '@cerebral/preact'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  class MyComponent extends Component {\n    render ({foo, click}) {\n      return <div onClick={() => click()}>{foo}</div>\n    }\n  }\n)\n```\n","title":"@cerebral/preact"},"react":{"raw":"# @cerebral/react\n\n[React](https://facebook.github.io/react) view for Cerebral.\n\n## Install\n`npm install @cerebral/react react react-dom babel-preset-react`\n\n## Container\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Controller} from 'cerebral'\nimport {Container} from '@cerebral/react'\nimport App from './App'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n## connect\nTypically you add a stateless component:\n\n```js\nimport React from 'react'\nimport {state, signal} from 'cerebral/tags'\nimport {connect} from '@cerebral/react'\n\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  function MyComponent ({foo, click}) {\n    return <div onClick={() => click()}>{foo}</div>\n  }\n)\n```\n\nBut you can also use stateful components:\n```js\nimport React from 'react'\nimport {state, signal} from 'cerebral/tags'\nimport {connect} from '@cerebral/react'\n\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  class MyComponent extends React.Component {\n    render () {\n      return <div onClick={() => this.props.click()}>{this.props.foo}</div>\n    }\n  }\n)\n```\n\nYou can add an additional function to connect that gives you full control of properties of the component and dependencies. The returned object from this function will be the exact props passed into the component.\n\n```js\nimport React from 'react'\nimport {signal, state} from 'cerebral/tags'\nimport {connect} from '@cerebral/react'\n\nexport default connect({\n  foo: state`app.foo`,\n  clicked: signal`app.somethingClicked`\n}, (dependencyProps, ownProps, resolve) => {\n  // we can resolve values or path here. Note: it's not tracked as dependency\n  const path = resolve.path(state`entities.foo.{ownProps}`)\n\n  return {\n    // values from state could be transformed here\n    foo: `Label: ${foo}`,                       \n    // signals calls could be bound here, so component uses it as general callback            \n    onClick: (e) => clicked({ id: ownProps.id })\n  }\n},\n  function App({foo, onClick}) {\n    return <div onClick={onClick}>{foo}</div>\n  }\n)\n```\n\n- **dependencyProps** are the props you connected.\n\n- **ownProps** are the props passed into the component by the parent.\n\n- **resolve** allows you to resolve computed etc., just like resolve in actions.\n\n## TypeScript\n\nIf you use TypeScript, you can type your component props with connect:\n\n```ts\nimport React from 'react'\nimport {state, signal} from 'cerebral/tags'\nimport {connect} from '@cerebral/react'\n\n// connected props\ninterface Props {\n  click (): void\n  foo: string\n}\n\n// component props such as <MyComponent name='foobar' />\ninterface EProps {\n  name: string\n}\n\n// Stateless\nexport default connect<Props, EProps>({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  // TypeScript now knows about foo and click props\n  function MyComponent ({foo, click}) {\n    return <div onClick={() => click()}>{foo}</div>\n  }\n)\n\n// Stateful\nexport default connect<Props, EProps>({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  class MyComponent extends React.Component<Props, EProps> {\n    render () {\n      return <div onClick={() => this.props.click()}>{this.props.foo}</div>\n    }\n  }\n)\n```\n","title":"@cerebral/react"},"vue":{"raw":"# @cerebral/vue\n\n[Vue.js](https://vuejs.org) view for Cerebral.\n\n## Install\n`npm install @cerebral/vue vue`\n\n## Container\n```js\nimport Vue from 'vue/dist/vue'\nimport {Controller} from 'cerebral'\nimport {Container, connect} from '@cerebral/vue'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\n var app = new Vue({\n  el: '#app',\n  components: {\n    container: Container(controller)\n  }\n})\n```\n\n**Note!** The HTML of the root element must use the *container*:\n\n```html\n<div id=\"app\">\n  <container>\n    <my-component></my-component>\n  </container>\n</div>\n```\n\n## connect\n*MyComponent.js*\n```js\nimport {connect} from '@cerebral/vue'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n}, {\n  template: '<div v-on:click=\"click()\">{{foo}}</div>'\n})\n```\n\n*main.js*\n```js\nimport Vue from 'vue/dist/vue'\nimport {Controller} from 'cerebral'\nimport {Container, connect} from '@cerebral/vue'\nimport MyComponent from './MyComponent'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\n var app = new Vue({\n  el: '#app',\n  components: {\n    container: Container(controller),\n    'my-component': MyComponent\n  }\n})\n```\n","title":"@cerebral/vue"}},"addons":{"index":{"raw":"# function-tree\n\n## Install\n**NPM**\n\n`npm install function-tree`\n\n## Description\nFunction-tree is the what Cerebral extends to create its signal implementation. You can use this library on the server, or standalone in the client as a replacement for Cerebral. Basically a function-tree allows you to execute a tree of functions. You can use the Cerebral debugger to debug function tree execution in any JS environment.\n\nFunction-tree is somewhat in the same family as Rxjs and Promises. The main difference is that Rxjs and Promises  are based on value transformation. That means only the value returned from the previous function is available in the next. This works when you indeed want to transform values, but events in your application are rarely about value transformation, they are about running side effects and going through one of multiple execution paths. Function tree embraces the fact that most of what we do in application development is running side effects.\n\nRxjs and Promises are also about execution control, but neither of them have declarative conditional execution paths, you have to write an *IF* or *SWITCH* statement or decouple streams. With function tree you are able to diverge the execution down paths just as declaratively as functions. This helps readability.\n\n## Instantiate\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nconst ft = new FunctionTree({\n  // add side effect libraries to context\n})\n\nft.run([\n// returns a promise\n  function someFunc (context) {},\n  function someOtherFunc (context) {}\n], {\n  foo: 'bar' // optional payload\n})\n.catch((error) => {\n  // Current payload with execution details,\n  // can be passed in to a new execution (will be indicated in debugger)\n  error.payload\n\n  // A serialized version of the error. Name, message and stack, or custom error serialization\n  error.payload.error\n})\n```\n\nYou can also add multiple custom context providers by using an array:\n\n```js\nconst ft = new FunctionTree({\n  // add side effect libraries to context\n  uuid,\n  axios\n})\n```\n\n## errors\n\n### FunctionTreeError (base)\n```js\nimport {FunctionTreeError} from 'function-tree'\n// Node:\n// const FunctionTreeError = require('function-tree').FunctionTreeError\n\n// Error structure\n{\n  name: 'FunctionTreeError',\n  message: 'Some function-tree error'\n  stack: '...'  \n}\n```\n\n### FunctionTreeExecutionError\n```js\nimport {FunctionTreeExecutionError} from 'function-tree'\n// Node:\n// const FunctionTreeExecutionError = require('function-tree').FunctionTreeExecutionError\n\n// Error structure\n{\n  name: 'FunctionTreeExecutionError',\n  message: 'Some execution error'\n  execution: {name: 'someName'},\n  funcDetails: {name: 'someFunction', functionIndex: 5},\n  payload: {foo: 'bar'},\n  stack: '...'  \n}\n```\n\n## devtools\nDownload the function tree standalone debugger for [Mac](https://drive.google.com/file/d/0B1pYKovu9Upyb1Bkdm5IbkdBN3c/view?usp=sharing), [Windows](https://drive.google.com/file/d/0B1pYKovu9UpyMGRRbG45dWR6R1k/view?usp=sharing) or [Linux](https://drive.google.com/file/d/0B1pYKovu9UpyMFQ5dEdnSy1aN0E/view?usp=sharing).\n\n```js\nimport FunctionTree from 'function-tree'\nimport Devtools from 'function-tree/devtools'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n// const Devtools = require('function-tree/devtools').Devtools\n\nconst devtools = new Devtools({\n  // Set url of remote debugger\n  host: 'localhost:8585',\n\n  // By default debugger tries to reconnect when it is not active\n  reconnect: true,\n\n  // By default devtools connects to \"ws://\". This option should be set to true\n  // when browser operates on https. Follow debugger instructions for\n  // further configuration\n  https: false\n})\nconst ft = new FunctionTree([])\n\n// Add your function tree to the debugger\ndevtools.add(ft)\n\n// If you are not going to use it anymore, remove it\ndevtools.remove(ft)\n\n// Remove all function trees from debugger\ndevtools.destroy()\n```\n\n## sequence\nYou can use an array literal to define a sequence of functions.\n\n```js\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = [\n  someFunction,\n  someOtherFunction\n]\n```\n\nOr you can be explicit by using the **sequence** function:\n\n```js\nimport {sequence} from 'function-tree'\n// Node:\n// const sequence = require('function-tree').sequence\n\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = sequence([\n  someFunction,\n  someOtherFunction\n])\n```\n\nThe first argument to **sequence** can be a string, which names the sequence. This will be shown in the debugger. If it is the root sequence it will be used as the name of the execution itself.\n\n```js\nimport {sequence} from 'function-tree'\n// Node:\n// const sequence = require('function-tree').sequence\n\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = sequence('My awesome sequence', [\n  someFunction,\n  someOtherFunction\n])\n```\n\n## parallel\n```js\nimport {parallel} from 'function-tree'\n// Node:\n// const sequence = require('function-tree').parallel\n\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = parallel([\n  someFunction,\n  someOtherFunction\n])\n```\n\nEven though **someFunction** returns a Promise, **someOtherFunction** will be run immediately.\n\n## context\n\n### path\nThe path is only available on the context when the function can diverge the execution down a path.\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nfunction funcA (context) {\n  context.props.foo // \"bar\"\n\n  return context.path.pathA({foo2: 'bar2'})\n}\n\nfunction funcB (context) {\n  context.props.foo // \"bar\"\n  context.props.foo2 // \"bar2\"\n\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({foo3: 'bar3'})\n    }, 100)\n  })\n}\n\nfunction funcC(context) {\n  context.props.foo // \"bar\"\n  context.props.foo2 // \"bar2\"\n  context.props.foo3 // \"bar3\"\n}\n\nconst ft = new FunctionTree({})\nconst tree = [\n  funcA, {\n    pathA: [\n      funcB,\n      funcC\n    ],\n    pathB: []\n  }\n]\n\nft.run(tree, {foo: 'bar'})\n```\n\n### props\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nfunction funcA (context) {\n  context.props.foo // \"bar\"\n}\n\nconst ft = new FunctionTree()\nconst tree = [\n  funcA\n]\n\nft.run(tree, {foo: 'bar'})\n```\n\n## error\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\nconst ft = new FunctionTree({})\n\n// As an event (async)\nft.on('error', function (error, execution, payload) {})\n\n// As callback for single execution\n// Triggers sync/async depending on where error occurs\nft.run(tree, (error) => {})\n\n// As callback (sync)\nft.run(tree, (error, execution, payload) => {\n  if (error) {\n    // There is an error\n  }\n})\n```\n\n## Provider\nYou can create your own custom providers which exposes the domain specific API you need for your application. You can also use it to set defaults for side effects, or even just transform the API more to your liking. With a **Provider** the debugger will know about the executions and inform you which functions executed them.\n\n```js\nimport axios from 'axios'\nimport { Provider } from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').Provider\n\nconst http = new Provider({\n  get(...args) {\n    return axios.get(...args)\n  }\n})\n\nconst api = new Provider({\n  getArticles() {\n    return this.context.http.get('/articles')\n  }\n})\n\nconst ft = new FunctionTree({\n  http,\n  api\n})\n```\n\n## tags\nTags gives you more power to write declarative code.\n\n### createTemplateTag\nAllows you to add new tags, targeting your custom providers.\n\n```js\nimport {createTemplateTag} from 'function-tree'\n\nexport const myTag = createTemplateTag('myTag', (path, context) => {\n  return context.myProvider.get(path)\n})\n```\n\n**Example use**\n```js\nsomeChain = [\n  set(props`foo`, myTag`other.path`)\n]\n```\n\n### extractValueWithPath\nEasy way to support nested values extraction from objects using the path.\n\n```js\nimport {createTemplateTag, extractValueWithPath} from 'function-tree'\n\nexport const myTag = createTemplateTag('myTag', (path, context) => {\n  return extractValueWithPath(context.something, path)\n})\n```\n\n### props\nTargets the props passed into the execution of a function tree:\n\n```js\nimport {props} from 'function-tree/tags'\n\nexport default [\n  shout(props`text`)\n]\n```\n\n### resolveObject\nWraps an object passed to a function factory, resolving any template tags.\n\n```js\nimport {props, resolveObject, string} from 'function-tree'\n\nconst mychain = [\n  setOptions(resolveObject({foo: props`foo`, bar: string`bar`}))\n]\n```\n\n### ResolveProvider\nBy default your function tree instance includes the ResolveProvider. It allows you to evaluate tags.\n\n```js\nfunction myFunctionFactory(someValue) {\n  function myFunction ({resolve}) {\n    // Evaluates to the contextual value's value, if not a contextual value\n    // it will just return the value.\n    resolve.value(someValue)\n\n    // Evaluates the path in the tag (someValue must be a Tag).\n    resolve.path(someValue)\n\n    // Evaluates if variable is a tag. We can optionally pass an array of\n    // types such as ['props', 'string'] as second argument.\n    resolve.isTag(someValue)\n\n    // Evaluates if variable is a ResolveValue. Useful when you have created custom\n    // stuff to be evaluated in tags or other, extending ResolveValue class.\n    resolve.isResolveValue(someValue)\n  }\n\n  return myFunction\n}\n```\n\n### ResolveValue\nAllows you to create a custom tag value container.\n\n```js\nimport {ResolveValue} from 'function-tree'\n\nclass Uppercaser extends ResolveValue {\n  constructor(tag) {\n    super()\n    this.tag = tag\n  }\n  // Required method\n  getValue(context) {\n    return this.tag.getValue(context).toUpperCase()\n  }\n}\n\nexport default (tag) => {\n  return new Uppercaser(tag)\n}\n```\n\n**Example use**\n```js\nimport uppercaser from './uppercaser'\n\nexport default [\n  shout(string`Hello, ${uppercaser(props`name`)}`)\n]\n```\n\n### string\nReturns the evaluated string.\n\n```js\nimport {string, props} from 'function-tree/tags'\n\nexport default [\n  shout(string`Hello ${props`name`}`)\n]\n```\n\n## events\nThe execute function is also an event emitter.\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nconst ft = new FunctionTree([])\nconst tree = [\n  funcA\n]\n\n// When an error is thrown, also catches promise errors\nft.on('error', (error, execution, payload) => {})\n\n// When a function tree is executed\nft.on('start', (execution, payload) => {})\n\n// When a function tree execution has ended\nft.on('end', (execution, payload) => {})\n\n// When a function tree goes down a path\nft.on('pathStart', (execution, payload) => {})\n\n// When a function tree ends execution of a path\nft.on('pathEnd', (execution, payload) => {})\n\n// When a function in a function tree starts executing\nft.on('functionStart', (execution, functionDetails, payload) => {})\n\n// When a function in a function tree stops executing\nft.on('functionEnd', (execution, functionDetails, payload) => {})\n\n// Triggers when an async function has been run\nft.on('asyncFunction', (execution, functionDetails, payload) => {})\n\n// When a parallel execution is about to happen (array in array)\nft.on('parallelStart', (execution, payload, functionsToResolveCount) => {})\n\n// When a function in parallel execution is done executing\nft.on('parallelProgress', (execution, payload, functionsStillResolvingCount) => {})\n\n// When a parallel execution is done\nft.on('parallelEnd', (execution, payload, functionsExecutedCount) => {})\n\nft.run(tree)\n```\n","title":"function-tree"},"baobab":{"raw":"# @cerebral/baobab\n\n## Install\n\n`npm install @cerebral/baobab`\n\n## Description\nUse the [Baobab](https://github.com/Yomguithereal/baobab) project as a Model instead of default model. This gives you for example immutability. You use the state API as normal.\n\n## Instantiate\n\n```js\nimport BaobabModel from '@cerebral/baobab'\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  Model: new BaobabModel({/* Baobab options */})\n})\n```\n","title":"@cerebral/baobab"},"firebase":{"raw":"# @cerebral/firebase\n\n## Install\n**NPM**\n\n`npm install @cerebral/firebase`\n\n## Description\nThe Firebase provider is a Cerebral friendly wrapper around the Firebase client. By default the Firebase client is heavily event based, even just getting some value, handling authentication etc. This is useful in some types of apps, but Cerebral has a very straight forward way of thinking about side effects. You will find that a lot of the API exposed by the Firebase client is simplified!\n\n\n## Instantiate\n\n```javascript\nimport {Controller} from 'cerebral'\nimport FirebaseProvider from '@cerebral/firebase'\n\nconst controller = Controller({\n  providers: [\n    FirebaseProvider({\n      config: {\n        apiKey: '{apiKey}',\n        authDomain: '{authDomain}',\n        databaseURL: '{databaseURL}',\n        storageBucket: '{storageBucket}'\n      },\n      // Tasks related options:\n      // Prefix the specs triggered. This is useful in\n      // development when multiple developers are working\n      // on the same instance.\n      specPrefix: 'CJ',\n      // Use a different queue path.\n      queuePath: 'myqueue' // default = 'queue',\n      // Set to true if you are using debugger cross client\n      // and server\n      sendTaskExecutionDetails: false\n    })\n  ]\n})\n```\n\n**Important notes**\n\n- The Cerebral firebase provider uses **dot** notation to keep consistency with Cerebral itself\n\n- All factories supports template tags, allowing you to dynamically create paths and points to values\n\n## cancelOnDisconnect\nCancel setting a value when Firebase detects disconnect.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  firebase.cancelOnDisconnect()\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {cancelOnDisconnect} from '@cerebral/firebase/operators'\n\nexport default [\n  cancelOnDisconnect()\n]\n```\n\n## createUserWithEmailAndPassword\nRegister a new user with email and password.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  const email = state.get('register.email')\n  const password = state.get('register.password')\n\n  return firebase.createUserWithEmailAndPassword(email, password)\n    .then((response) => {\n      /*\n        user: { uid: 'someuid', ... }\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {createUserWithEmailAndPassword} from '@cerebral/firebase/operators'\n\nexport default [\n  createUserWithEmailAndPassword(state`newUser.email`, state`newUser.password`),\n  /*\n    PROPS: {\n      response: { user: {} }\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {createUserWithEmailAndPassword} from '@cerebral/firebase/operators'\n\nexport default [\n  createUserWithEmailAndPassword(state`newUser.email`, state`newUser.password`), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## deleteFile\n\nUse `deleteFile` to remove an uploaded file. Specify the containing folder and filename.\n\n### action\n```js\nfunction someAction({ firebase, props }) {\n  return firebase.deleteFile('folderName', props.fileName)\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```js\nimport {props, state, string} from 'cerebral/tags'\nimport {deleteFile} from '@cerebral/firebase/operators'\n\nexport default [\n  deleteFile(\n    string`posts.all.${props`postId`}`,\n    state`posts.all.${props`postId`}.imageName`\n  ),\n  // No output\n\n  // Alternatively with explicit paths\n  deleteFile(\n    string`posts.all.${props`postId`}`,\n    state`posts.all.${props`postId`}.imageName`\n  ), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### operator with paths\n```js\nimport {props, state, string} from 'cerebral/tags'\nimport {deleteFile} from '@cerebral/firebase/operators'\n\nexport default [\n  deleteFile(\n    string`posts.all.${props`postId`}`,\n    state`posts.all.${props`postId`}.imageName`\n  ), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## error\nThe Firebase errors are passed to signal and global catch handlers, or `.catch` handler in your actions.\n\n### FirebaseProviderError (base)\n```js\nimport {FirebaseProviderError} from '@cerebral/firebase'\n\n// Error structure\n{\n  name: 'HttpProviderError',\n  message: 'Some firebase error message'\n  stack: '...'  \n}\n```\n\n### FirebaseProviderAuthenticationError\n```js\nimport {FirebaseProviderAuthenticationError} from '@cerebral/firebase'\n\n// Error structure\n{\n  name: 'HttpProviderError',\n  message: 'Some firebase error message'\n  code: 10 // firebase auth error code\n  stack: '...'  \n}\n```\n\n## getDownloadURL\nWill get the download url of a given file in firebase storage.\n\n### action\n```js\nfunction someAction({ firebase, props }) {\n  return firebase.getDownloadURL('images', `${props.path}.jpg`)\n    .then((response) => {\n      /*\n        response: https://foo.com/myImage.jpg\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport { getDownloadURL } from '@cerebral/firebase/operators'\n\nexport default [\n  getDownloadURL('images', string`${props`path`}.jpg`), {\n    success: [\n      /* PROPS: { response: https://foo.com/myImage.jpg } */\n    ],\n    error: [\n      /* PROPS: { error: { ... } } */\n    ]\n  }\n]\n```\n\n## getUser\nWill resolve to `{user: {}}` if user exists. If user was redirected from Facebook/Google etc. as part of first sign in, this method will handle the confirmed registration of the user.\n\n### action\n```js\nfunction someAction({ firebase }) {\n  return firebase.getUser()\n    .then((response) => {\n      /*\n        user: {...},\n        isRedirected: false\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {getUser} from '@cerebral/firebase/operators'\n\nexport default [\n  getUser(),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {getUser} from '@cerebral/firebase/operators'\n\nexport default [\n  getUser(), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## linkWith{PROVIDER}\nLink an anonymous account with Facebook, Google or Github.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.linkWithFacebook({\n    redirect: false, // Use popup or redirect. Redirect typically for mobile\n    scopes: [] // Facebook scopes to access\n  })\n    .then((response) => {\n      /*\n        name: 'Bob',\n        ...\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {linkWithFacebook} from '@cerebral/firebase/operators'\n\nexport default [\n  linkWithFacebook({\n    redirect: state`useragent.media.small`\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {linkWithFacebook} from '@cerebral/firebase/operators'\n\nexport default [\n  linkWithFacebook({\n    redirect: state`useragent.media.small`\n  }), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\nSimilar you can sign in with Google or GitHub.\nJust use `linkWithGoogle` or `linkWithGithub` instead of `linkWithFacebook`.\n\n\n## off\n\n### action\n```js\nfunction someAction({ firebase }) {\n  // Turn off listener at specific path and\n  // specific event\n  firebase.off('posts', 'onChildChanged')\n\n  // Turn off all listeners at specific path\n  firebase.off('posts')\n\n  // Turn off all listeners of specific event at wildcard path\n  firebase.off('posts.*', 'onChildChanged')\n\n  // Turn off all listeners at wildcard path\n  firebase.off('posts.*')\n}\n```\n\n### operator\n```javascript\nimport {string} from 'cerebral/tags'\nimport {off} from '@cerebral/firebase/operators'\n\nexport default [\n  // Same API as in actions, also wildcard\n  off('posts', 'onChildChanged'),\n\n  // Compose using string tag\n  off(string`posts.${state`selectedPostKey`}`)\n]\n```\n\n## onChildAdded\n\n### action\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildAdded('posts', 'posts.postAdded', {\n    // Merged with the payload passed on new data\n    payload: {},\n    // Read Firebase docs for these options\n    endAt: 5,\n    equalTo: 5,\n    limitToFirst: 5,\n    limitToLast: 5,\n    orderByChild: 'count',\n    orderByKey: true,\n    orderByValue: true,\n    startAt: 5,\n  })\n  // posts.postAdded called with { key, value, ...payload }\n}\n```\n\nThis will immediately grab and trigger the signal `posts.postAdded` for every post grabbed. Note this is just registering a listener, not returning a value from the action. The signal is triggered with the payload: `{ key: 'someKey', value: {} }`.\n\nTo stop listening for updates to the posts:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildAdded');\n}\n```\n\n### operator\n```javascript\nimport {state, string, signal} from 'cerebral/tags'\nimport {onChildAdded} from '@cerebral/firebase/operators'\n\nexport default [\n  onChildAdded(string`foo.bar`, signal`some.signal`, {\n    orderByChild: 'count',\n    limitToFirst: state`config.limitToFirst`\n  })\n]\n```\n\n## onChildChanged\n\n### action\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildChanged('posts', 'posts.postChanged', {\n    // Same options as above\n  })\n  // posts.postChanged called with { key, value, ...payload }\n}\n```\nThis will trigger the signal `posts.postChanged` whenever a post is changed in the selection. The signal is triggered with the payload: `{ key: 'someKey', value: {} }`.\n\nTo stop listening:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildChanged');\n}\n```\n\n### operator\n```javascript\nimport {onChildChanged} from '@cerebral/firebase/operators'\nimport {string, signal} from 'cerebral/tags'\n\nexport default [\n  onChildChanged(string`foo.bar`, signal`some.signal`, {\n    // Same options as above\n  })\n]\n```\n\n## onChildRemoved\n\n### action\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildRemoved('posts', 'posts.postRemoved', {\n    // Same options as above\n  })\n  // posts.postRemoved called with { key, ...payload }\n}\n```\nThis will trigger the signal `posts.postRemoved` whenever a post is removed from the selection. The signal is triggered with the payload: `{ key: 'someKey' }`.\n\nTo stop listening:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildRemoved');\n}\n```\n\n### operator\n```javascript\nimport {onChildRemoved} from '@cerebral/firebase/operators'\nimport {string, signal} from 'cerebral/tags'\n\nexport default [\n  onChildRemoved(string`foo.bar`, signal`some.signal`, {\n    // Same options as above\n  })\n]\n```\n\n## onValue\n\n### action\n```js\nfunction someAction({ firebase }) {\n  firebase.onValue('someKey.foo', 'someModule.fooUpdated',  {\n    payload: {}, // Merged with the payload passed on new data\n  })\n  // someModule.fooUpdate called with { value, ...payload }\n}\n```\n\nThis will **NOT** immediately grab the value and trigger the signal passed, the first event is discarded for more predictable behaviour. To grab existing value, just use `value`.\n\nTo stop listening for updates to the value:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('someKey.foo', 'onValue');\n}\n```\n\n### operator\n```javascript\nimport {onValue} from '@cerebral/firebase/operators'\nimport {string, signal} from 'cerebral/tags'\n\nexport default [\n  onValue(string`foo.bar`, signal`some.signal`)\n]\n```\n\n## push\nGenerates a new child location using a unique key and returns its reference from the action. An example being `{key: \"-KWKImT_t3SLmkJ4s3-w\"}`.\n\n### action\n```javascript\nfunction someAction({firebase}) {\n  return firebase.push('users', {\n    name: 'Bob'\n  })\n    .then((response) => {\n      /*\n        {\n          key: 'someKey'\n        }\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {push} from '@cerebral/firebase/operators'\n\nexport default [\n  push('users', state`newUser`),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {push} from '@cerebral/firebase/operators'\n\nexport default [\n  push('users', state`newUser`), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n*output*\n```javascript\n{key: 'theAddedKey'}\n```\n\n## put\n\nUpload a new file at the given location. Please note that the file is **not** stored inside the realtime database but into Google Cloud Storage (please consult filrebase documentation). This means that you need to take care of storage security as well.\n\nNote that `put` expects a folder as first argument and will use the name of the provided file. If you want to control the filename, add this in the options. In this case, make sure to respect file type and extension...\n\n### action\n```js\nfunction someAction({ firebase, props }) {\n  return firebase.put('folderName', props.file, {\n    progress({progress, bytesTransferred, totalBytes, state}) {\n      /* do whatever */\n    },\n    // Override name, make sure you set same extension\n    filename: 'customName.png'\n    // optional payload added to progress callback\n    { type: 'avatar'\n    }\n  })\n    .then((response) => {\n      /*\n        {\n          url: 'urlToFile',\n          filename: 'nameOfFile'\n          ... payload\n        }\n      */\n    })\n}\n```\n\n### operator\n```js\nimport {props, signal, string, state} from 'cerebral/tags'\nimport {put} from '@cerebral/firebase/operators'\n\n// we expect props.file to contain a file provided by\n// a user in an <input type='file' />\nexport default [\n  put(string`posts.all.${props`postId`}`, props`file`, {\n    // Trigger a signal which receives payload\n    progress: signal`gallery.progress`\n    // Set progress on a state value\n    progress: state`gallery.progress`\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {props, signal, string, state} from 'cerebral/tags'\nimport {put} from '@cerebral/firebase/operators'\n\n// we expect props.file to contain a file provided by\n// a user in an <input type='file' />\nexport default [\n  put(string`posts.all.${props`postId`}`, props`file`, {\n    progress: signal`gallery.progress`\n    progress: state`gallery.progress`\n  }), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## remove\nRemove the data at this database location.\n\n### action\n```javascript\nfunction someAction({ firebase}) {\n  return firebase.remove('foo.bar')\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {props, string} from 'cerebral/tags'\nimport {remove} from '@cerebral/firebase/operators'\n\nexport default [\n  remove(string`users.${props`userKey`}`),\n  // No output\n]\n```\n\n### operator with paths\n```javascript\nimport {props, string} from 'cerebral/tags'\nimport {remove} from '@cerebral/firebase/operators'\n\nexport default [\n  remove(string`users.${props`userKey`}`), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## sendPasswordResetEmail\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.sendPasswordResetEmail(state.get('user.email'))\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {sendPasswordResetEmail} from '@cerebral/firebase/operators'\n\nexport default [\n  sendPasswordResetEmail(state`user.email`),\n  // No output\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {sendPasswordResetEmail} from '@cerebral/firebase/operators'\n\nexport default [\n  sendPasswordResetEmail(state`user.email`), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## set\nWrite data to this database location. This will overwrite any data at this location and all child locations. Passing **null** for the new value is equivalent to calling remove(); all data at this location or any child location will be deleted.\n\n### action\n```javascript\nfunction someAction({firebase}) {\n  return firebase.set('foo.bar', 'baz')\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {props} from 'cerebral/tags'\nimport {set} from '@cerebral/firebase/operators'\n\nexport default [\n  set('foo.bar', props`foo`),\n  // No output\n]\n```\n\n### operator with paths\n```javascript\nimport {props} from 'cerebral/tags'\nimport {set} from '@cerebral/firebase/operators'\n\nexport default [\n  set('foo.bar', props`foo`), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## setOnDisconnect\nSets a value when Firebase detects user has disconnected.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  firebase.setOnDisconnect(`activeUsers.${state.get('app.user.uid')}`, 'someValue')\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {setOnDisconnect} from '@cerebral/firebase/operators'\n\nexport default [\n  setOnDisconnect(string`activeUsers.${state`app.user.uid`}`, null)\n]\n```\n\n## signInAnonymously\nThis login will method will resolve to existing anonymous or create a new one for you.\n\n### action\n```js\nfunction someAction({ firebase }) {\n  return firebase.signInAnonymously()\n    .then((user) => {\n      /*\n        name: 'Bob',\n        ...\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {signInAnonymously} from '@cerebral/firebase/operators'\n\nexport default [\n  signInAnonymously(),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {signInAnonymously} from '@cerebral/firebase/operators'\n\nexport default [\n  signInAnonymously(), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## signInWithCustomToken\nSign in a custom token.\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.signInWithCustomToken(state.get('token'))\n}\n```\n\n*factory*\n```javascript\nimport {props, state} from 'cerebral/tags'\nimport {signInWithCustomToken} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithCustomToken(props`token`),\n\n  // Alternatively with explicit paths\n  signInWithCustomToken(state`token`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```javascript\n{user: {}}\n```\n\n## signInWithEmailAndPassword\nSign in a user with email and password.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  const email = state.get('register.email')\n  const password = state.get('register.password')\n\n  return firebase.signInWithEmailAndPassword(email, password)\n    .then((response) => {\n      /*\n        name: 'Bob',\n        ...\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {props} from 'cerebral/tags'\nimport {signInWithEmailAndPassword} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithEmailAndPassword(props`email`, props`password`),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {props} from 'cerebral/tags'\nimport {signInWithEmailAndPassword} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithEmailAndPassword(props`email`, props`password`), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## signInWith{PROVIDER}\nSign in a user with Facebook, Google or Github.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.signInWithFacebook({\n    redirect: false, // Use popup or redirect. Redirect typically for mobile\n    scopes: [] // Facebook scopes to access\n  })\n    .then((response) => {\n      /*\n        name: 'Bob',\n        ...\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {signInWithFacebook} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithFacebook({\n    redirect: state`useragent.media.small`\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {signInWithFacebook} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithFacebook({\n    redirect: state`useragent.media.small`\n  }), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\nSimilar you can sign in with Google or GitHub.\nJust use `signInWithGoogle` or `signInWithGithub` instead of `signInWithFacebook`.\n\n## signOut\nSign out user. **getUser** will now not resolve a user anymore.\n\n### action\n```js\nfunction someAction({ firebase }) {\n  return firebase.signOut()\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {signOut} from '@cerebral/firebase/operators'\n\nexport default [\n  signOut(),\n  // No output\n]\n```\n\n### operator with paths\n```javascript\nimport {signOut} from '@cerebral/firebase/operators'\n\nexport default [\n  signOut(), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## task\nIf you are using the [firebase-queue](https://github.com/firebase/firebase-queue) and need to create tasks, you can do that with:\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.task('create_post', {\n    uid: state.get('app.user.uid'),\n    text: state.get('posts.newPostText')\n  })\n    .then(() => {\n      // No output\n    })\n}\n```\n\nThis will add a task at `queue/tasks`. There is no output from a resolved task, it just resolves when the action has been processed.\n\n### operator\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {task} from '@cerebral/firebase/operators'\n\nexport default [\n  task('some_task', {\n    uid: state`user.uid`,\n    data: props`data`\n  }),\n  // No output\n\n  // Alternatively with explicit paths\n  task('some_task', {\n    uid: state`user.uid`,\n    data: props`data`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### operator with paths\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {task} from '@cerebral/firebase/operators'\n\nexport default [\n  task('some_task', {\n    uid: state`user.uid`,\n    data: props`data`\n  }), {\n    success: [\n      // No output\n    ],\n    error: [\n      // No output\n    ]\n  }\n]\n```\n\n## transaction\nAtomically modifies the data at the provided location.\n\nUnlike a normal set(), which just overwrites the data regardless of its previous value, transaction() is used to modify the existing value to a new value, ensuring there are no conflicts with other clients writing to the same location at the same time.\n\nTo accomplish this, you pass transaction() an update function which is used to transform the current value into a new value. If another client writes to the location before your new value is successfully written, your update function will be called again with the new current value, and the write will be retried. This will happen repeatedly until your write succeeds without conflict or you abort the transaction by not returning a value from your update function.\n\n### action\n```javascript\nfunction someAction({firebase}) {\n\n  function transactionFunction(currentData){\n    if (currentData === null) {\n      return { foo: 'bar' }\n    }\n\n    return // Abort the transaction.\n  }\n\n  return firebase.transaction('some.transaction.path', transactionFunction)\n    .then((result) => {\n      if(result.committed){\n        return {result: result.value}\n      } else {\n        throw new Error('Transaction failed')\n      }\n    })\n      .then((response) => {\n        /*\n          {\n            committed: true,\n            value: 'new value'\n          }\n        */\n      })\n}\n```\n\nThis will add a task at `queue/tasks`. There is no output from a resolved task, it just resolves when the action has been processed.\n\n### operator\n```javascript\nimport {transaction} from '@cerebral/firebase/operators'\n\nfunction transactionFunction() {...}\n\nexport default [\n  transaction('foo.bar', transactionFunction),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {transaction} from '@cerebral/firebase/operators'\n\nfunction transactionFunction() {...}\n\nexport default [\n  transaction('foo.bar', transactionFunction), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      // No output\n    ]\n  }\n]\n```\n\nNote: Modifying data with set() will cancel any pending transactions at that location, so extreme care should be taken if mixing set() and transaction() to update the same data.\n\nNote: When using transactions with Security and Firebase Rules in place, be aware that a client needs .read access in addition to .write access in order to perform a transaction. This is because the client-side nature of transactions requires the client to read the data in order to transactionally update it.\n\n## update\nAs opposed to the set() method, update() can be use to selectively update only the referenced properties at the current location (instead of replacing all the child properties at the current location).\n\n### action\n```javascript\nfunction someAction({firebase}) {\n  return firebase.update('some.path', {\n    'foo': 'bar',\n    'items.item1.isAwesome': true\n  })\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {props} from 'cerebral/tags'\nimport {update} from '@cerebral/firebase/operators'\n\nexport default [\n  update('some.path', {\n    'foo.bar': props`bar`,\n    'foo.baz': props`baz`\n  }),\n  // No output\n\n  // Alternatively with explicit paths\n  update('some.path', {\n    'foo.bar': props`bar`,\n    'foo.baz': props`baz`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### operator with paths\n```javascript\nimport {props} from 'cerebral/tags'\nimport {update} from '@cerebral/firebase/operators'\n\nexport default [\n  update('some.path', {\n    'foo.bar': props`bar`,\n    'foo.baz': props`baz`\n  }), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## value\n\n### action\n```js\nfunction someAction({ firebase }) {\n  return firebase.value('someKey.foo')\n    .then((response) => {\n      /*\n        {\n          key: 'foo',\n          value: 'some value'\n        }\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {value} from '@cerebral/firebase/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  value('foo.bar'),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n  // Alternatively with explicit paths\n  value('foo.bar'), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### operator with paths\n```javascript\nimport {value} from '@cerebral/firebase/operators'\n\nexport default [\n  value('foo.bar'), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n","title":"@cerebral/firebase"},"firebase_admin":{"raw":"# @cerebral/firebase-admin\n\n## Install\n**NPM**\n\n`npm install @cerebral/firebase-admin`\n\n## Description\nThe firebase admin package for function-tree allows you to easily handle Firebase Queues. With the Cerebral debugger you will even be able to merge execution data cross client/server. This package helps you set up a **QueueHandler** which registers your specs with queues and lets you know when new tasks are ready to be run.\n\n## provider\nFirst you create a function tree with the Firebase provider. You will need to add the Devtools with the same port as the client to merge execution.\n\n```js\nconst FunctionTree = require('function-tree').FunctionTree\nconst Devtools = require('function-tree/devtools')\nconst FirebaseProvider = require('@cerebral/firebase-admin').Provider\n\nconst devtools = Devtools({\n  // Connect to same port as the client to merge execution\n  host: 'localhost:8787'\n})\n\nconst runTask = new FunctionTree([\n  devtools.Provider(),\n  FirebaseProvider({\n    serviceAccount: {} // your service account details\n    databaseURL: '', // Your database url\n  })\n  /* Your other providers */\n])\n\ndevtools.watchExecution(runTask)\n\nmodule.exports = runTask\n```\n\n\n### createKey\nCreate a new Firebase key at some path.\n```js\nfunction authenticate (context) {\n  const newKey = context.firebase.createKey('some/path')\n}\n```\n\n### listUsers\nLists all users from Firebase authentication. Responds with \"{users: [], nextPageToken: 'token'}\".\n```js\nfunction listAllUsers (context) {\n  return context.firebase.listUsers(context.props.maxResults, context.props.nextPageToken)\n  }\n```\n\n### createUser\nCreate a user from Firebase. All properties are optional. Responds with \"user\".\n```js\nfunction createUser (context) {\n  return context.firebase.createUser({\n    uid: context.props.uid,\n    email: context.props.email,\n    emailVerified: context.props.emailVerified,\n    phoneNumber: context.props.phoneNumber,\n    password: context.props.password,\n    displayName: context.props.displayName,\n    photoURL: context.props.photoURL,\n    disabled: context.props.disabled\n  })\n}\n```\n\n### deleteUser\nDelete a user from Firebase. Outputs nothing.\n```js\nfunction deleteUser (context) {\n  return context.firebase.deleteUser(context.props.uid)\n}\n```\n\n### push\nPush new data. Outputs {key: 'keyAdded'}.\n```js\nfunction addItem (context) {\n  return context.firebase.push('items', context.props.data.item)\n}\n```\n\n### remove\nRemove key. Outputs nothing.\n```js\nfunction removeItem (context) {\n  return context.firebase.remove(`items/${context.props.itemKey}`)\n}\n```\n\n### set\nSet new data. Output nothing.\n```js\nfunction addItem (context) {\n  return context.firebase.set(`items/${context.props.data.itemKey}`, context.props.data.item)\n}\n```\n\n### transaction\nRun a transaction. Outputs nothing.\n```js\nfunction updateItems (context) {\n  return context.firebase.transaction('some/path', (maybeValue) => {\n    if (!maybeValue) {\n      return 'bar'\n    }\n\n    return context.props.data.foo\n  })\n}\n```\n\n### update\nUpdate multiple paths from top level or at specific path. Outputs nothing.\n```js\nfunction updateItems (context) {\n  return context.firebase.update({\n    'items/1': context.props.data.item1Data,\n    'items/2': context.props.data.item2Data\n  })\n}\n```\n\n```js\nfunction updateItems (context) {\n  return context.firebase.update('items', {\n    '1': context.props.data.item1Data,\n    '2': context.props.data.item2Data\n  })\n}\n```\n\n### value\nGet value. Outputs {key: 'theKey', value: 'theValue'}.\n```js\nfunction updateItems (context) {\n  return context.firebase.value('some/path')\n}\n```\n\n### task\nRun a task\n```js\nfunction runTask (context) {\n  return context.firebase.task('someTask', {\n    // Data to task\n  })\n}\n```\n\n\n## queueHandler\nThe QueueHandler is responsible for registering Firebase Queues with your defined specs and what trees should run when new tasks arrive in Firebase. The QueueHandler also automatically authenticates the tasks using **verifyIdToken**.\n\n```js\nconst runTask = require('./runTask')\nconst firebase = require('firebase-admin')\nconst username = require('username')\nconst QueueHandler = require('@cerebral/firebase-admin').QueueHandler\n\nmodule.exports = new QueueHandler({\n  // If you are using a specPrefix on the client during development\n  // you will have to use it here as well, to pick up the correct\n  // queue tasks. It is automatically removed in production\n  specPrefix: username.sync(),\n\n  // You can specify if you want to authenticate or not.\n  // default is false\n  authenticate: true,\n\n  // An array of specs and corresponding trees to run\n  tasks: [{\n    specId: 'some_spec_name',\n    numWorkers: 100,\n    tree: [\n      /* Some tree to run */\n    ]\n  }],\n\n  // A reference in Firebase to your queue\n  queueRef: firebase.database().ref('queue')\n}, (specId, tree, payload) => {\n  runTask.run(specId, tree, payload)\n    .catch((error) => {\n      // Handle error. Payload has error property with details\n      runTask.run('ERROR', [/* A tree handling errors */], error.payload)\n    })\n});\n```\n\nWhen a task runs you have access to the following **props**:\n\n```js\nfunction someFunc (context) {\n  context.props.uid // Uid of user who made the task\n  context.props.data // Data passed from client\n  context.props.task.resolve // Resolve the task\n  context.props.task.reject // Reject the task\n}\n```\n\n## task\nIf you are using the [firebase-queue](https://github.com/firebase/firebase-queue) and need to create tasks, you can do that with:\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.task('create_post', {\n    uid: state.get('app.user.uid'),\n    text: state.get('posts.newPostText')\n  })\n}\n```\n\nThis will add a task at `queue/tasks`. There is no output from a resolved task, it just resolves when the action has been processed.\n\n## testTasks\nYou can easily test tasks. The TestTasks includes a local [firebase-server](https://github.com/urish/firebase-server) and allows you to define a state of your Firebase instance before running tasks and assert its state after the tasks are run.\n\n```js\nconst TestTasks = require('@cerebral/firebase-admin').TestTasks\n\nconst testTasks = new TestTasks([\n  /* Any mocked providers */\n])\n\nmodule.exports = testTasks\n```\n\nIn your test framework of choice:\n\n```js\nconst someTreeToRun = require('./someTreeToRun')\nconst test = require('./testTasks');\nconst assert = require('assert');\n\ndescribe('example', () => {\n  it('should test for foo', (done) => {\n    const runTest = test.create({\n      foo: 'bar'\n    }, {\n      // The tree to be run\n      task: someTreeToRun,\n\n      // Data to pass into tree execution\n      data: {\n        bip: 'bop'\n      }\n    }, (data) => {\n      assert.equal(data.foo, 'bar')\n    });\n\n    runTest(done)\n  })\n})\n```\n\nRun multiple tasks:\n\n```js\nconst someTreeToRun = require('./someTreeToRun')\nconst test = require('./testTasks');\nconst assert = require('assert');\n\ndescribe('example', () => {\n  it('should test for foo', (done) => {\n    const runTest = test.create({\n      foo: 'bar'\n    }, [{\n      task: someTreeToRun,\n      data: {\n        foo: 'bop'\n      },\n      // You can do assertions between running tasks\n      assert (data) {\n        assert.equal(data.foo, 'bop')\n      }\n    }, {\n      task: someTreeToRun,\n      data: {\n        foo: 'bap'\n      }\n    }], (data) => {\n      assert.equal(data.foo, 'bap')\n    });\n\n    runTest(done)\n  })\n})\n```\n","title":"@cerebral/firebase-admin"},"fluent":{"raw":"# @cerebral/fluent\n\n## Install\n\n`npm install @cerebral/fluent`\n\n## Description\nThis addon gives you full typesafety using [TypeScript](https://www.typescriptlang.org/). It exposes a chainable API and types to be used with defining your modules, sequences, actions and connecting to components.\n\nCurrently only [React](https://reactjs.org/) is supported.\n\nTo enable type safe mutations, the model of this addon is based on [Mobx](https://mobx.js.org/).\n\n## action\n\n```ts\nimport { sequence, Context } from './myFluent'\nimport * as actions from './actions'\n\nexport const doThis = sequence(s => s\n  .action(actions.someAction)\n)\n```\n\n## branch\n\n```ts\nimport { sequence } from './myFluent'\nimport * as actions from './actions'\n\nexport const doThis = Sequence(s => s\n  .branch(actions.someBranchAction)\n  .paths({\n    pathA: s => s,\n    pathB: s => s\n  })\n)\n```\n\n## computed\n\n```ts\nimport { Module, ComputedValue, Computed } from '@cerebral/fluent'\nimport * as sequences from './sequences'\n\ntype State = {\n  items: string[],\n  currentItemIndex: number,\n  currentItem: ComputedValue<string>\n}\n\nconst state: State = {\n  items: [],\n  currentItemIndex: 0,\n  currentItem: Computed(state => state.items[state.currentItemIndex])\n}\n\nexport const module = Module({\n  state\n})\n```\n\n**Computed** also exposes the root state:\n\n```ts\nComputed((state, root) => {})\n```\n\n## connect\n\n```ts\nimport * as React from 'react'\nimport { connect } from './myFluent'\n\ntype Props = {\n  externalProp: string\n}\n\nexport const App = connect<Props>()\n  .with(({ state, signals, props }) => ({\n    foo: state.foo,\n    onClick: signals.thisHappened\n  }))\n  .to(\n    function App ({ foo, onClick, externalProp }) {\n      return <div></div>\n    }\n  )\n  // Alternatively\n  .toClass(props =>\n    class App extends React.Component<typeof props> {\n      render () {\n        const { foo, onClick, externalProp } = this.props\n\n        return <div></div>\n      }\n    }\n  )\n```\n\n## controller\n\n```ts\nimport { Controller } from '@cerebral/fluent'\nimport { module as app } from './app'\nimport { State, Signals } from './fluent'\n\nconst controller = Controller<State, Signals>(app)\n```\n\nThe **State** and **Signals** type are not required, but will enable auto suggestions on:\n\n```ts\ncontroller.state\ncontroller.signals\n```\n\n## dictionary\n\n```ts\nimport { Dictionary } from '@cerebral/fluent'\n\nexport type State = {\n  items: Dictionary<string>\n}\n\nconst state: State = {\n  foo: Dictionary({\n    foo: 'bar',\n    bar: 'baz'\n  })\n}\n\nexport const module = Module({\n  state,\n  signals\n})\n```\n\n## debounce\n\n```ts\nimport { sequence } from './myFluent'\nimport * as actions from './actions'\n\nexport const doThis = sequence(s => s\n  .debounce(100)\n)\n```\n\n## equals\n\n```ts\nimport { sequence } from './myFluent'\n\nexport const doThis = sequence(s => s\n  .equals(({ state }) => state.user.role)\n  .paths({\n    admin: s => s,\n    user: s => s,\n    otherwise: s => s\n  })\n)\n```\n\n## factories\n\n```ts\nimport { IContext, IBranchContext, ConnectFacory, SequenceFactory, SequenceWithPropsFactory } from '@cerebral/fluent'\nimport { State, Signals, Providers } from './app'\n\nexport type Context<Props> = IContext<Props> & Providers;\n\nexport type BranchContext<Paths, Props> = IBranchContext<Paths, Props> & Providers;\n\nexport const connect = ConnectFactory<State, Signals>();\n\nexport const sequence = SequenceFactory<SignalContext>();\n\nexport const sequenceWithProps = SequenceWithPropsFactory<SignalContext>();\n```\n\n## IContext\n\n```ts\nimport { IContext } from '@cerebral/fluent'\nimport { HttpProvider } from '@cerebral/http'\n\nexport type State = {\n  foo: string\n}\n\nexport interface Providers {\n  http: HttpProvider,\n  state: State\n}\n\nexport type Context<Props> = IContext<Props> & Providers;\n```\n\n## IBranchContext\n\n```ts\nimport { IBranchContext } from '@cerebral/fluent'\nimport { HttpProvider } from '@cerebral/http'\n\nexport type State = {\n  foo: string\n}\n\nexport interface Providers {\n  http: HttpProvider,\n  state: State\n}\n\nexport type BranchContext<Paths, Props> = IBranchContext<Paths, Props> & Providers\n```\n\n## module\n\n```ts\nimport { Module } from '@cerebral/fluent'\nimport * as signals from './sequences'\n\nexport type ModuleSignals = {\n  [key in keyof typeof signals]: typeof signals[key]\n}\n\nexport type ModuleState = {\n  foo: string\n}\n\nconst state: ModuleState = {\n  foo: 'bar'\n}\n\nexport const module = Module({\n  state,\n  signals\n})\n```\n\n## paths\n\n```ts\nimport { sequence } from './myFluent'\nimport * as actions from './actions'\n\nexport const doThis = sequence(s => s\n  .branch(actions.doThis)\n  .paths({\n    success: s => s,\n    error: s => s\n  })\n)\n```\n\n\n## sequence\n\n```ts\nimport { sequence } from  './fluent'\n\n// Sequence without expected input and output props\nexport const doThis = sequence(s => s)\n\n// Sequence with expected output props\nexport const composeThis = sequence<{ foo: string, bar: string }>(s \n```\n\n## sequenceWithProps\n\n```ts\nimport { sequenceWithProps } from  './fluent'\n\n// Sequence with expected input props\nexport const doThis = sequenceWithProps<{ foo: string }>(s => s)\n\n// Sequence with expected input and output props\nexport const composeThis = sequence<{ foo: string }, { foo: string, bar: string }>(s \n```\n\n## wait\n\n```ts\nimport { Sequence } from  '@cerebral/fluent'\n\nexport const doThis = Sequence(s => s\n  .wait(1000)\n)\n```\n\n## when\n\n```ts\nimport { Sequence } from  '@cerebral/fluent'\n\nexport const doThis = Sequence(s => s\n  .when(({ state }) => state.isAwesome)\n  .paths({\n    true: s => s,\n    false: s => s\n  })\n)\n```\n\n## ComputedValue\n\n```ts\nimport { ComputedValue } from '@cerebral/fluent'\n\ntype State = {\n  someComputedString: ComputedValue<string>\n}\n```\n\n## Dictionary\n\n```ts\nimport { Dictionary } from '@cerebral/fluent'\n\ntype Item = {\n  title: string\n}\n\nexport type State = {\n  items: Dictionary<Item>\n}\n```\n\n","title":"@cerebral/fluent"},"forms":{"raw":"# @cerebral/forms\n\n## Install\n**NPM**\n\n`npm install @cerebral/forms`\n\n## Description\nThe forms provider allows you to easily compute forms based on a number of rules. Easily add new rules, error messages and, if you want, add whatever you want to your fields for custom logic.\n\n## Instantiate\n\n```javascript\nimport {Controller} from 'cerebral'\nimport FormsProvider from '@cerebral/forms'\n\nconst controller = Controller({\n  providers: [\n    FormsProvider({\n      // Add additional rules\n      rules: {\n        myAddedRule (value, arg, get) {\n          // value of the field\n          value\n          // arg passed to the rule\n          arg\n          // The \"get\" argument from computed. Use it to grab\n          // state or props passed to component. The component\n          // will track use of these dependencies for rerender\n          get\n\n          return true\n        }\n      },\n\n      // errorMessage property added to field when invalid with the following rules\n      errorMessages: {\n        minLength (value, minLength) {\n          return `The length is ${value.length}, should be equal or more than ${minLength}`\n        }\n      }\n    })\n  ]\n})\n```\n\n## compute\nTo use a form you use the **form** computed, pointing to the form. Typically:\n\n```js\nimport React from 'react'\nimport {connect} from '@cerebral/react'\nimport {form} from '@cerebral/forms'\n\nexport default connect({\n  form: form(state`path.to.form`)\n},\n  function MyForm ({form}) {\n    // Value of some field\n    form.someField.value\n    // A true/false if field has a value\n    form.someField.hasValue\n    // A true/false if field has been changed\n    form.someField.isPristine\n    // A true/false if field is valid\n    form.someField.isValid\n    // The name of the rule that failed\n    form.someField.failedRule.name\n    // Any arg you passed to the failing rule\n    form.someField.failedRule.arg\n    // If you have defined global error messages and field is invalid\n    form.someField.errorMessage\n    // Get all invalid fields\n    form.getInvalidFields()\n    // Get all fields\n    form.getFields()\n  }\n)\n```\n\nYou can also use the **field** computed, pointing to the field. This will optimize rendering as only the field will render on change.\n\n```js\nimport React from 'react'\nimport {connect} from '@cerebral/react'\nimport {field} from '@cerebral/forms'\n\nexport default connect({\n  field: field(state`path.to.form.name`)\n},\n  function MyField ({field}) {\n    // Value of some field\n    field.value\n    // A true/false if field has a value\n    field.hasValue\n    // A true/false if field has been changed\n    field.isPristine\n    // A true/false if field is valid\n    field.isValid\n  }\n)\n```\n\n## defaultValue\nYou can define a default value for your fields. When the form is **reset**, it will put back the default value:\n\n```js\n{\n  myForm: {\n    firstName: {\n      value: '',\n      defaultValue: 'Ben'\n    }\n  }\n}\n```\n\n## field\nA field is just an object with a `value` property:\n\n```js\n{\n  myForm: {\n    myField: {\n      value: ''\n    }\n  }\n}\n```\n\n## form\nA form is just an object in the state tree:\n\n```js\n{\n  myForm: {}\n}\n```\n\n## isRequired\nDefine field as required. This will make the field invalid if there is no value. By default forms identifies a value or not\nusing the **isValue** rule. You can change this rule if you want, look below.\n\n```js\n{\n  myForm: {\n    firstName: {\n      value: '',\n      isRequired: true\n    }\n  }\n}\n```\n\n## isValueRules\nYou can change what defines a field as having a value. For example if your value is an array, you can use the **minLength** rule to\ndefine a required minimum of 3 items in the array.\n\n```js\n{\n  myForm: {\n    interests: {\n      value: [],\n      isRequired: true,\n      isValueRules: ['minLength:3']\n    }\n  }\n}\n```\n\n## nesting\nYou can nest this however you want, even with array:\n\n```js\n{\n  myForm: {\n    firstName: {value: ''},\n    lastName: {value: ''},\n    address: [{\n      street: {value: ''},\n      zipCode: {value: ''}\n    }],\n    interests: {\n      books: {value: false},\n      films: {value: false}\n    }\n  }\n}\n```\n\n## operators\n\n### isValidForm\nDiverge execution based on validity of a form.\n\n```js\nimport {state} from 'cerebral/tags'\nimport {isValidForm} from '@cerebral/forms/operators'\n\nexport default [\n  isValidForm(state`my.form`), {\n    true: [],\n    false: []\n  }\n]\n```\n\n### resetForm\nReset a form.\n\n```js\nimport {state} from 'cerebral/tags'\nimport {resetForm} from '@cerebral/forms/operators'\n\nexport default [\n  resetForm(state`my.form`)\n]\n```\n\n### setField\nWhen you change the value of a field you will need to use this operator. Note that you point to the field, not the field value.\n\n```js\nimport {state, props} from 'cerebral/tags'\nimport {setField} from '@cerebral/forms/operators'\n\nexport default [\n  setField(state`my.form.field`, props`value`)\n]\n```\n\n## provider\nYou can also access your forms in actions.\n\n```js\nfunction myAction ({forms}) {\n  const form = forms.get('path.to.form')\n}\n```\n\n### reset\nReset the form to its default values (or empty string by default).\n\n```js\nfunction myAction ({forms}) {\n  forms.reset('path.to.form')\n}\n```\n\n### toJSON\nTypically you want to convert your forms to a plain value structure.\n\n```js\nfunction myAction ({forms}) {\n  const form = forms.toJSON('path.to.form')\n}\n```\n\nThis form will now have the structure of:\n\n```js\n{\n  myField: 'theValue',\n  address: {\n    street: 'street value',\n    zipCode: 'zip code value'\n  }\n}\n```\n\n### updateErrorMessages\nDynamically update global error messages:\n\n```js\nfunction myAction ({forms}) {\n  forms.updateErrorMessages({\n    someRule () {}\n  })\n}\n```\n\n### updateRules\nDynamically update available rules:\n\n```js\nfunction myAction ({forms}) {\n  forms.updateRules({\n    someNewRule () {}\n  })\n}\n```\n\n## validationRules\nYou add validation rules on the field:\n\n```js\n{\n  myForm: {\n    firstName: {\n      value: '',\n      validationRules: ['minLength:3']\n    }\n  }\n}\n```\n\n### equals:Value\n```js\n{\n  field1: {\n    value: 123, // valid\n    validationRules: ['equals:123']\n  },\n  field2: {\n    value: '123', // valid\n    validationRules: ['equals:\"123\"']\n  },\n  field3: {\n    value: [], // not valid\n    validationRules: ['equals:[]']\n  }\n}\n```\n\n### equalsField:Field\n```js\n{\n  field1: {\n    value: 'foo', // valid\n    validationRules: ['equalsField:full.path.to.form.field2']\n  },\n  field2: {\n    value: 'foo', // valid\n    validationRules: ['equalsField:full.path.to.form.field1']\n  },\n  field3: {\n    value: 'bar', // not valid\n    validationRules: ['equalsField:full.path.to.form.field2']\n  }\n}\n```\n\n### isAlpha\n```js\n{\n  field1: {\n    value: 'abc', // valid\n    validationRules: ['isAlpha']\n  },\n  field2: {\n    value: 'AbC', // valid\n    validationRules: ['isAlpha']\n  },\n  field3: {\n    value: '123abc', // not valid\n    validationRules: ['isAlpha']\n  }\n}\n```\n\n### isAlphanumeric\n```js\n{\n  field1: {\n    value: '123abc', // valid\n    validationRules: ['isAlphanumeric']\n  },\n  field2: {\n    value: '123', // valid\n    validationRules: ['isAlphanumeric']\n  },\n  field3: {\n    value: '123+abc', // not valid\n    validationRules: ['isAlphanumeric']\n  }\n}\n```\n\n### isEmail\n```js\n{\n  field1: {\n    value: 'ho@hep.co', // valid\n    validationRules: ['isEmail']\n  },\n  field2: {\n    value: 'hello@', // not valid\n    validationRules: ['isEmail']\n  },\n  field3: {\n    value: 'hel.co', // not valid\n    validationRules: ['isEmail']\n  }\n}\n```\n\n### isEmpty\n```js\n{\n  field1: {\n    value: '', // valid\n    validationRules: ['isEmpty']\n  },\n  field2: {\n    value: 'hello', // not valid\n    validationRules: ['isEmpty']\n  },\n  field3: {\n    value: 123, // not valid\n    validationRules: ['isEmpty']\n  }\n}\n```\n\n### isExisty\n```js\n{\n  field1: {\n    value: 0, // valid\n    validationRules: ['isExisty']\n  },\n  field2: {\n    value: [], // valid\n    validationRules: ['isExisty']\n  },\n  field3: {\n    value: null, // not valid\n    validationRules: ['isExisty']\n  }\n}\n```\n\n### isFalse\n```js\n{\n  field1: {\n    value: false, // valid\n    validationRules: ['isFalse']\n  },\n  field2: {\n    value: 'false', // not valid\n    validationRules: ['isFalse']\n  },\n  field3: {\n    value: true, // not valid\n    validationRules: ['isFalse']\n  }\n}\n```\n\n### isFloat\n```js\n{\n  field1: {\n    value: '22.5', // valid\n    validationRules: ['isFloat']\n  },\n  field2: {\n    value: 22.5, // valid\n    validationRules: ['isFloat']\n  },\n  field3: {\n    value: '22', // not valid\n    validationRules: ['isFloat']\n  }\n}\n```\n\n\n### isInt\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['isInt']\n  },\n  field2: {\n    value: 123, // valid\n    validationRules: ['isInt']\n  },\n  field3: {\n    value: '22.5', // not valid\n    validationRules: ['isInt']\n  }\n}\n```\n\n### isLength:Number\n```js\n{\n  field1: {\n    value: 'hey', // valid\n    validationRules: ['isLength:3']\n  },\n  field2: {\n    value: ['foo', 'bar'], // valid\n    validationRules: ['isLength:2']\n  },\n  field3: {\n    value: 'hm 123', // not valid\n    validationRules: ['isLength:3']\n  }\n}\n```\n\n\n### isNumeric\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['isNumeric']\n  },\n  field2: {\n    value: 123, // valid\n    validationRules: ['isNumeric']\n  },\n  field3: {\n    value: '123abc', // not valid\n    validationRules: ['isNumeric']\n  }\n}\n```\n\n### isSpecialWords\n```js\n{\n  field1: {\n    value: 'hey there', // valid\n    validationRules: ['isSpecialWords']\n  },\n  field2: {\n    value: 'some  åäö', // valid\n    validationRules: ['isSpecialWords']\n  },\n  field3: {\n    value: 'hm 123', // not valid\n    validationRules: ['isSpecialWords']\n  }\n}\n```\n\n### isTrue\n```js\n{\n  field1: {\n    value: true, // valid\n    validationRules: ['isTrue']\n  },\n  field2: {\n    value: 'true', // not valid\n    validationRules: ['isTrue']\n  },\n  field3: {\n    value: false, // not valid\n    validationRules: ['isTrue']\n  }\n}\n```\n\n### isUndefined\n```js\n{\n  field1: {\n    value: undefined, // valid\n    validationRules: ['isUndefined']\n  },\n  field2: {\n    value: 'hello', // not valid\n    validationRules: ['isUndefined']\n  },\n  field3: {\n    value: 123, // not valid\n    validationRules: ['isUndefined']\n  }\n}\n```\n\n### isUrl\n```js\n{\n  field1: {\n    value: 'http://www.test.com', // valid\n    validationRules: ['isUrl']\n  },\n  field2: {\n    value: 'http://www', // not valid\n    validationRules: ['isUrl']\n  },\n  field3: {\n    value: 'http//www', // not valid\n    validationRules: ['isUrl']\n  }\n}\n```\n\n### isWords\n```js\n{\n  field1: {\n    value: 'hey there', // valid\n    validationRules: ['isWords']\n  },\n  field2: {\n    value: 'wut åäö', // not valid\n    validationRules: ['isWords']\n  },\n  field3: {\n    value: 'hm 123', // not valid\n    validationRules: ['isWords']\n  }\n}\n```\n\n### isValue\n```js\n{\n  field1: {\n    value: 'test', // valid\n    validationRules: ['isValue']\n  },\n  field2: {\n    value: [], // not valid\n    validationRules: ['isValue']\n  },\n  field3: {\n    value: null, // not valid\n    validationRules: ['isValue']\n  },\n  field3: {\n    value: false, // not valid\n    validationRules: ['isValue']\n  }\n}\n```\n\n### maxLength:Number\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['maxLength:3']\n  },\n  field2: {\n    value: 'fo', // valid\n    validationRules: ['maxLength:3']\n  },\n  field3: {\n    value: ['foo', 'bar', 'baz', 'mip'], // not valid\n    validationRules: ['maxLength:3']\n  }\n}\n```\n\n### minLength:Number\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['minLength:3']\n  },\n  field2: {\n    value: 'fo', // not valid\n    validationRules: ['minLength:3']\n  },\n  field3: {\n    value: ['foo', 'bar', 'baz', 'mip'], // valid\n    validationRules: ['minLength:3']\n  }\n}\n```\n\n### regexp\n```js\n{\n  field1: {\n    value: 'foo', // valid\n    validationRules: [/foo/]\n  },\n  field2: {\n    value: 'bar', // not valid\n    validationRules: [/foo/]\n  }\n}\n```\n","title":"@cerebral/forms"},"http":{"raw":"# @cerebral/http\n\n## Install\n**NPM**\n\n`npm install @cerebral/http`\n\n## Description\nThe HTTP provider exposes the ability to do HTTP requests both in actions and directly in signals. It supports **cors** and file upload, with progress handling. It default to **json**, but you can configure it to whatever you want.\n\nRead more about http in the [Cerebral in depth - Http](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_http) article.\n\n```js\nimport {set} from 'cerebral/operators'\nimport {httpGet} from '@cerebral/http/operators'\nimport {state, props, string} from 'cerebral/tags'\n\nexport default [\n  httpGet(string`/items/${props`itemKey`}`),\n  set(state`app.currentItem`, props`result`)\n]\n```\n\nAll factories of HTTP provider supports template tags.\n\n## Instantiate\n\n```js\nimport {Controller, Module} from 'cerebral'\nimport HttpProvider from '@cerebral/http'\n\nconst http = HttpProvider({\n  // Prefix all requests with this url\n  baseUrl: 'https://api.github.com',\n\n  // Any default headers to pass on requests\n  headers: {\n    'Content-Type': 'application/json; charset=UTF-8',\n    'Accept': 'application/json'\n  },\n\n  // When talking to cross origin (cors), pass cookies\n  // if set to true\n  withCredentials: false,\n\n  // Provide a global request timeout for all calls\n  // which can be overwritten for request by providing\n  // a different timeout when doing a request\n  // in actions or operators\n  timeout: 5000\n})\n\nconst app = Module({\n  providers: { http }  \n})\n\nconst controller = Controller(app)\n```\n\nYou can update these default options in an action:\n\n```js\nfunction updateDefaultHttpOptions({http}) {\n  http.updateOptions({\n    // Updated options\n  })\n}\n```\n\n## abort\nYou can abort any running request, causing the request to resolve as status code **0** and sets the type to **abort** on the error object.\n\n```js\nfunction searchItems({input, state, path, http}) {\n  http.abort('/items*') // regexp string\n  return http.get(`/items?query=${input.query}`)\n    .then(path.success)\n    .catch((error) => {\n      if (error.type === 'abort') {\n        return path.abort()\n      }\n\n      return path.error({error})\n    })\n}\n\nexport default [\n  searchItems, {\n    success: [],\n    error: [],\n    abort: []\n  }\n]\n```\n\n## cors\nCors has been turned into a \"black box\" by jQuery. Cors is actually a very simple concept, but due to a lot of confusion of \"Request not allowed\", **cors** has been an option to help out. In HttpProvider we try to give you the insight to understand how cors actually works.\n\nCors has nothing to do with the client. The only client configuration related to cors is the **withCredentials** option, which makes sure cookies are passed to the cross origin server. The only requirement for cors to work is that you pass the correct **Content-Type**. Now, this depends on the server in question. Some servers allows any content-type, others require a specific one. These are the typical ones:\n\n- text/plain\n- application/x-www-form-urlencoded\n- application/json; charset=UTF-8\n\nNote that this is only related to the **request**. If you want to define what you want as response, you set the **Accept** header, which is *application/json* by default.\n\n## errors\n\n### HttpProviderError\n\n```js\nimport {HttpProviderError} from '@cerebral/http'\n\n// Error structure\n{\n  name: 'HttpProviderError',\n  type: 'http | abort | timeout',\n  message: 'Some error message or responseText',\n  response: {\n    result: {}, // Parsed responseText\n    headers: {},\n    status: 200\n  },\n  stack: '...'\n}\n```\n\nThis error is available in the following scenarios:\n\n- Inside an action\n\n```js\nfunction someAction ({http}) {\n  return http.get('/something').catch(error => ...)\n}\n```\n\n- Going down an error path\n\n```js\n[\n  httpGet('/something'), {\n    success: [],\n    error: [\n      // {error: ...}\n    ]\n  }\n]\n```\n\n- To module catch handlers\n\n```js\nconst errorCatched = [\n  // {error: ...}\n  displayError\n]\n\nModule({\n  catch: [\n    [HttpProviderError, errorCatched]\n  ]\n})\n```\n\n## delete\n\n### action\n```js\nfunction someDeleteAction ({http}) {\n  const query = {}\n  const options = {}\n\n  return http.delete('/items/1', query, options)\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpDelete} from '@cerebral/http/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  httpDelete(string`/items/${state`currentItemId`}`),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {httpDelete} from '@cerebral/http/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  httpDelete(string`/items/${state`currentItemId`}`), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n    timeout: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## get\n\n### action\n```js\nfunction someGetAction ({http}) {\n  const query = {}\n  const options = {}\n\n  return http.get('/items', query, options)\n    .then((response) => {\n      return {someResponse: response}\n    })\n    .catch((error) => {\n      return {someError: error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpGet} from '@cerebral/http/operators'\n\nexport default [\n  httpGet('/items'),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\nOn error this will throw to the signal or global catch handler.\n\n### operator with paths\n```js\nimport {httpGet} from '@cerebral/http/operators'\n\nexport default [\n  httpGet('/items'), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n    timeout: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## patch\n\n### action\n```js\nfunction somePatchAction ({http}) {\n  const data = {}\n  const options = {}\n\n  return http.patch('/items/1', data, options)\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpPatch} from '@cerebral/http/operators'\nimport {state, props, string} from 'cerebral/tags'\n\nexport default [\n  httpPatch(string`/items/${props`itemId`}`, state`patchData`),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {httpPatch} from '@cerebral/http/operators'\nimport {state, props, string} from 'cerebral/tags'\n\nexport default [\n  httpPatch(string`/items/${props`itemId`}`, state`patchData`), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n    timeout: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## post\n\n### action\n```js\nfunction somePostAction ({http}) {\n  const data = {}\n  const options = {}\n\n  return http.post('/items', data, options)\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpPost} from '@cerebral/http/operators'\nimport {props} from 'cerebral/tags'\n\nexport default [\n  httpPost('/items', {\n    title: props`itemTitle`,\n    foo: 'bar'\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {httpPost} from '@cerebral/http/operators'\nimport {props} from 'cerebral/tags'\n\nexport default [\n  httpPost('/items', {\n    title: props`itemTitle`,\n    foo: 'bar'\n  }), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n    timeout: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## put\n\n### action\n```js\nfunction somePutAction ({http}) {\n  const data = {}\n  const options = {}\n\n  return http.put('/items/1', data, options)\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpPut} from '@cerebral/http/operators'\n\nexport default [\n  httpPut('/items', {\n    // data object\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {httpPut} from '@cerebral/http/operators'\n\nexport default [\n  httpPut('/items', {\n    // data object\n  }), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n    timeout: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## responses\nThere are two types of responses from the HTTP provider. A **response** and an **error** of type *HttpProviderError*. A **response** will be received on status codes 200-299. Everything else is an **error**.\n\n### response\n```js\n{\n  result: 'the response body',\n  headers: {...},\n  status: 200\n}\n```\n\n### error\n```js\n{\n  name: 'HttpProviderError',\n  type: 'http | abort | timeout',\n  message: 'Some potential error message',\n  result: 'Message or response body',\n  status: 500,\n  headers: {},\n  stack: '...'\n}\n```\n\n## request\n\n```js\nfunction someGetAction ({http}) {\n  return http.request({\n    // Any http method\n    method: 'GET',\n\n    // Url you want to request to\n    url: '/items'\n\n    // Request body as object. Will automatically be stringified if json and\n    // urlEncoded if application/x-www-form-urlencoded\n    body: {},\n\n    // Query as object, will automatically be urlEncoded\n    query: {},\n\n    // If cross origin request, pass cookies\n    withCredentials: false,\n\n    // Any additional http headers, or overwrite default\n    headers: {},\n\n    // A function or signal path (foo.bar.requestProgressed) that\n    // triggers on request progress. Passes {progress: 45} etc.\n    onProgress: null\n  })\n}\n```\n\n## uploadFile\n\n### action\n```js\nfunction someDeleteAction ({http, props}) {\n  return http.uploadFile('/upload', props.files, {\n    name: 'filename.png', // Default to \"files\"\n    data: {}, // Additional form data\n    headers: {},\n    onProgress: 'some.signal.path' // Upload progress\n  })\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpUploadFile} from '@cerebral/http/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpUploadFile('/uploads', props`file`, {\n    name: state`currentFileName`\n  }), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n### operator with paths\n```js\nimport {httpUploadFile} from '@cerebral/http/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpUploadFile('/uploads', props`file`, {\n    name: state`currentFileName`\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n","title":"@cerebral/http"},"mobx-state-tree":{"raw":"# @cerebral/mobx-state-tree\n\nCombine Cerebral with Mobx state-tree.\n\n## Install\n\n`npm install @cerebral/mobx-state-tree`\n\n## Description\nUse the [mobx-state-tree](https://github.com/mobxjs/mobx-state-tree) project as state layer of Cerebral. Use mobx project way of connecting to components and ignore using computed in Cerebral.\n\n\n## Instantiate\n\nInstead of creating the controller from `cerebral`, you create it from this package. Also any modules should be created from this package:\n\n```js\nimport { Controller, Module } from '@cerebral/mobx-state-tree'\n\nconst app = Module({\n  // definition  \n})\n\nexport default Controller(app, {\n  // options\n})\n```\n\n## considerations\nThere are a couple of minor things to consider when using this addon.\n\n1. Any addons defining state, like **@cerebral/useragent**, will not work with this addon, due\nto the missing types definitions. Though for example **cerebral/router** will work as it does not have any state\n\n2. Avoid using **types.reference**, rather define it as a string and do manual lookup. The reason is simply that the debugger does not understand reference, though it works perfectly fine\n\n## state and model\n\nWith Mobx state tree you also define models, in addition to state. You do this directly in your modules:\n\n*modules/app.js*\n```js\nimport { Module } from '@cerebral/mobx-state-tree'\nimport { types } from 'mobx-state-tree'\nimport { set } from 'cerebral/operators'\nimport { state, props } from 'cerebral/tags'\n\nexport default Module({\n  // Define your model as an object,\n  // it will be converted to a mobx model\n  model: {\n    name: types.string,\n  },\n  // Define the initial state as normal\n  state: {\n    name: ''\n  },\n  // Define getters\n  // store.upperName // \"BAR\"\n  getters: {\n    upperName() {\n      return this.name.toUpperCase()\n    }\n  },\n  // Define computed (receives a value to compute)\n  // store.sayHelloTo(\"someName\")\n  computed: {\n    sayHelloTo(name) {\n      return `Hello ${this.name}, I am ${name}`\n    }\n  },\n  signals: {\n    nameChanged: set(state`name`, props`name`)\n  }\n})\n```\n\n**Note!** Instead of exposing views like *mobx-state-tree*, we expose **getters** and **computed**. The reason is to improve the declarativeness of the code. Meaning that when you open the module file you will see all state, getters and computed defined. No file jumping or implementation details in the module file needed.\n\n## accessing state and props in components\n\nFor example using React you will need the package [mobx-react](https://github.com/mobxjs/mobx-react) and use the **provide()** method of the controller:\n\n*main.js*\n```js\nimport React from 'react'\nimport { render } from 'react-dom'\nimport controller from './controller'\nimport { Provider } from 'mobx-react'\nimport App from './components/App'\n\nrender((\n  <Provider {...controller.provide()}>\n    <App />\n  </Provider>\n))\n```\n\n*App.js*\n```js\nimport React from 'react'\nimport { observer, inject } from 'mobx-react'\n\n@inject('store', 'signals')\n@observer\nclass App extends React.Component {\n  render () {\n    const { store, signals } = this.props\n\n    return (\n      <div>\n        <h1>{store.sayHelloTo('Bob')}</h1>\n        <input value={store.name} onChange={event => signals.nameChanged({ name: event.target.value })}\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n","title":"@cerebral/mobx-state-tree"},"storage":{"raw":"# @cerebral/storage\n\n## Install\n**NPM**\n\n`npm install @cerebral/storage`\n\n## Description\nThis module exposes local storage or session storage as a provider,\nwhere it by default parses and serializes to JSON.\n\n## Instantiate\n\n```js\nimport { Module, Controller } from 'cerebral'\nimport StorageModule from '@cerebral/storage'\n\nconst storage = StorageModule({\n  // instance of storage, can be window.localStorage / localStorage,\n  // window.sessionStorage / sessionStorage, or asyncStorage on\n  // react native. Async storage API is automatically managed\n  target: localStorage,\n  // Serializes and parses to JSON by default\n  json: true,\n  // Synchronize state when it changes\n  sync: {\n    'someStorageKey': 'some.state.path'\n  },\n  // Set prefix for storagekey \"somePrefix.someStorageKey\"\n  prefix: 'somePrefix'\n})\n\nconst app = Module({\n  modules: { storage }\n})\n\nconst controller = Controller(app)\n```\n\n## error\n\n### StorageProviderError\n\n```js\nimport {StorageProviderError} from '@cerebral/storage'\n\n// Error structure\n{\n  name: 'StorageProviderError',\n  message: 'Some storage error'\n  stack: '...'  \n}\n```\n\n## get\nGet data from storage.\n\n*action*\n```javascript\nfunction someAction({storage}) {\n  // sync\n  const value = storage.get('someKey')\n  // async\n  return storage.get('someKey')\n    .then(value => ({value}))\n}\n```\n\n*operator*\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {getStorage} from '@cerebral/storage/operators'\n\nexport default [\n  // sync and async\n  getStorage('someKey'),\n  function someAction ({props}) {\n    props.value // Whatever was on \"someKey\"\n  }\n]\n```\n\n## remove\nRemove data from storage.\n\n*action*\n```javascript\nfunction someAction({storage}) {\n  // sync\n  storage.remove('someKey')\n  // async\n  return storage.remove('someKey')\n}\n```\n\n*operator*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {removeStorage} from '@cerebral/storage/operators'\n\nexport default [\n  // sync and async\n  removeStorage(state`currentStorageKey`)\n]\n```\n\n## set\nWrite data to storage.\n\n*action*\n```javascript\nfunction someAction({storage}) {\n  // sync\n  storage.set('someKey', {foo: 'bar'})\n  // async\n  return storage.set('someKey', {foo: 'bar'})\n}\n```\n\n*operator*\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {setStorage} from '@cerebral/storage/operators'\n\nexport default [\n  // sync and async\n  setStorage(state`currentStorageKey`, props`someData`)\n]\n```\n","title":"@cerebral/storage"},"shortcuts":{"raw":"# @cerebral/shortcuts\n\n## Install\n\n**NPM**\n\n`npm install @cerebral/shortcuts`\n\n## Description\nThis is a tiny module that allows you to bind keyboard shortcuts to Cerebral signals.\n\nIt's created using a very nice library called [\"shortway\" by Thiago Santos](https://github.com/thiamsantos/shortway)\n\n## Instantiate\n\n```javascript\n\nimport shortcuts from '@cerebral/shortcuts';\n\nconst controller = Controller({\n  signals: {\n    testSignal: () => console.log(\"shortcut pressed!\")\n  },\n  modules: {\n    shortcuts: shortcuts({\n      \"ctrl+s\": \"testSignal\"\n    })\n  }\n});\n\n```\n","title":"@cerebral/shortcuts"},"router":{"raw":"# @cerebral/router\n\n## Install\n**NPM**\n\n`npm install @cerebral/router`\n\n## Description\nThe router of Cerebral does not affect your view layer. A url change triggers a signal that puts your application in the correct state. Your view just reacts to this state, like any other state change.\n\nRead more about the router in the [Cerebral in depth - Routing](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_routing) article.\n\n## Instantiate\n\n```js\nimport { Controller, Module } from 'cerebral'\nimport Router from '@cerebral/router'\n\nconst router = Router({\n  // Define routes and point to signals\n  routes: [{\n    path: '/',\n    signal: 'app.homeRouted'\n  }],\n\n  // Only react to hash urls\n  onlyHash: false,\n\n  // Set a base url, if your app lives on a subpath\n  baseUrl: null,\n\n  // Will allow none matching routes on same origin to run as normal\n  allowEscape: false,\n\n  // Will make the router not run the initial route\n  preventAutostart: false\n})\nconst app = Module({\n  modules: { router }\n})\n\nconst controller = Controller(app)\n```\n\n## getOrigin\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000/items?foo=bar\", returns \"http://localhost:3000\"\n  router.getOrigin()\n}\n```\n\n## getPath\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000/items?foo=bar\", returns \"/items\"\n  router.getPath()\n}\n```\n\n## getSignalUrl\nAllows you to convert a signal to its corresponding url. This is useful when you actually want to produce the url for a hyperlink etc. To do this you need to create the router in its own file:\n\n*router.js*\n```js\nimport Router from '@cerebral/router'\n\nexport default Router({\n  routes: [{\n    path: '/items/:itemKey',\n    signal: 'items.itemRouted'\n  }]\n})\n```\n\nAnd attaching it to the controller:\n\n*controller.js*\n```js\nimport {Controller} from 'cerebral'\nimport router from './modules/router'\nimport items from './modules/items'\n\nexport default Controller({\n  modules: {items, router}\n})\n```\n\nYou will be able to use the same router instance to produce url based on registered signals:\n\n```js\nimport router from './router'\n\nexport default connect({\n  item: state`items.list.${props`itemKey`}`,\n},\n  function ListItem ({itemKey, item, itemRouted}) {\n    return (\n      <li key={itemKey}>\n        <a href={router.getSignalUrl('items.itemRouted', {itemKey})}>{item.name}</a>\n      </li>\n    )\n  }\n)\n```\n\n## getUrl\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000/items?foo=bar\", returns \"/items?foo=bar\"\n  router.getUrl()\n}\n```\n\n## getValues\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000/items/123?foo=bar\", returns \"{itemId: '123', foo: 'bar'}\"\n  router.getValues()\n}\n```\n\n## goTo\n*action*\n```js\nfunction myAction({router}) {\n  // Go to a new url\n  router.goTo('/items')\n}\n```\n\n*operator*\n```js\nimport {goTo} from '@cerebral/router/operators'\n\nexport default [\n  goTo('/items')\n]\n```\n\n*operator with dynamic URL*\n```js\nimport {state, string} from 'cerebral/tags'\nimport {goTo} from '@cerebral/router/operators'\n\nexport default [\n  goTo(string`/${state`app.currentView`}`)\n]\n```\n\n## redirect\n*action*\n```js\nfunction myAction({router}) {\n  // Go to a new url, replacing current url\n  router.redirect('/items')\n}\n```\n\n*operator*\n```js\nimport {redirect} from '@cerebral/router/operators'\n\nexport default [\n  redirect('/items')\n]\n```\n\n*operator with dynamic URL*\n```js\nimport {state, string} from 'cerebral/tags'\nimport {redirect} from '@cerebral/router/operators'\n\nexport default [\n  redirect(string`/${state`app.currentView`}`)\n]\n```\n\n## redirectToSignal\n*action*\n```js\nfunction myAction({router}) {\n  // Trigger a signal bound to router\n  router.redirectToSignal('app.itemsRouted', {foo: 'bar'})\n}\n```\n\n*operator*\n```js\nimport {redirectToSignal} from '@cerebral/router/operators'\n\nexport default [\n  redirectToSignal('app.itemsRouted', props`payload`)\n]\n```\n\n## reload\n*action*\n```js\nfunction myAction({router}) {\n  // reload the current route\n  router.reload()\n}\n```\n\n*operator*\n```js\nimport {reload} from '@cerebral/router/operators'\n\nexport default [\n  reload\n]\n```\n\n## routes\n```js\nimport {Controller} from 'cerebral'\nimport Router from '@cerebral/router'\n\nconst controller = Controller({\n  modules: {\n    router: Router({\n      routes: [\n        {\n          path: '/',\n          signal: 'app.homeRouted'\n        },\n        {\n          // Params are passed as props to the signal.\n          // Query parameters are also passed as props\n          path: '/projects/:projectId',\n          signal: 'app.projectRouted',\n        }\n      ]\n    })\n  }\n})\n```\n\nWhen a mapped signal triggers it will trigger with a payload if either **params** are defined on the route or the url has a **query**. For example */projects/123?showUser=true* will produce the following payload to the signal, available on the **props** :\n\n```js\n{\n  projectId: '123',\n  showUser: true\n}\n```\n\n## setUrl\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000\", changes to \"http://localhost:3000/foo\"\n  router.setUrl('/foo')\n}\n```\n\n### EXPERIMENTAL\nWe are currently working on functionality that allows you to bind urls to your state, also allowing you to create more complex relationships between your application state and the url. This API is very likely to change, but please feel free to try it out and give us feedback.\n\n#### mapping\nThe `map` property let's you create a mapping between state and\nurl parameters. This works both ways: when you change the state,\nit sets the url from state and when the url changes, it triggers\nthe state changes.\n\nThis automatic mapping is only active if the current url\nis active. Note also that when you use state mapping, the 'signal'\nis optional.\n\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from '@cerebral/router'\n\nconst controller = Controller({\n  modules: {\n    router: Router({\n      routes: [\n        {\n          path: '/projects/:projectId',\n          map: {projectId: state`app.currentProjectId`},\n          signal: 'app.projectRouted',\n        },\n        {\n          path: '/settings/:tab',\n          // whitelist 'focus' query parameter\n          // and 'tab' url parameter\n          map: {tab: props`tab`, focus: props`focus`},\n          signal: 'app.settingsRouted',\n        }\n      ]\n    })\n  }\n})\n```\n\n\n#### computed mapping\n\nYou can use a `Compute` value here to run a computed in order to prepare\nthe value passed to build the url.\n\n```js\nmap: {\n  urlKey: Compute(/* ... */)\n}\n```\n\nIf you use a `Compute` the router cannot map back from the url key to the\nstate and you need to define a reverse map with `rmap`:\n\n```js\nrmap: {\n  'some.state': Compute(props`urlKey`, (urlKey) => /* ... */),\n  'other.state': Compute(props`urlKey`, (urlKey) => /* ... */)\n}\n```\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from '@cerebral/router'\nimport {props, state} from 'cerebral/tags'\n\nconst controller = Controller({\n  modules: {\n    router: Router({\n      routes: [\n        {\n          path: '/settings/:tab',\n          // This maps a complex app state to the `opts` param in\n          // url query.\n          map: {\n            opts: Compute(\n              state`projectId`,\n              state`user.lang`,\n              (projectId, lang) => ({projectId, lang})\n            )\n          },\n          // This parses the url query `opts` into two state values.\n          // It does a 'reverse map' hence the 'rmap' name.\n          rmap: {\n            'projectId': Compute(\n              state`projectId`,\n              props`opts`,\n              (projectId, opts) => opts.projectId || projectId\n            ),\n            'user.lang': Compute(\n              state`validLangs`,\n              props`opts`,\n              (validLangs, opts) => (\n                validLangs[opts.lang] ? opts.lang : 'en'\n              )\n            )\n          }\n        }\n      ],\n      query: true\n    })\n  }\n})\n```\n\n#### Dynamically add routes\n\nApps that use code splitting for security reasons may not want to define all routes until after the user has been verified.\n\nThe `addRoutes()` method allows routes to be added after the app has been initialized.\n\nDefine your initial set of routes as normal:\n```js\nimport Router from '@cerebral/router';\n\nexport default Router({\n  routes: [\n    { path: '/', signal: 'homeRouted' },\n    { path: '/login', signal: 'loginRouted' }\n  ]\n});\n```\n\nThen later you can call `addRoutes`:\n```js\nimport router from './router';\n\nrouter.addRoutes([\n  { path: '/now-you-see-me', signal: 'hiddenModule.hiddenRouted' }\n]);\n```\n\nWhen used together with code splitting and `controller.addModule()` you can dynamically add functionality to a running cerebral application.\n\nThe only gotcha is that you might need to refresh the current route when reloading the app. Due to the order of events, the router may fire before the routes have loaded.\n```js\n// app init signal\nimport {reload} from '@cerebral/router/operators'\nimport checkAuthToken from '../actions/checkAuthToken'\nimport addExtraRoutes from '../actions/addExtraRoutes'\n\nexport default [\n  checkAuthToken, {\n    valid: [\n      addExtraRoutes,\n      reload // ensure that the route which was added after app was loaded is called\n    ],\n    invalid: []\n  }\n]\n```\n","title":"@cerebral/router"},"useragent":{"raw":"# @cerebral/useragent\n\n## Install\n\n**NPM**\n\n`npm install @cerebral/useragent`\n\n## Description\nThe useragent module puts information about the browser into your state tree, and it also updates this information when this information changes.\n\n- UA parser: browser and device\n- Window: size & orientation\n- Media queries\n- Feature detection\n- Internet connectivity\n\n## Instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport Useragent from '@cerebral/useragent'\n\nconst controller = Controller({\n  modules: {\n    useragent: Useragent({\n      // Use CSS media queries to determine\n      // custom sizes available in your model.\n      // They will be toggle between true/false in your\n      // model\n      media: {\n        small: '(min-width: 600px)',\n        medium: '(min-width: 1024px)',\n        large: '(min-width: 1440px)',\n        portrait: '(orientation: portrait)'\n      },\n\n      // store all feature tests in model\n      feature: true,\n\n      parse: {\n        // parse useragent.browser from ua string\n        browser: true,\n        // parse useragent.device from ua string\n        device: true\n      },\n\n      // check the docs at: https://github.com/HubSpot/offline#advanced\n      offline: {\n        checkOnLoad: false,\n        interceptRequests: true,\n        reconnect: {\n          initialDelay: 3,\n          delay: 1.5\n        },\n        requests: false\n      },\n\n      // update window size on resize\n      window: true\n    })\n  }\n})\n```\n","title":"@cerebral/useragent"}},"resources":{"index":{"raw":"# Boilerplates\n\n## create-react-app\n\nFacebook released a boilerplating tool for React, called [create-react-app](https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html). As a beginner it can be a good idea to create a project with create-react-app first and install Cerebral as instructed in [Install Cerebral](/docs/introduction/install.html).\n\n## saitodisse/cerebral2-boilerplates\n\nVarious scripts that uses [create-react-app](https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html), yarn and some shell script to start a cerebral project based on cerebral's official examples: tutorial, demo, forms-demo and todomvc. (_tested on Linux, may work on Mac_)\n","title":"Boilerplates"},"migration":{"raw":"# Migration\n\nWhen migrating from 1.x to 2.x you need to take the following under consideration.\n\n- There are no models left to choose from. Cerebral now comes with one model.\n- Services have been removed in favor of function-tree/providers.\n\n## Controller\nInstead of choosing your model and connecting to the *Controller* as in 1.x as shown below\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nconst controller = Controller(Model({\n  // You can add some initial state here if you want\n}))\n\nexport default controller\n```\n\nYou would simply do the following in 2.x\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {\n    // You can add some initial state here if you want\n  }\n})\n\nexport default controller\n```\n\n**controller.getSignals()** is removed from 2.x so favor **controller.getSignal('some.signal')** instead.\n\n## Modules\nIn 1.x you would have done something like this\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  home: Home,\n  admin: Admin\n})\n\nexport default controller\n```\n\nIn 2.x the modules are defined along with the controller\n\n```js\nimport {Controller} from 'cerebral'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller({\n  modules: {\n    home: Home(),\n    admin: Admin()\n  }\n})\n\nexport default controller\n```\n\nSub-modules can be defined by each module in the same way (see below).\n\nIn 1.x you would create your own module like this\n\n```js\n// 1.x\nexport default module => {\n  module.addState({\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  })\n\n  module.addSignals({\n    newItemTitleSubmitted: submitNewItemTitle\n  })\n}\n```\n\naddState, addSignals have been removed, so in 2.x you simply return an object\n\n```js\n// 2.x\nexport default {\n  state: {\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  },\n  modules: {\n    subModule: SubModule()\n  },\n  signals: {\n    newItemTitleSubmitted: submitNewItemTitle\n  }\n}\n```\n\n## Operators\nThe biggest change to Cerebral 2.x is the operators. You can read more about them in the Operators docs. They have become very powerful and you can create your own operators. Operators in Cerebral 2.x has been moved into core Cerebral. You can still use the old operators if you want by installing them via npm.\n\n```js\nnpm install cerebral-operators\n```\n\nThe new operators now use tagged template literals and you can reduce number of actions and instead use the new operators. Here is a quick sample. As you can see you import them from 'cerebral/operators'\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  set(state`foo.bar`, props`bar`)\n]\n```\n\nOther operators include: wait, when, equals, debounce, push, pop, shift, toggle, unset, splice\n\n## Signals\nYou handle signals mostly the same way as in 1.x. You can describe signals in a module or in the controller directly.\n\n### 1.x\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral-model-immutable'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller(Model({}))\n\ncontroller.addSignals({\n  buttonClicked: doSomething,\n  fieldChanged: { immediate: true, chain: updateField }\n})\n```\n### 2.x\n```js\nimport {Controller} from 'cerebral'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller({\n  signals: {\n    buttonClicked: doSomething,\n    fieldChanged: updateField\n  }\n})\n```\n\nOne note when using signals is that the **immediate** option is gone. This keeps the api cleaner.\n\n## Actions\nSince cerebral 2.x is using **function-tree** under the hood we have other, more powerful options than before. The state is the same, but output is gone and input is renamed to props. You can just return an object from the action that will be available in the props for the next action. You can also return a **path** that is a new concept in Cerebral 2.x and outdates output. **path** is used to determine the execution path for your chain. You do no longer have services as an argument in the context, use providers instead.\n\n### 1.x\n```js\nfunction myAction({props, state, output, services}) {\n\n}\n```\n\nIn 2.x you have the following. Instead of services you hook up providers that supersedes services.\n\n```js\nfunction myAction({props, state, path /*, myProvider, otherProvider */ }) {\n\n}\n```\n\nWhen you wanted to output to paths in 1.x you would do something like this\n```js\nfunction myAction({state, output}) {\n  if (state.get('app.isAwesome')) {\n    output.awesome()\n  } else {\n    output.notSoAwesome()\n  }\n}\nmyAction.outputs = ['awesome', 'notSoAwesome']\n```\n\nWith the new **path** concept this is simpler. In 2.x you would just do what is stated below. Please note the **return path...**. The same is true with promises. They need to be returned.\n\n```js\nfunction myAction({state, path}) {\n  if (state.get('app.isAwesome')) {\n    return path.awesome()\n  } else {\n    return path.notSoAwesome()\n  }\n}\n```\n\nIf you don't want to take another path in the execution tree you could return a new object that would be available in the props object.\n\n```js\nfunction myAction({state, path}) {\n  return {\n    someData: 'Some new data available at output.someData'\n  }\n}\n```\n\nWhen doing async operations you would do something like this in 1.x\n\n```js\nfunction myAction({output}) {\n  setTimeout(() => {\n    output({ /* optional output */ }) // or output.pathName({ /* optional output */ })\n  }, 1000)\n}\n\nmyAction.async = true\n```\n\nIn Cerebral 2 you you must resolve or reject a returned promise.\n\n```js\nfunction myAction({path}) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({ /* optional output */ }) // or resolve(path.pathName({ /* optional output */ }))\n    }, 1000)\n  })\n}\n```\n\nIn 1.x you could set a path that wasn't defined yet in the state tree. Let's say your state looked like this.\n\n```js\n{\n  app: {\n    nodes: {}\n  }\n}\n```\n\nYou could do this in an action.\n\n```js\nfunction myAction({state}) {\n  state.set('app.nodes.some.state.more', {updated: true})\n}\n```\n\nWith 2.x this is no longer possible. It's easy to mistype paths and therefore this option is no longer available. Your paths need to be in place before setting values to them.\n\nWhen using computed data in an action you could call **state.computed(myComputed())** in the action. This has changed in 2.x in favor of\n**state.compute(myComputed)**. You can also pass props to the compute function.\n\n```js\nfunction myAction({state}) {\n  state.compute(someComputed)\n  state.compute(someComputed.props({foo: 'bar'}))\n}\n```\n\nThis works the same in context for 2.x\n\n```js\nconnect({\n  foo: someComputed,\n  foo2: someComputedFactory({foo: 'bar'})\n})\n```\n\n## Providers (outdates services)\n\nIn 1.x you could add services that would be available to you in the actions. Typically, you would do something like this in 1.x\n\n```js\nimport someExternalApi from 'some-external-api'\n\nexport default (options = {}) => module => {\n\n  if (!options.apiKey) {\n    throw new Error('This service needs an apiKey')\n  }\n\n  module.addServices({\n    connect() {\n      return someExternalApi.connect({\n        apiKey: options.apiKey\n      })\n    }\n  })\n\n}\n```\n\nIn 2.x you would use providers instead.\n\n```js\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  providers: [\n    ContextProvider({\n      axios\n    })\n  ]\n})\n```\n\nor manually\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  provider(context) {\n    context.myProvider = {\n      doSomething() {}\n    }\n    return context\n  }\n})\n```\n\nNow instead of having services in the context object in an action you would have the **axios** object.\n\n```js\nfunction myAction({axios}) {\n\n}\n```\n\n## Views\nHow you import view specific packages has changed. In 1.x you would import Container like this.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral-view-react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x you would not import the Container from another package.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nThe same is true when connecting Cerebral to your component. In 1.x you would import it like this.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral-view-react'\n\nexport default connect({\n  isLoading: 'app.isLoading'\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 2.x you would have to use a different import.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 1.x you would first connect state, then signals as separate arguments in connect. In Cerebral 2.x these are combined, tags are used to differentiate between state, signals and props.\n\n```js\n// 2.x\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {props, state, signal} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`,\n  item: state`items.${props`itemId`}`,\n  someSignal: signal`app.someSignal`\n}.\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIf you really want all signals in props as in 1.x you can set this as an option in the controller.\n\n```js\n// 2.x\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  options: {\n     signalsProp: true\n   }\n})\n```\n\n\n##  Model\nThe following functions have been removed from Cerebral 2.x when using state inside an action\n\n- logModel\n- export\n- findWhere\n- keys\n- import\n- toJs\n- toJson\n\n## Strict render mode\nTo setup strict render mode in 1.x for React was specified as follows.\n\n```js\nrender(\n  <Container controller={controller} strict>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x this is the only mode\n\n## Devtools\nThe devtools has changed as well. Go to chrome store and install cerebral2 debugger. The setup has slightly changed from 1.x to 2.x as well as the import.\n\n### 1.x\n```js\nimport Controller from 'cerebral'\nimport Model from 'cerebral/model/immutable'\nimport Devtools from 'cerebral-module-devtools'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools()\n})\n\nexport default controller\n```\n\n### 2.x\n```js\nimport Controller from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools(),\n  modules: {\n    ...\n  }\n})\n\nexport default controller\n```\n\n## Router\nThe router now defines its routes with an array\n\n### 1.x\n```js\nimport Controller from 'cerebral'\nimport Model from 'cerebral/model/immutable'\nimport Router from 'cerebral-module-router'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  modules: {\n    router: Router({\n      routes: {\n        '/': 'appRouted'\n      }\n    })\n  }\n})\n\nexport default controller\n```\n\n### 2.x\n```js\nimport Controller from 'cerebral'\nimport Router from '@cerebral/router'\n\nconst controller = Controller({\n  modules: {\n    router: Router({\n      routes: [{\n        path: '/',\n        signal: 'appRouted'\n      }]\n    })\n  }\n})\n\nexport default controller\n```\n","title":"Migration"},"articles":{"raw":"# Articles\n- [Business logic as a data structure](https://www.jsblog.io/articles/christianalfoni/business_logic_as_a_data_structure)\n- [Function-Tree](http://www.christianalfoni.com/articles/2017_04_16_The-second-case-for-function-tree)\n- [Cerebral 2](http://www.christianalfoni.com/articles/2017_03_19_Cerebral-2)\n- [The story of Cerebral](http://medium.com/p/5793c08db2cc)\n- [An unlikely success story](https://gist.github.com/christianalfoni/b08a99faa09df054afe87528a2134730)\n- [CerebralJS - Gentle introduction](https://dev.to/reflog/cerebraljs)\n","title":"Articles"},"videos":{"raw":"# Videos\n- [Ducky architecture](https://youtu.be/uXlxNJfGKjU?t=4m19s)\n- [Fingerprint analysis](https://youtu.be/iKkGg8UR514?t=58m41s)\n- [Car dealer provision system](https://youtu.be/iKkGg8UR514?t=1m37s)\n","title":"Videos"},"projects":{"raw":"# Cerebral projects\n- [Codesandbox](https://www.codesandbox.io). A bin service using Webpack ([Source Code](https://github.com/CompuIves/codesandbox-client/tree/master/packages/app/src/app)).\n- [Unity connect](https://connect.unity.com/). The Unity social platform\n- [Projects overview](https://github.com/cerebral/cerebral/issues/713). A github issue with multiple projects (images)\n- [rehace](https://www.npmjs.com/package/rehace-github-magnolia). A CMS component/controller library\n","title":"Cerebral projects"}},"migration":{"index":{"raw":"# 4.0\n\nThese are the constructs that Cerebral consists of:\n\n```js\nimport { Controller, Module, Provider, Compute, CerebralError } from 'cerebral'\n```\n\n## Module\nThe module is how you structure your application.\n\n```js\nconst app = Module({\n  state: {},\n  signals: {},\n  providers: {},\n  modules: {},\n  catch:[]\n})\n\n// Or callback\nconst app = Module(({name, path, controller}) => ({\n  state: {}\n}))\n```\n\n1. Providers are now an object instead of an array. This makes more sense as providers needs a name and we do not need this `provide` factory:\n\n```js\nconst app = Module({\n  state: {},\n  providers: {\n    http: HttpProvider({})\n  }\n})\n```\n\n2. The only way to `catch` an error now is at the module level. Errors propagate up to parent modules if not caught. Meaning there is no signal specific error catching or \"global\". \"Global\" would be your root level module.\n\n```js\nconst app = Module({\n  state: {},\n  catch: [\n    [HttpProviderError, sequences.catchHttpError]\n  ]\n})\n```\n\n[Documentation](/docs/api/module)\n\n## Controller\nThe controller takes a module as first argument, and other options as a second argument.\n\n```js\nconst controller = Controller(rootModule, {\n  devtools: null\n})\n```\n\nThe same goes for server side controller.\n\n[Documentation](/docs/api/controller)\n\n## Provider\nProviders will now have a stronger concept. The concept is being the API between your application and your tools of choice. It can only be defined in one way, an object with methods. This makes things consistent and also enforces the idea that you think of a provider as a \"bridge\" between your app and the tools your are using.\n\n```js\nconst myProvider = Provider({\n  foo() {}\n})\n```\n\nYou can point to the existing context using `this.context`. It works this way to simplify with just one API surface and we can do prototypal optimizations under the hood.\n\n```js\nconst api = Provider({\n  getUser() {\n    return this.context.http.get('/user')\n  }\n})\n```\n\nAll providers defined this way is automatically optimized and wrapped for debugger purposes. If you just want to use a 3rd party tool directly, you can still do that by just attaching it:\n\n```js\nModule({\n  providers: { uuid }\n})\n```\n\n[Documentation](/docs/api/providers)\n\n## Compute\n\nThis is just a change to be consistent with the other APIs:\n\n```js\nconst myComputed = Compute(state`foo`, (foo) => ())\n```\n\n[Documentation](/docs/api/compute)\n\n## CerebralError\nTo more easily create different error types you can now define your errors by extending the CerebralError:\n\n```js\nimport { CerebralError } from 'cerebral'\n\nexport class AppError extends CerebralError {}\nexport class ApiError extends CerebralError {}\n```\n\n[Documentation](/docs/api/error)\n\n## Module state changes\nYou can point to the module to make state changes on module executing the signal:\n\n```js\nfunction myAction ({ module }) {\n  module.set('foo', 'bar')\n}\n```\nYou can now use a `module` tag to point to the state of the module running the signal:\n\n```js\n[\n  set(module`foo`, 'bar')\n]\n```\n\n[Documentation tags](/docs/api/tags)\n[Documentation state](/docs/api/state)\n\n## Testing\nThe `CerebralTest` API now takes a Module as first argument.\n\n```js\nimport { CerebralTest } from 'cerebral/test'\nimport app from './src/app' // A Module\n\nCerebralTest(app)\n```\n\n## Routing\nSince you now use a root `Module`, the router will need to be added there.\n\n```js\nimport { Controller, Module } from 'cerebral'\nimport router from './router' // Instance of the router module\n\nconst rootModule = Module({\n  modules: {\n    router\n  }\n})\n\nconst controller = Controller(rootModule)\n```\n\n## Migration\n\n1. Change controller configuration to take in a top level module\n2. Wrap all modules in Module constructor\n3. Change configuration of providers to use object\n4. Change any custom providers to use the Provider factory\n5. Rename use of `compute` to `Compute`\n6. Any error catching now needs to be at module level without `new Map(...)`\n7. Recommended to extend any errors that can be caught from `CerebralError`, as you get serialization out of the box\n8. Change out any `CerebralTest` argument with a `Module`\n","title":"4.0"}}}