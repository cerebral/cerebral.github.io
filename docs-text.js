{"get_started":{"index":{"raw":"# Cerebral\n\n> Welcome to the BETA\n\nThe **Cerebral 2.0** project is now officially in Beta. It is already running in production on the [webpackbin](https://www.webpackbin.com) project and other non open source projects. A release article, comparing Cerebral to Mobx and Redux, can be [read here](http://www.christianalfoni.com/articles/2017_03_19_Cerebral-2). Have fun looking through the docs and the tutorial, and please let us know if you need any help or have questions. Our community is hanging out on [Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n\n## Install\nTo install Cerebral you need to use the Node Package Manager. NPM is part of [Node](https://nodejs.org/en/), so please install that on your computer first. You should install Node version 5 or later. If you are not familiar with Node and/or Webpack it can be a good idea to start out with [the tutorial](/docs/developer_guide/index.html).\n\nTo install Cerebral BETA you have to explicitly install Cerebral and its dependency:\n\n**NPM**\n\n`npm install cerebral@next --save --save-exact`\n\n**YARN**\n\n`yarn add cerebral@next --exact`\n\n\n## Choosing a view type\nCerebral technically can use any view layer. Currently it officially supports [React](https://facebook.github.io/react/) and [Inferno](http://infernojs.org/). From a Cerebral perspective they have the exact same API, you just have to choose to import from **cerebral/react** or **cerebral/inferno**. For specific API differences of the two view libraries please check their documentation.\n\nChoose React if you want a huge ecosystem of shared components and documentation. Inferno is faster than React and is recommended to be used when you do not depend heavily on 3rd party components.\n\n**NPM**\n\n`npm install react react-dom babel-preset-react --save`\n\n`npm install inferno inferno-component babel-plugin-inferno --save`\n\n**YARN**\n\n`yarn add react react-dom babel-preset-react`\n\n`yarn add inferno inferno-component babel-plugin-inferno`\n\n## Hello world\n*controller.js*\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {\n    title: 'Hello world'\n  }\n})\n\nexport default controller\n```\n\n*App.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`\n},\n  function App ({title}) {\n    return (\n      <h1>{title}</h1>\n    )\n  }\n)\n```\n\n*main.js*\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\nimport controller from './controller'\nimport App from './App'\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n## Swag store\nYou might get to the point where a Cerebral coffee cup at work, a Cerebral t-shirt going to a conference or a Cerebral notebook seems like fun... head over to [the swag store](https://cerebral.threadless.com/). It also brings some income to the Cerebral organization which will be spent on getting people together :-)\n","title":"Cerebral"},"the_architecture":{"raw":"# The architecture\n\nCerebral is based on the simple concept of three things your application does in order to function. **Store state**, **render state** and **update state**.\n\n## Store state\nWhere to store the state of an application is a highly debated subject. Should we allow the components to store state? Should we have multiple models? Stores? Reducers? Services? There are many concepts that can store state. In Cerebral you store all your state in \"a single state tree\". That means you do not create classes or other abstractions around state, it is all basically one big object of plain JavaScript types. Objects, arrays, strings, numbers and booleans:\n\n```js\n{\n  auth: {\n    isLoggedIn: false,\n    user: {}\n  },\n  posts: {\n    list: [],\n    selectedPostIndex: 0\n  }\n}\n```\n\nWith this approach we get some benefits not possible with other approaches.\n\n### Simple and consistent API\nTypically a state update changes a value, pushes an item in a list or merges an object into another. With a single state tree we can create an API that does exactly that:\n\n```js\nstate.set('user.prefs.style', 'dark')\nstate.push('user.friends', 'Joe')\nstate.merge('user.info', {\n  email: 'cheetah@jungle.com',\n  name: 'Cheetah'\n})\n```\n\nWith a single state tree we can point to parts of the state using paths (the first argument). We use dot notation to point to nested paths, like **auth.user.name**.\n\n### Optimized rendering\nCerebral does not look at the updates in your application as \"value updates\", but as \"path updates\". This allows Cerebral to make optimizations not possible in other frameworks:\n\n1. There is no need for immutability in Cerebral because a change to a path means that any component depending on that path should render (no value comparison). In applications with large data structures immutability has a high cost. There is no need to hack objects and arrays to observe changes to them either. There is nothing special about the state you put into Cerebrals state tree\n2. Since there is no value comparison in Cerebral it uses what we call **strict render**. This allows us to do render optimizations not possible with other solutions. For example you can say that a component depending on a list is only interested in added/removed items of the list or if the list itself is being replaced\n\n### Visualize the entire app state\nWhen the state of the application is a single object we can use an object inspector to visualize the whole state of your application. With the Cerebral debugger it is easy to build a mental image of application state. You can even make changes directly to state to see how it affects the view layer.\n\n\n## Render state\nSince Cerebral stores all the state of the application in a single state tree we need a way to expose that state to the components. In some frameworks this is done by passing the whole model or collection of models/stores from the top of the application and down from one component to the next. This can become very tedious and fragile as all nested components completely depend on their parent. In Cerebral the state of the application is directly connected to each component:\n\n```js\nconnect({\n  userName: state`app.user.name`\n},\n  function User(props) {\n    props.userName // \"some name\" (value stored in 'app.user.name')\n  }\n)\n```\n\n**connect** tells Cerebral that the component is interested in a path where the user name happens to be. When that path changes the component will render. The component is now completely independent of other components. You can move it wherever you want in the component tree and it will still work.\n\n## Update state\nThis is where Cerebral really differs from other approaches to application development. Updating the state of an application can be anything from:\n\n- flipping a **true** to a **false**\n- setting some value, like a filter\n- reading (and storing) something in local storage\n- requesting data from the server and, depending on the status code of the response, do something with that response which might lead to new requests and/or setting up a listener for data on the server\n- etc...\n\nThe point is, updating state can be a very complex flow of operations. This is often where spaghetti code comes from and we use abstractions to hide it. The problem with abstractions is that it is very difficult to understand how things actually work and it becomes more difficult to make changes.\n\nTo handle everything from a simple toggle to very complex operations, Cerebral has the concept of **signals**. Signals allows you to compose functions together into a flow that is not only about the \"happy path\" but properly takes the actual paths of execution into account, them being errors or other reasons to diverge execution. You can define many different execution paths based on whatever you want (a status code, an error, some state, etc). This allows you to write decoupled code, while still bringing everything together in the form of a higher abstraction which greatly helps understanding how things relate to one another (in what order they will run, when they will run, etc). Under the hood, signals are based on [function-tree](https://github.com/cerebral/function-tree), a project that came out of the initial experimentations in the first version of Cerebral.\n\nAnother powerful feature of **signals** (aka function-tree) is that there is the debugger that can track execution and understands when a signal triggers, what functions are run, what state is being updated, what other side effects are triggered and even how these signals are composed together.\n\n## Summary\nThe architecture of Cerebral is driven by the goal to give you insight. The single state tree and the way state is connected to the components all support this vision. Creating a Cerebral application allows you and your team members to never question what actually happens when a page loads, a specific button is clicked, etc. Decoupling of state, components and state updates also makes it an overall better experience when scaling up an application as the components will be just a dumb layer that transforms a given state to a user interface.\n","title":"The architecture"},"debugger":{"raw":"# Debugger\n\nCerebral has a powerful development tool. It knows about all the state in your application, all the state updates, side effects run, state paths currently active in your components and when they render. All the things Cerebral helps you with, it visualizes in the debugger.\n\nBecause Cerebral can run on different environments and you might want to manage multiple apps, the debugger is a standalone application. This also opens up for further helpful tools beyond just debugging. It is an [Electron](https://electron.atom.io/) application that connects to your application through websockets. You can add multiple apps to it and if you are using function-tree on the server you can even merge execution data on client and the server.\n\nDownload and extract the zip for your target OS:\n\n- [Download debugger for MAC](https://docs.google.com/uc?id=0B1pYKovu9UpybHRMRm9YZU10WUU&export=download)\n- [Download debugger for WINDOWS](https://docs.google.com/uc?id=0B1pYKovu9UpyU0lkU2UyWklMV28&export=download)\n- [Download debugger for LINUX](https://docs.google.com/uc?id=0B1pYKovu9UpyWE85UWVHNFRCQkk&export=download)\n\nYou initialize the devtools by adding it to the controller.\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  // You do not want to run the devtools in production as it\n  // requires a bit of processing and memory to send data from\n  // your application\n  devtools: (\n    process.env.NODE_ENV === 'production' ?\n      null\n    :\n      Devtools({\n        // If running standalone debugger. Some environments\n        // might require 127.0.0.1 or computer IP address\n        remoteDebugger: 'localhost:8585',\n\n        // By default the devtools tries to reconnect\n        // to debugger when it can not be reached, but\n        // you can turn it off\n        reconnect: true\n      })\n  )\n})\n\nexport default controller\n```\n\n## Signals\nThe signals tab in the debugger gives you a chronological list of signals triggered. Every signal tells you what actions were run, what mutations were run related to the action and what other side effects like HTTP and Firebase was triggered. You will also see how your signals are composed together in different action groups, parallel execution.\n\n![signals](/images/signals.png)\n\n## Mutations\nThe mutations tab gives you a chronological list of mutations performed. Since signals can be asynchronous, mutations might happen cross signals. In this list you can double click a mutation to time travel to that point in time.\n\n![signals](/images/mutations.png)\n\n## Components\nThe components tab gives you a list of all currently connected components in your app and what state dependencies they have. You also have a list of latest renders. This list contains what paths changed and what components was affected by the change.\n\n![signals](/images/components.png)\n\n## State tree\nThe state tree tab gives you complete overview of the state of your application. You can explore it and make changes to the state directly to see how it affects your application.\n\n![signals](/images/state_tree.png)\n","title":"Debugger"},"resources":{"raw":"# Resources\n\n## Cerebral projects\n- [Webpackbin](https://www.webpackbin.com). A bin service using Webpack\n- [Unity connect](https://connect.unity.com/). The Unity social platform\n- [Projects overview](https://github.com/cerebral/cerebral/issues/713). A github issue with multiple projects (images)\n- [rehace](https://www.npmjs.com/package/rehace-github-magnolia). A CMS component/controller library\n\n## Videos\n- [Ducky architecture](https://youtu.be/uXlxNJfGKjU?t=4m19s)\n- [WASL 3.0 routing](https://youtu.be/iKkGg8UR514?t=46m13s)\n- [Fingerprint analysis](https://youtu.be/iKkGg8UR514?t=58m41s)\n- [Car dealer provision system](https://youtu.be/iKkGg8UR514?t=1m37s)\n\n## Articles\n- [Cerebral 2](http://www.christianalfoni.com/articles/2017_03_19_Cerebral-2)\n- [The story of Cerebral](http://medium.com/p/5793c08db2cc)\n- [An unlikely success story](https://gist.github.com/christianalfoni/b08a99faa09df054afe87528a2134730)\n\n## Source code\n- [Webpackbin](https://github.com/cerebral/webpackbin). The client for Webpackbin\n","title":"Resources"},"counter":{"raw":"# Example: Counter\n\n*controller.js*\n```js\nimport {Controller} from 'cerebral'\n\nfunction increase ({state}) {\n  state.set('count', state.get('count') + 1)\n}\n\nfunction decrease ({state}) {\n  state.set('count', state.get('count') - 1)\n}\n\nconst controller = Controller({\n  state: {\n    count: 0\n  },\n  signals: {\n    increaseClicked: [increase],\n    decreaseClicked: [decrease]\n  }\n})\n\nexport default controller\n```\n\n*App.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  count: state`count`,\n  increaseClicked: signal`increaseClicked`,\n  decreaseClicked: signal`decreaseClicked`,\n},\n  function App ({count, increaseClicked, decreaseClicked}) {\n    return (\n      <div>\n        <button\n          onClick={() => increaseClicked()}\n        > + </button>\n        {count}\n        <button\n          onClick={() => decreaseClicked()}\n        > - </button>\n      </div>\n    )\n  }\n)\n```\n\n*main.js*\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\nimport controller from './controller'\nimport App from './App'\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n","title":"Example: Counter"},"todomvc":{"raw":"# Example: TodoMVC\n\nThis example only shows a commented version of the controller. Please go to [TodoMVC repo](https://github.com/cerebral/cerebral/tree/master/demos/todomvc) to see complete source code.\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\nimport {ContextProvider} from 'cerebral/providers'\nimport uuid from 'uuid'\nimport Router, {redirect} from 'cerebral-router'\n// Providers\nimport StorageProvider from 'cerebral-provider-storage'\n// Operators\nimport {set, toggle, unset, when} from 'cerebral/operators'\nimport {props, state} from 'cerebral/tags'\n// Actions\nimport addTodo from './actions/addTodo'\nimport toggleAllChecked from './actions/toggleAllChecked'\nimport clearCompletedTodos from './actions/clearCompletedTodos'\n\nconst controller = Controller({\n  devtools: Devtools({ remoteDebugger: 'localhost:8787' }),\n  // The router maps urls to signal execution\n  router: Router({\n    onlyHash: true,\n    routes: {\n      '/': 'rootRouted',\n      '/:filter': 'filterClicked'\n    }\n  }),\n  // Providing side effects to the signal execution. ContextProvider\n  // is a simple way to inject any library\n  providers: [\n    StorageProvider({\n      sync: {todos: 'todos'},\n      prefix: 'todomvc'\n    }),\n    ContextProvider({uuid})\n  ],\n  // Initial state\n  state: {\n    newTodoTitle: '',\n    todos: window.localStorage.getItem('todomvc.todos') ? JSON.parse(window.localStorage.getItem('todomvc.todos')) : {},\n    filter: 'all',\n    editingUid: null\n  },\n  // Most of the logic of TodoMVC can be expressed with operators\n  signals: {\n    rootRouted: redirect('/all'),\n    newTodoTitleChanged: set(state`newTodoTitle`, props`title`),\n    newTodoSubmitted: [\n      when(state`newTodoTitle`), {\n        true: [\n          addTodo,\n          set(state`newTodoTitle`, '')\n        ],\n        false: []\n      }\n    ],\n    todoNewTitleChanged: set(state`todos.${props`uid`}.editedTitle`, props`title`),\n    todoNewTitleSubmitted: [\n      when(state`todos.${props`uid`}.editedTitle`), {\n        true: [\n          set(state`todos.${props`uid`}.title`, state`todos.${props`uid`}.editedTitle`),\n          unset(state`todos.${props`uid`}.editedTitle`),\n          set(state`editingUid`, null)\n        ],\n        false: []\n      }\n    ],\n    removeTodoClicked: [\n      unset(state`todos.${props`uid`}`)\n    ],\n    todoDoubleClicked: [\n      set(state`todos.${props`uid`}.editedTitle`, state`todos.${props`uid`}.title`),\n      set(state`editingUid`, props`uid`)\n    ],\n    toggleAllChanged: [\n      toggleAllChecked\n    ],\n    toggleTodoCompletedChanged: [\n      toggle(state`todos.${props`uid`}.completed`)\n    ],\n    todoNewTitleAborted: [\n      unset(state`todos.${props`uid`}.editedTitle`),\n      set(state`editingUid`, null)\n    ],\n    clearCompletedClicked: [\n      clearCompletedTodos\n    ],\n    filterClicked: set(state`filter`, props`filter`)\n  }\n})\n\nexport default controller\n```\n","title":"Example: TodoMVC"}},"developer_guide":{"index":{"raw":"# Introduction\n\nThis developer guide will explain the concepts of Cerebral. The first sections also includes a **tutorial**, meaning that you get introduced to the concept first and then you will be guided through a tutorial using the [Webpackbin](https://www.webpackbin.com) service.\n\nGoing through the tutorials it is highly recommended that you install the [the debugger](/docs/get_started/debugger.html). If you ever get lost or have other questions we are happy to help you on [discord chat](https://discord.gg/0kIweV4bd2bwwsvH). Hope you enjoy it!\n","title":"Introduction"},"state":{"raw":"# State\n\nCerebral uses a single state tree to store all the state of your application. It is just a single object:\n\n```js\n{}\n```\n\nThat's it.\n\nYou will normally store other objects, arrays, strings, booleans and numbers in it. Forcing you to think of your state in this simple form gives us benefits.\n\n1. The state of the application is exposed as simple values. There are no classes or other abstractions hiding the state of your application\n2. The state can be stored on the server, local storage and passed to the debugger. It is what we call **serializable** state\n3. All the state of your application can be inspected through one object\n4. All state is related to a path. There is no need to import and/or pass around model instances into other model instances to access state\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KdACuVE1vrPicewg7fm)\n\nTo define the initial state of any application all we need to do is to add it to our **Controller** in *controller.js*\n\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: Devtools({\n    remoteDebugger: '127.0.0.1:8585'\n  }),\n  state: {\n    title: 'Cerebral Tutorial'\n  }\n})\n\nexport default controller\n```\n\nWhen you save your bin and look at the state tree in the debugger you will see the state added. If it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"State"},"connect":{"raw":"# Components\n\nIn Cerebral you connect state to components where you need it. This give some benefits:\n\n1. Cerebral will optimize the component\n2. The debugger will know about this component and visualize its state dependencies and when it renders\n3. Increased readability as every component explicitly tells you what state and signals it needs and where it gets it from\n4. You can safely move the component wherever you want without breaking chain of props passing\n\nWhen you connect a component like this...\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`\n},\n  function MyComponent ({title}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n      </div>\n    )\n  }\n)\n```\n\n...the component will be registered to the root **Container** component which is used to expose the controller. The *Container* actually has a register of all connected components in your application. This information is passed to the debugger and whenever Cerebral flushes out changes made to different state paths, the *Container* will figure out what components should render.\n\nAll connected components are automatically optimized, meaning that they will only render if a parent component passes a changed prop or the *Container* tells it to render.\n\nYou can also use classes where needed:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`\n},\n  class MyComponent extends React.Component {\n    render () {\n      return (\n        <div>\n          <h1>{this.props.title}</h1>\n        </div>\n      )\n    }\n  }\n)\n```\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KdBDYEXCVwtPoaMAXgJ)\n\nNow let's get that state displayed in our application.\nFirst of all, we need to tell our component (App) to **connect** to the state.\n\nSo please change *App.js* to:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`\n},\n  function App ({title}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>Render state</h2>\n      </div>\n    )\n  }\n)\n```\n\nAnd voil√†, your application should now look exactly the same, only getting the title from the state tree. And this is the essence of creating web applications. We define state and how that state should be displayed in the user interface.\n\nWe used something called a **tag** to define our state dependency. If you are unfamiliar with [template literals and template literal tags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) in JavaScript, you can read about them or just accept their awesome power :)\n\nBut our application does not do much. We have to introduce the concept of change. With the debugger, we can actually force a change to our state and make the UI update. Click the title state in the debugger, change it and hit enter. You will see the application display your changed state.\n\nThanks to...\n```js\nconnect({\n  title: state`title`\n}, ...)\n```\n...we told Cerebral that this component is interested in the value on the path **title**, and we wanted it exposed as **title** to our component as well. Because this component now depends on the **title** state it gets rendered whenever the path has a change.\n\nCongratulations, you have now created application state and exposed it to a component. You have now gained the power of translating the state of the application into something a user can understand. You will notice with Cerebral that this is a very clear separation. You define your application state in Cerebral and you use components to translate this state into a user interface.\n\n### The component signature\nLet us quickly talk about the syntax before moving on. The signature of connect most commonly uses two arguments:\n\n**connect(dependencies, Component)**\n\nWe usually write this out as:\n\n```js\nconnect({\n  title: state`title`\n},\n  function App ({title}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>Render state</h2>\n      </div>\n    )\n  }\n)\n```\n\nWriting out the arguments on multiple lines and with indentation just makes it read better. It is also very nice to read the dependencies of your component first and then what the component does with those dependencies.\n\n### Challenge\n\nIt's time for your first challenge!\n\n- Add another state to the store called *subTitle*\n- Connect *subTitle* to the App component and replace the content of the H2 with that state\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Components"},"signals":{"raw":"# Signals\n\nYou trigger a signal when something happens in your application. For example a button is clicked, but also if a websocket connection receives a message. The signal runs the business logic of your application. You compose together state changes, side effects and other logic in one coherent flow. The signals of Cerebral are named in past tense. So typically you would name a signal **inputChanged** or **mounted**. Going through this guide you will see what benefits this approach gives you. To trigger a signal you call it just like you would call a function, the difference is that you start a function-tree execution.\n\nCerebral uses the [function-tree](https://github.com/cerebral/function-tree) project to implement its signals. A function-tree allows you to define a tree of functions to be executed. In Cerebral world we call the functions in this tree **actions**.\n\nYou can define this execution tree with a single action:\n\n```js\nfunction myAction () {}\n\nexport default myAction\n```\n\nOr you can group them together in a *sequence* using an array:\n\n```js\nfunction actionA () {}\nfunction actionB () {}\n\nexport default [\n  actionA,\n  actionB\n]\n```\n\nIn a sequence Cerebral runs one action after the other synchronously. When an action returns a promise it will hold until the promise resolves and then continue the sequence.\n\n## Parallel execution\nYou can also run these actions in parallel. You do that by using the **parallel** function:\n\n```js\nimport {parallel} from 'cerebral'\n\nfunction actionA () {}\nfunction actionB () {}\nfunction actionC () {}\n\nexport default [\n  parallel([\n    actionA,\n    actionB\n  ]),\n  actionC\n]\n```\n\nIf actionA returns a promise actionB will still be run instantly, meaning that they run in parallel. When both actionA and actionB is done, actionC is run.\n\n## Composing\nActions and a sequence of actions can be composed into other sequences of actions. This is a powerful concept that allows you to decouple a lot of your logic and compose it together wherever it is needed:\n\n```js\nimport otherActions from './otherActions'\n\nfunction actionA () {}\nfunction actionB () {}\n\nexport default [\n  actionA,\n  otherActions,\n  actionB\n]\n```\n\nCerebral will now run this as one signal, first running *actionA*, then whatever is expressed in *otherActions* and then run *actionB* last. The debugger will even show otherActions as its own sequence of actions, meaning that composition is visualized in the debugger. If you want you could even name this otherActions sequence, giving even more debugging information.\n\n## Running a signal\nTo run a signal you can grab it from the controller:\n\n```js\nimport {Controller} from 'controller'\nimport someActions from './actions/someActions'\n\nconst controller = Controller({\n  signals: {\n    somethingHappened: someActions\n  }\n})\n\nconst signal = controller.getSignal('somethingHappened')\nsignal()\n```\n\nThis signal triggers synchronously and you can pass it a payload.\n\n```js\n...\nsignal({\n  foo: 'bar'\n})\n```\n\nThis payload is brought into the signal execution and acts as the **props** of the signal. Typically you will not trigger signals manually this way, but rather from within a component.\n\n```js\nconnect({\n  somethingHappened: signal`app.somethingHappened`\n},\n  function MyComponent (props) {\n    return <button onClick={() => props.somethingHappened()}>Click me</button>\n  }\n)\n```\n\nThe payload passed to a signal is typically the core value types of JavaScript. Object, Array, String, Number or Boolean. It is also possible to pass in some special value types, like files. For a full list of supported value types, check the [state API documentation](../api/state.md).\n\n## Tutorial\n**Before you start,** [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KdBGyGo09NxQfRWSNOb)\n\nDefining state and user interfaces is more about describing how something should look, rather than how it should update. Updates are the tricky part, this is where we usually introduce complexity in our applications.\n\nCerebral allows you to describe updates the same way you describe state and user interfaces, in a declarative manner. We call them **signals** and they will help you handle complexity both in code and in your head.\n\n### Adding a signal\nLet us add a signal to our **Controller** in *controller.js*:\n\n```js\n...\nfunction updateSubtitle ({state}) {\n  state.set('subTitle', 'Updating some state')\n}\n\nconst controller = Controller({\n  devtools:  Devtools({\n    remoteDebugger: '127.0.0.1:8585'\n  }),\n  state: {\n    title: 'Hello from Cerebral!',\n    subTitle: 'Working on my state management'\n  },\n  signals: {\n    buttonClicked: updateSubtitle\n  }\n})\n...\n```\nWe now defined a signal named **buttonClicked**. The signal tells us \"what happened to make this signal run\". What we want to happen when this signal triggers is to update the **subTitle** in our state with a static value. We do this by pointing to our *subTitle* function. Normally you would define this signal in a separate file.\n\nAs you can see functions in a signal receives an argument, which we [destructure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) to grab the *state*. The argument itself is called the **context**. So **state** is on the **context**, as we can see here:\n\n```js\n...\nfunction updateSubtitle ({state}) {\n  state.set('subTitle', 'Updating some state')\n}\n...\n```\n\n### Trigger the change\nPlease take a closer look at *App.js*:\n\n```js\n...\nconnect({\n  title: state`title`,\n  subTitle: state`subTitle`\n},\n  ...\n)\n```\nAs you can see the App-Component depends on **subTitle**. That means it will render automatically whenever **subTitle** changes.\n\nTo trigger the signal we need to wire up a click-handler on a button and add our signal **buttonClicked** to the **connect(..)** method:\n\n*App.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  buttonClicked: signal`buttonClicked`\n},\n  function App ({title, subTitle, buttonClicked}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>{subTitle}</h2>\n        <button onClick={() => buttonClicked()}>\n          Update state\n        </button>\n      </div>\n    )\n  }\n)\n```\nNow click it and take a look at the debugger. You will see the debugger list the execution of the signal, with information about what happened. This is also a tool the Cerebral debugger provides to give you insight into your application. Very handy for example when you need to dig into a **complex application** after not touching it for a long time, introduce a new team member to the application or debug complex execution flows.\n\nSo changing the *subTitle* is kind of a silly state change on a button click. Let's introduce a very simple \"Toast\"-Component. It has already been added for you on the next chapter.\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Signals"},"actions":{"raw":"# Actions\n\nA signal runs actions and actions are actually just functions.\n\n```js\nfunction iAmAnAction () {}\n```\n\nThat means you do not need any API to define an action. This makes actions highly testable.\n\nTypically you use actions to change the state of the application or run other side effects.\n\n```js\nfunction iAmAnAction ({props, state}) {\n  state.set('some.path', props.someValue)\n}\n```\n\n```js\nfunction iAmAnAction ({http, path}) {\n  return http.get('/someitems')\n    .then(path.success)\n    .catch(path.error)\n}\n```\n\n## Update props\nYou update the props on the signal by returning an object from the action. This object will be merged with existing props.\n\n```js\nfunction iAmAnAction () {\n  return {\n    newProp: 'someValue'\n  }\n}\n```\n\n## Async\nWhen actions return a promise the signal will hold execution until it is resolved. any resolved values will be merged in with props.\n\n```js\nfunction iAmAnAction () {\n  return new Promise((resolve) => {\n    resolve({\n      newProp: 'someValue'\n    })\n  })\n}\n```\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KdBPZwKFDQKkAcUqRte)\n\nIf you run this bin right away you will see a message popping up after clicking the button.\nNow let us customize the existing **signal** by adding a custom **action** in between the sequence.\n\nSignals can take a props-object which can then be accessed or processed by any subsequent action.\n\nLet us say you have a user input which should get written to state.\nAs we now know, the correct way to write any state change is to use **signals** with **actions**.\n\nJust like we are able to grab the **state** from the context of an action, we can also grab the **props**. This props object can be populated when a signal triggers and it can be further extended using actions. Any object returned from an action will be merged into the current props and passed to the next action.\n\n### Create an action\nLet us create a new action inside *controller.js* that will take a prop from the signal and add some exclamation marks.\n\n```js\nfunction shoutIt ({props}) {\n  return {\n    message: `${props.message}!!!`\n  }\n}\n```\n\nAs you can see we grabbed the props just like we grabbed the state. The object we return from the action will be merged with the existing props. That means we are overriding the **message** with exclamation marks.\n\nWe also add an action for setting the toast.\n\n```js\nfunction setToast ({state, props}) {\n  state.set('toast', props.message)\n}\n```\n\nThen we wire those actions together in our buttonClicked-**signal**\n\n```js\n...\n{\n  buttonClicked: [\n    shoutIt,\n    setToast\n  ]  \n}\n...\n```\n\n### Passing a payload\nNow we just need to change our button click to actually pass a message:\n\n*App.js*\n```js\n        ...\n        <button onClick={() => buttonClicked({\n          message: 'Please shout me'\n        })}>\n          Update state\n        </button>\n        ...\n```\n\nNow we are ready to test drive our changes. Click the button and you should see the toast message appear with three exclamation marks behind. Take some time to open up the **debugger** and explore the changes you've made. You can track the flow of the props object as it is passed into the action *props:{}* and after the action has excecuted *output: {}*. Keep in mind that the object returned from an action will be merged with the props object and handed over to the next action. You could just as easily use a different property for the shouted message.\n\n### Challenge\n\n- Add another custom action which transforms the props value to Uppercase. You may override existing properties on the props or create a new one\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Actions"},"operators":{"raw":"# Operators\nCreating an action for any kind of state change will be tedious. That is why Cerebral has **operators**. These operators are just functions that return an action for you. There is an operator for every kind of state change, but also other operators controlling time and execution paths. Also other packages in the Cerebral ecosystem has their own operators.\n\n## State changes\nThe most common operators you will use changes the state of your application.\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, 'bar')\n]\n```\n\nWith the help of **tags** we are able to express that we want to set the state path **foo** to have the value **\"bar\"**. We can also use the **props** tag to express that we want to grab the value from the current payload of the signal instead:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, props`foo`)\n]\n```\n\nAnd this is how you go about using operators:\n\n```js\nimport {merge, push, pop} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  merge(state`some.object`, props`newObj`),\n  push(state`some.list`, props`newItem`),\n  pop(state`some.otherList`)\n]\n```\n\n## Time\nYou can control time using operators. For example to hold a signals execution, you can:\n\n```js\nimport {wait} from 'cerebral/operators'\nimport doThis from '../actions/doThis'\nimport doThat from '../actions/doThat'\n\nexport default [\n  doThis,\n  wait(2000),\n  doThat\n]\n```\n\nYou can also do more complex time control using **debounce**.\n\n```js\nimport {set, debounce} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\nimport makeQueryRequest from '../chains/makeQueryRequest'\n\nexport default [\n  set(state`query`, props`query`),\n  debounce(500), {\n    continue: makeQueryRequest,\n    discard: []\n  }\n]\n```\n\n## Paths\nSome operators helps you go down specific paths of execution.\n\n```js\nimport {when, equals} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  when(state`app.isAwesome`), {\n    true: [],\n    false: []\n  },\n  equals(state`user.role`), {\n    admin: [],\n    user: [],\n    otherwise: []\n  }\n]\n```\n\nAs you can see **operators** are a powerful concept that allows you to describe how your application executes and changes its state. Other tools in the Cerebral ecosystem also has its own operators for running side effects like HTTP requests, Firebase requests etc. Most of your application can actually be described with operators.\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KdBHyLJDefteJy0s821)\n\nLet us first change out our actions with an operators instead. Since we did a *set*, we change it out with the **set** operator. Operators also take advantage of the tags. In this case, the first argument uses a tag to target our state. The second argument uses a tag to grab the message from the props passed into the signal.\n\nNow lets add a **wait** operator and another **set** to close our toast message after a few seconds. So go ahead and change our **buttonClicked** signal in *controller.js* to:\n\n```js\n...\nimport {set, wait} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n...\n{\n  buttonClicked: [\n    set(state`toast`, props`message`),\n    wait(4000),\n    set(state`toast`, null)\n  ]\n}\n```\n\nNow when we check again in the debugger you will see all the 3 actions executed when signal *buttonClicked* got triggered.\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Operators"},"factories":{"raw":"# Factories\nFunction factories is a common term in programming. It is basically a function that returns a function:\n\n```js\nfunction createHelloMessage (name) {\n  function helloMessage () {\n    console.log(`Hello there ${name}`)\n  }\n\n  return helloMessage\n}\n\nconst helloBob = createHelloMessage('Bob')\nhelloBob() // Logs: \"Hello there Bob\"\n```\n\nIn Cerebral you will find yourself creating a lot of factories. Factories for creating actions and even factories for creating sequences of actions. Actually the Cerebral **operators** are action and actions sequence factories.\n\n## Action factory\n```js\nfunction hasUserRoleFactory (role) {\n  function hasUserRole ({state, path}) {\n    if (state.get('user.role') === role) {\n      return path.true()\n    }\n\n    return path.false()\n  }\n\n  return hasUserRole\n}\n```\n\nSo this factory can now be used in any sequence:\n\n```js\nimport hasUserRole from '../factories/hasUserRole'\n\nexport default [\n  hasUserRole('admin'), {\n    true: [],\n    false: []\n  }\n]\n```\n\n## Actions sequence factory\n```js\nimport {set, wait} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nfunction showMessageFactory (message, ms) {\n  return [\n    set(state`app.message`, message),\n    wait(ms),\n    set(state`app.message`, null)\n  ]\n}\n```\n\nNow this can be used in any other sequence of actions:\n\n```js\nimport showMessage from '../factories/showMessage'\n\nfunction someAction () {}\n\nexport default [\n  someAction,\n  showMessage('Hello there!', 500)\n]\n```\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KfHVlMgu-OTENr2fH2-)\n\nTo see how **factories** are defined you may also check out the already existing code inside cerebral itself.\nE.g. that is how the **wait** operator looks like:\n\n```js\nfunction waitFactory (ms) {\n  function wait () {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms)\n    })\n  }\n\n  return wait\n}\n```\n\nYou can see that a **factory** is just a function that returns another function which we call **action**. The action itself (wait) returns a promise. This promise is what tells the signal to hold its execution until it is resolved. Because **wait** is quite a common operation it's already included as an operator in the default\n\nLet us create our own custom **showToast** factory. It will return a sequence of actions. As you can see we have moved the operators we defined previously into this array, using the arguments passed into the factory. As an example we want to name this sequence of actions, so instead of using an array we rather use the **sequence** function. They are exactly the same, only the function allows us to pass in a name as the first argument:\n\n```js\nimport {Controller, sequence} from 'cerebral'\n...\nfunction showToast(message, ms) {\n  return sequence('showToast', [\n    set(state`toast`, message),\n    wait(ms),\n    set(state`toast`, null)\n  ])\n}\n...\nconst controller = Controller(...)\n```\n\nWe need to adjust the signal as well:\n```js\nController({\n  signals: {\n    buttonClicked: [\n      showToast(props`message`, 1000)\n    ]\n  }\n})\n```\n\nWhen this now triggers you will see in the debugger the **showToast** sequence composed into our signal definition and it is even named. This is a good practice for very complex flows, but not strictly necessary. Using plain arrays will get you very far.\n\nCongratulations! You have successfully mastered the power of factories. But there are a couple of more concepts that will help you define state changes, jump over to the next chapter to find out more.\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Factories"},"paths":{"raw":"# Paths\nSignals can also express execution paths. For example:\n\n```js\nfunction actionA () {}\nfunction actionB () {}\nfunction actionC () {}\n\nexport default [\n  actionA, {\n    foo: actionB,\n    bar: actionC\n  }\n]\n```\n\nWhen an object is expressed after an action we call that object the paths of the action. The context of the action will have **path** available on its context. For example in this example:\n\n```js\nfunction actionA ({path}) {\n  path.foo // function\n  path.bar // function\n}\n```\n\nWhen the action calls and returns one of these paths, that path will be executed:\n\n```js\nfunction actionA ({path}) {\n  return path.foo()\n}\n```\n\nThis is possible due to Cerebrals static analysis of the signals. It knows exactly how it is going to run before it is executed.\n\nYou can also pass a payload to the path:\n\n```js\nfunction actionA ({path}) {\n  return path.foo({\n    foo: 'bar'\n  })\n}\n```\n\nThis is merged into the *props* and made available to the next actions. If you return a promise from an action you just resolve the path:\n\n```js\nfunction actionA ({path}) {\n  return new Promise((resolve) => {\n    resolve(path.foo({\n      foo: 'bar'\n    }))\n  })\n}\n```\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KdBUBNJyrfqL3c6VHkr)\n\nIn the previous chapter we introduced async actions. But what about the following scenario: \"User gets data async from a server, server responds with either a success or error\". To handle not only the so called *Happy Path* we should also allow our signals to branch out into a different flows depending on the result of the previous action.\n\n### Http Provider\nSo let us build that scenario introducing *cerebral-http-provider*. *cerebral-http-provider* is a simple http-provider which enables you to request data from servers. You could have used any other HTTP library if you wanted to. We have already added it as a configuration of the controller. The concept of **Providers** will be covered in more detail in one of the next chapters.\n\nTo handle any kind of diverging execution in a signal we can use the concept of **paths**. A simple signal using paths and a sample async action named *getData* could look like this:\n\n```js\nController({\n  signals: {\n    submitClicked:[\n      getData, {\n        success:[\n          processResults,\n          showSuccessMessage\n        ],\n        error: showErrorMessage\n      }\n    ]\n  }\n})\n```\n\nWhere *success* and *error* are our **paths**.\n\n### Grabbing a repo\nLet us implement something similar. We are going to grab information about github repos and display it in the toast. We introduce a new tag called **string**. It just evaluates the string, inserting any props or state you have defined in it. So please change your *controller.js* to also contain:\n\n```js\n...\nimport {set, wait} from 'cerebral/operators'\nimport {state, props, string} from 'cerebral/tags'\n...\n{\n  buttonClicked: [\n    showToast(string`Loading data for repo: ${props`repo`}`, 2000),\n    getRepo, {\n      success: showToast(\n        string`\n          How cool is that. ${props`repo`}\n          has ${props`result.subscribers_count`}\n          subscribers and ${props`result.stargazers_count`}\n          stars!\n        `,\n        5000\n      ),\n      error: showToast(\n        string`\n          Ooops something went wrong: ${props`error`}\n        `,\n        5000\n      )\n    }\n  ]\n}\n...\n```\n\nAs you can see you can configure as many and whatever paths you like. Just add an object after an action and the action will know about possible paths to execute.\n\nAlso notice here that we plan our signal before implementing. Typically working in a team you would actually define the signal first and later implement the actions. It is the flow that is important to get right.\n\nThe **getRepo** action can look like this:\n\n```js\n...\nfunction getRepo({props, http, path}) {\n  return http.get(`/repos/cerebral/${props.repo}`)\n    .then(path.success)\n    .catch(path.error)\n}\n\nconst controller = Controller(...)\n```\n\nThe path **success** and **error** are now available inside the action because we defined those paths after the action in the chain. When either **.then** or **.catch** resolves it will call the path function and return it. Last, but not least, we need to pass in a **repo** property on our button click:\n\n*App.js*\n```js\n...\n<button onClick={() => buttonClicked({repo: 'cerebral'})}>\n  Update state\n</button>\n...\n```\n\n### Parallel execution\nBut there is an issue here. Did you notice that the message *Loading data for repo...* is blocking the execution for 2 seconds? It would be nice to indicate to Cerebral that actions can execute in parallel.\n\nReplace your signal with the following snippet:\n\n```js\n...\nimport {Controller, sequence, parallel} from 'cerebral'\n...\n\n{\n  buttonClicked: parallel([\n    showToast(string`Loading data for repo: ${props`repo`}`, 2000),\n    getRepo, {\n      success: showToast(\n        string`How cool is that. ${props`repo`}\n         has ${props`result.subscribers_count`}\n         subscribers and ${props`result.stargazers_count`}\n         stars!\n        `,\n        5000,\n        'success'\n      ),\n      error: showToast(\n        string`\n          Ooops something went wrong: ${props`result.message`}\n        `,\n        5000,\n        'error'\n      )\n    }\n  ])\n}\n```\n\nWhat is happening here? Did you spot the use of **parallel**? This is just like defining a sequence of actions only that the next action will run immediately, even though the previous one returned a Promise.\n\nWe got even more flow control now, telling Cerebral to execute actions/operators in parallel and objects to diverge execution. By reading the signals you get a good understanding what the application will do. And don't forget, you do not even have to look at the code to understand this, the debugger reflects parallel execution, state changes, and even **paths** chosen.\n\n### Handling time\nBut... there is an other issue here. Did you notice that these **showToast** action factories do not cancel each other out? So the initial 2 second wait might close the toast where it was supposed to hold for 5 seconds after a success?\n\nInstead of using **wait**, we can use **debounce**. It is difficult to wrap your head around debounce. Simply said it ensures that whenever we run **showToast**, any pending toast timer will be discarded. But that is not enough, cause we have multiple *showToast* in our signal. So we need this behavior to be shared across them. Whenever **any** *showToast* is called, we want the existing pending toast timer to be discarded. We can do that by creating a shared debounce. So once again, head over to *controller.js* and change it to:\n\n```js\n...\nimport {set, merge, debounce} from 'cerebral/operators'\nimport {state, props, string} from 'cerebral/tags'\n...\nconst toastDebounce = debounce.shared()\nfunction showToast (message, ms) {\n  return sequence('showToast', [\n    set(state`toast`, message),\n    toastDebounce(ms), {\n      continue: [\n        set(state`toast`, null)\n      ],\n      discard: []\n    }\n  ])\n}\n...\n```\n\nCongratulations! Now you know how to control your flow using **paths**. And if you need **parallel actions/operators**, well just use the **parallel** function. You have even gotten insight into very complex control flow using **debounce**.\n\n### Challenge\n\nWe would like you to run two getRepo(...) requests. One to *cerebral/cerebral* and one to *cerebral/addressbar*. So it is a good idea to make *getRepo* a factory instead. On their successes, they should insert their data into the state tree.\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Paths"},"compute":{"raw":"# Compute\nNormally you use state directly from the state tree, but sometimes you need to compute values. Typically filtering lists, grabbing the projects of a user, or other derived state.\n\nCerebral allows you to compute state that can be used in multiple contexts. Let us look at the signature:\n\n```js\nimport {compute} from 'cerebral'\n\nexport default compute(() => {\n  return 'foo'\n})\n```\n\nYou can now use this with **connect**:\n\n```js\nimport computedFoo from '../computedFoo'\n\nconnect({\n  foo: computedFoo\n})\n```\n\nYou can use it with operators in a signal:\n\n```js\nimport computedFoo from '../computedFoo'\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, computedFoo)\n]\n```\n\nOr you can resolve it inside an action if you need to:\n\n```js\nimport computedFoo from '../computedFoo'\n\nfunction myAction ({resolve}) {\n  const foo = resolve.value(computedFoo)\n}\n```\n\nYou can even compose it into a Tag:\n\n```js\nimport computedFoo from '../computedFoo'\nimport {state} from 'cerebral/tags'\nimport {set} from 'cerebral/operators'\n\nexport default [\n  set(state`${computedFoo}.bar`, 'baz')\n]\n```\n\n## Getting data\nCompute can manually grab data related to where it is run. For example in **connect** you have access to both state and properties of the component. In a signal you would have access to state and the props to the signal. You access these manually by combining the **get** argument with a related tag:\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default compute((get) => {\n  return get(state`foo`) + get(props`bar`)\n})\n```\n\nCerebral now knows what paths this computed is interested in and can optimize its need to run again to produce a changed value.\n\n## Composing\nWhat makes compute very powerful is its ability to compose tags and other compute. Any tags you pass as arguments will be passed in as a value to the next function in line. The last argument of the function is always the **get** function.\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nconst computedItemUsers = compute(\n  state`items.${props`itemKey`}`,\n  (item, get) => {\n    return item.userIds.map((userId) => get(state`users.${userId}`))\n  }\n)\n\n// In connect\nconnect({\n  users: computedItemUsers\n})\n```\n\nIt uses the *itemKey* property from the component to grab the actual item. It then grabs each user based on the userIds of the item. You can also compose multiple compute together.\n\n```js\nconnect({\n  item: compute(filteredList, onlyAwesome)\n})\n```\n\nHere *filteredList* returns a list of filtered items, where *onlyAwesome* expects to receive a list and filters it again.\n\n```js\ncompute((list) => {\n  return list.filter((item) => item.isAwesome)\n})\n```\n\nIt is possible to combine tags and functions as many times as you would like:\n\n```js\ncompute(\n  state`currentItemKey`,\n  (currentItemKey, get) => {\n    return get(state`item.${currentItemKey}`)\n  },\n  state`isAwesome`,\n  (item, isAwesome) => {\n    return item.isAwesome === isAwesome\n  }\n)\n```\n\nTypically you can get away with most things using Tags, but compute will help you with any other scenarios where more \"umph\" is needed.\n\n## Factory\nTypically you will create computed factories. Just think of compute as a function that is able to resolve tags and other computed. for example:\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default (type) => {\n  return compute(\n    state`items`,\n    (items) => {\n      return items.filter(item => item.type === type)\n    }\n  )\n}\n```\n\nThis could now be used as:\n\n```js\nconnect({\n  filteredItems: filterCompute('typeA')\n})\n```\n\nBut we could be smarter about this. By changing it out like:\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default (typeValue) => {\n  return compute(\n    typeValue,\n    state`items`,\n    (type, items) => {\n      return items.filter(item => item.type === type)\n    }\n  )\n}\n```\n\nNow we evaluate the value passed in, meaning it could also be a tag:\n\n```js\nconnect({\n  filteredItems: filterCompute(props`type`)\n})\n```\n\n## Tutorial\n\n**Before you start,** [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KdBaa45GzVJFOxU69Gp)\n\nIn our application we want to sum up the number of stars. We have already implemented a naive approach, which we are going to refactor. We created an action which adds the count together:\n\n```js\nfunction setStarsCount ({state}) {\n  state.set('starsCount',\n    state.get('repos.cerebral.stargazers_count') +\n    state.get('repos.addressbar.stargazers_count')\n  )\n}\n```\n\nThis is a perfectly okay approach for our simple scenario, but computing state like this can be tedious in large applications. We might want to use this state multiple places in our application, and we want to make sure it is the same wherever we use it.\n\n### Computing\nIn Cerebral, we can automatically compute state by using **compute**. It is basically a function that takes any number of arguments to produce a value. Let us look at how it works with our scenario. Please add another file called *starsCount.js* to the bin and copy the following snippet into it:\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default compute(\n  state`repos`,\n  (repos) => {\n    return Object.keys(repos).reduce((currentCount, repoKey) => {\n      return currentCount + repos[repoKey].stargazers_count\n    }, 0)\n  }\n)\n```\n\nWe depend on our repos state. Then we just count the stars and return it. When the compute is used with a component it will automatically track whatever dependencies it has and only runs when any of those dependencies change.\n\nNow we would like to use our computed in the signal, and we want to show the count in our component.\n\n### Replacing with computed\nLet us remove the **setStarsCount** action and refactor our signal to instead grab the repos first, then we update the state in one go. This just to show you different strategies.\n\nCheck out the refactoring of our *getRepo* action. The factory is no longer returning paths. We just return a payload to the signal if the request is successful. That means any errors will be thrown from the HTTP provider.\n\n```js\n...\nfunction getRepo (repoName) {\n  function get ({http}) {\n    return http.get(`/repos/cerebral/${repoName}`)\n      .then((response) => {\n        return {[repoName]: response.result}\n      })\n  }\n\n  return get\n}\n...\n```\n\nWe can change now the signal to look like:\n\n```js\n...\nimport HttpProvider, {HttpProviderError} from 'cerebral-provider-http'\nimport starsCount from './starsCount'\n...\n{\n  buttonClicked: {\n    signal: [\n      showToast(string`Loading data for repos...`),\n      parallel([\n        getRepo('cerebral'),\n        getRepo('addressbar')\n      ]),\n      set(state`repos.cerebral`, props`cerebral`),\n      set(state`repos.addressbar`, props`addressbar`),\n      showToast(string`The repos have ${starsCount} stars`, 5000, 'success')\n    ],\n    catch: new Map([\n      [HttpProviderError, showToast(string`Error: ${props`error.message`}`, 5000)]\n    ])\n  }\n}\n...\n```\n\nWe have now defined our signal in two parts. The happy path and what to do if an error is thrown (catch). We use a JavaScript [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) to define what errors we are interested in being thrown, in this case an http provider error, and what logic to run when that happens. That means all other errors will be thrown to console as normal.\n\nNote here that we also updated the *toast* to allow no time to be passed in, causing it to stick.\n\nYou can use computeds with other computeds, directly in tags, with operators, in actions and in components. Lets update our **App** component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport starsCount from './starsCount'\nimport Toast from './Toast'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  buttonClicked: signal`buttonClicked`,\n  starsCount\n},\n  function App ({title, subTitle, buttonClicked, starsCount}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>{subTitle}</h2>\n        <button onClick={() => buttonClicked()}>\n          Update star count ({starsCount})\n        </button>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\nThats it for now regarding *Compute*. Of course summarizing some numbers is pretty simple stuff, but you can compute anything.\n\nIf it did not work try jumping to the next chapter or [shout at us on Discord](https://discord.gg/0kIweV4bd2bwwsvH).\n","title":"Compute"},"routing":{"raw":"# Routing\nTypically applications use a router. To instantiate the Cerebral router, install it as a separate package and add to the controller:\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst controller = Controller({\n  router: Router({\n    routes: {}, // Route definitions\n    query: false, // Query support\n    onlyHash: false, // Use hash urls\n    baseUrl: '/' // Only handle url changes on nested path\n  })\n})\n```\n\n## Defining routes\nRoutes in Cerebral do not affect the components, they affect signals. The signals put your application in a specific state and then your components decide what to render based on that state. So the router is completely decoupled from your components. This is a very good thing because a route can now translate to any kind of state changes and side effects.\n\nLet us create a small app:\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\nimport HomeModule from './modules/home'\nimport PostsModule from './modules/posts'\n\nconst controller = Controller({\n  state: {\n    currentPage: 'home'\n  },\n  router: Router({\n    routes: {\n      '/': 'home.routed',\n      '/posts': 'posts.routed'\n    }\n  }),\n  modules: {\n    home: HomeModule,\n    posts: PostsModule\n  }\n})\n```\n\nAs we can see, when the root route is hit we want to trigger a signal that says that home is routed:\n\n*modules/Home/index.js*\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default {\n  signals: {\n    routed: set(state`currentPage`, 'home')\n  }\n}\n```\n\nThe **/posts** route points to a different module and signal.\n\n*modules/Posts/index.js*\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default {\n  signals: {\n    routed: set(state`currentPage`, 'posts')\n  }\n}\n```\n\n## Render based on state\nSo we do not render anything based on the route. We render based on state, like we do with everything else. A route never affects the components, it only affects the state.\n\n*components/App/index.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\nimport Home from '../Home'\nimport Posts from '../Posts'\n\nconst pages = {\n  home: Home,\n  posts: Posts\n}\n\nexport default connect({\n  currentPage: state`currentPage`\n},\n  function App(props) {\n    const Page = pages[props.currentPage]\n\n    return <Page />\n  }\n)\n```\n\nSo this was simple page handling routing, but you can imagine that a route does not have to be a page change. It can be opening a modal, highlight some item or whatever. You are completely free to structure this. If some data fetching was needed before changing the page you would just put this in the signal.\n\n## Tutorial\n**Before you start,** [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KdBeIDJoRv0PQlF7uWU)\n\nNow that our tutorial UI gets more complex it is a good idea to separate it a little bit. We want a home tab and a repos tab. Our two repos should load when we click the repos tab or hit the url directly.\n\n### Adding some tabs\nLet us introduce the tabs first. We will just shove everything into our one component. Normally you would split this up into multiple components of course. You would probably also use JavaScript to map over a list of tabs or something similar, but let us be explicit now. Please change *App.js* to:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport Toast from './Toast'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  repos: state`repos`,\n  activeTab: state`activeTab`,\n  homeClicked: signal`homeClicked`,\n  reposClicked: signal`reposClicked`\n},\n  function App ({\n    title,\n    subTitle,\n    repos,\n    activeTab,\n    homeClicked,\n    reposClicked\n  }) {\n    return (\n      <div>\n        <h1>{title}</h1>\n        <h2>{subTitle}</h2>\n        <div>\n          <div className='tabs'>\n            <div\n              onClick={() => homeClicked()}\n              className={`tab ${\n                activeTab === 'home' ? 'tab-active' : ''\n              }`}\n            >\n              Home\n            </div>\n            <div\n              onClick={() => reposClicked()}\n              className={`tab ${\n                activeTab === 'repos' ? 'tab-active' : ''\n              }`}\n            >\n              Repos\n            </div>\n          </div>\n          <br />\n          {\n            activeTab === 'home' ? (\n              <div>\n                Some awesome home page content\n              </div>   \n            ) : null\n          }\n          {\n            activeTab === 'repos' ? (\n              <div>\n                <ul>\n                  {Object.keys(repos).map((repoKey, index) => {\n                    const name = repos[repoKey].name\n                    const count = repos[repoKey].stargazers_count\n\n                    return (\n                      <li key={index}>\n                        {name} ({count})\n                      </li>\n                    )\n                  })}\n               </ul>\n              </div>   \n            ) : null\n          }\n        </div>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\n\nWe also need to add new state in *controller.js*:\n```js\n...\n{\n  title: 'Hello from Cerebral!',\n  subTitle: 'Working on my state management',\n  toast: null,\n  repos: {},\n  activeTab: 'home'\n}\n...\n```\nAnd update the signals as well:\n```js\n...\n{\n  homeClicked: [\n    set(state`activeTab`, 'home')\n  ],\n  reposClicked: {\n    signal: [\n      set(state`activeTab`, 'repos'),\n      showToast(string`Loading data for repo: ${props`repo`}`),\n      parallel([\n        getRepo('cerebral'),\n        getRepo('addressbar')\n      ]),\n      set(state`repos.cerebral`, props`cerebral`),\n      set(state`repos.addressbar`, props`addressbar`),\n      showToast(string`The repos have ${starsCount} stars`, 5000, 'success')  \n    ],\n    catch: new Map([\n      [HttpProviderError, showToast(string`Error: ${props`error.message`}`, 5000)]\n    ])\n  }\n}\n...\n```\nNow you can test-drive your changes. You should see the first tab activated. Now go to the debugger and change *activeTab* state to 'repos' and you will see the second tab. If you click the tabs you will actually trigger the signals which appear in the debugger. Nice! But what has this to do with Routing?\n\n### Introducing the router\nTraditional routers are a wrapper around your components and they manipulate what components to display based on the URL. That is not how routing works in Cerebral. In Cerebral you connect URLs to signals. So:\n\n1. A URL is hit or changed\n2. The respective signal is triggered putting your application in the correct state\n3. The components now renders based on the state of the application\n\nThis is a really good thing because most route changes require quite a few state changes and side effects, like server requests, to be run. This is exactly what signals do so well.\n\nLet us introduce **cerebral-router** to our project by adding an import to the top of our *controller.js*:\n\n```js\nimport Router from 'cerebral-router'\n\n```\n\nAnd go ahead by doing the router config as follows inside the controller:\n```js\n...\nconst controller = Controller({\n  ...\n  router: Router({\n    routes: {\n      '/': 'homeClicked',\n      '/repos': 'reposClicked'\n    },\n    onlyHash: true\n  }),\n  ...\n})\n...\n```\n\nAs you can see, defining *routes* is as easy as linking them to *signals*. When you save and load up the BIN again you can go to the address bar and change the url to **/#/repos**. You will now see the signal triggers and the repos content is shown. This is exactly what happens when you click the tab as well.\n\n### Challenge\n\nGo to your browsers address bar and enter an invalid route like: */#/foo* and press Enter. Now check the log! The challenge is to add another route which catches those *unknown* routes, runs a signal and display a toast with an error. You probably need to read some more docs on the router to make this work.\n","title":"Routing"},"organize":{"raw":"# Organize\n\nCerebral uses a concept called **modules** to organize application code. These allow you to wrap state and signals into a namespace without isolating them. Any action run in a signal can change any state in the application.\n\nTypically the file structure for modules looks like this. We call it the **signals pattern**. Every signal has its own file.\n\n```js\n/modules\n  /home\n    /actions\n    /signals\n    index.js\nmain.js\n```\n\nThe **index.js** file is where you define the module. It is just an object where you can define state, signals and optionally sub modules.\n\n```js\nimport somethingHappened from './signals/somethingHappened'\n\nexport default {\n  state: {},\n  signals: {\n    somethingHappened\n  }\n}\n```\n\nYou are free to structure however you want of course. Maybe you rather want to define signals directly in *index.js*, rather than have each one contained in a file.\n\nIn the **controller.js** file, the module is added to the controller:\n\n```js\nimport {Controller} from 'cerebral'\nimport home from './modules/home'\n\nconst controller = Controller({\n  modules: {\n    home\n  }\n})\n```\n\nAny signal and state defined inside the *home* module will live on the namespace chosen during controller instantiation.\n\nAnd this is how an application scales: by defining modules and submodules. Actions and factories that are common are often placed in a folder called **common**:\n\n```js\n/common\n  /actions\n  /factories\n/modules\n  /home\n    /actions\n    /signals\n    index.js\nmain.js\n```\n\n## Components\n\nA very important point in Cerebral is that your components do not affect the structure of the application state. Modules are defined in terms of what makes sense for state and signals. Sometimes this is similar to how components are structured, but more often it is not. This is why components usually live in their own **components** folder, separated from the modules:\n\n```js\n/components\n  /Home\n    index.js\n/common\n  /actions\n  /factories\n/modules\n  /home\n    /actions\n    /signals\n    index.js\nmain.js\n```\n\nAnd this is it. You will never get in trouble creating a module because any action can change any state in your application. Modules are just a way to structure state and signals, not isolate them.\n\n## Tutorial\n\nBefore we begin you can have a look at [the solution over here](https://www.webpackbin.com/bins/-KfDKApROapTmuhEF5_j). Click the **download** button, which downloads the project as a Webpack project, extract the contents to a folder on your computer and make sure that you have installed [Node JS](https://nodejs.org/en/). From the command line, run:\n\n`npm install`\n\nThen you can run:\n\n`npm start`\n\nGo to *localhost:3000* in your browser. Now you have a starting point for playing more with Cerebral and make the final adjustments yourself. A new Webpack loader called **CSS Modules** has been added and also the **classnames** tool is ready to be used. These two features allows you to refactor the CSS of the application in a scalable way.\n\n### Folder structure\nSO! Welcome to the world of **modules**. We will build the following structure:\n```\n/src\n  /components\n    /App\n      index.js\n      styles.css\n    /Home\n      index.js\n      styles.css\n    /Repos\n      index.js\n      styles.css\n    /Toast\n      index.js\n      styles.css\n\n  /modules\n    /app\n      /factories\n        showToast.js\n      index.js\n    /home\n      /signals\n        routed.js\n      index.js\n    /repos\n      /factories\n        getRepo.js\n      /signals\n        routed.js\n      index.js\n\n  /computed\n    starsCount.js\n\n  controller.js\n  main.js\n```\n\nLet us do this step by step.\n\n### main.js\nOur main file should just wire things together, meaning that it wires the controller with the view.\n\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\nimport controller from './controller'\nimport App from './components/App'\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n### controller.js\nOur controller does the same kind of wiring. It wires the modules of our app to the controller and its configuration.\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\nimport Router from 'cerebral-router'\nimport HttpProvider from 'cerebral-provider-http'\nimport app from './modules/app'\nimport home from './modules/home'\nimport repos from './modules/repos'\n\nconst controller = Controller({\n  devtools: Devtools({\n    remoteDebugger: '127.0.0.1:8585'\n  }),\n  modules: {\n    app,\n    home,\n    repos,\n    router: Router({\n      routes: [\n        {path: '/', signal: 'home.routed'},\n        {path: '/repos', signal: 'repos.routed'}\n      ],\n      onlyHash: true\n    })\n  },\n  providers: [\n    HttpProvider({\n      baseUrl: 'https://api.github.com'\n    })\n  ]\n})\n```\n\nBasically our state and signals has been removed and we rather import modules instead.\n\n### modules/app\nThe app module will take care of what tab is currently active, our titles and the toast.\n\n*index.js*\n```js\nexport default {\n  state: {\n    title: 'Cerebral Tutorial',\n    subTitle: 'Routing',\n    activeTab: 'home',\n    toast: null\n  }\n}\n```\n\nIt will also hold the **showToast** factory as we consider it a \"global app thing\", even though it is currently only used by the **repos** module.\n\n*factories/showToast.js*\n```js\nimport {set, merge, debounce} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nconst toastDebounce = debounce.shared()\nfunction showToast (message, ms, type = null) {\n  if (!ms) {\n    return merge(state`app.toast`, {message, type})\n  }\n\n  return [\n    merge(state`app.toast`, {message, type}),\n    toastDebounce(ms), {\n      continue: [\n        set(state`app.toast`, null)\n      ],\n      discard: []\n    }\n  ]\n}\n\nexport default showToast\n```\n\nNote that the paths to the state has changed, since **toast** now is under the namespace **app**.\n\n### modules/home\nThe home module does not have any state, but it does have a signal related to being clicked.\n\n*index.js*\n```js\nimport clicked from './signals/clicked'\n\nexport default {\n  signals: {\n    clicked\n  }\n}\n```\n\n*signals/clicked.js*\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default set(state`app.activeTab`, 'home')\n```\n\nAs you can see any signal can point to any state. This allows you to organize your app in a way that makes sense without worrying about isolation. This is really important, because in complex applications isolation causes big challenges.\n\n### modules/repos\nOur repos module holds the list of repos and also holds the signal for opening the repos tab.\n\n*index.js*\n```js\nimport clicked from './signals/clicked'\n\nexport default {\n  state: {\n    list: {}\n  },\n  signals: {\n    clicked\n  }\n}\n```\n\n*signals/clicked.js*\n```js\nimport {parallel} from 'cerebral'\nimport {set, when} from 'cerebral/operators'\nimport {state, props, string} from 'cerebral/tags'\nimport getRepo from '../factories/getRepo'\nimport showToast from '../../app/factories/showToast'\nimport starsCount from '../../computed/starsCount'\n\nexport default [\n  set(state`app.activeTab`, 'repos'),\n  showToast(string`Loading data for repos...`),\n  parallel([\n    getRepo('cerebral'),\n    getRepo('addressbar')\n  ]),\n  when(props`error`), {\n    'true': showToast(string`Error: ${props`error`}`, 5000, 'error'),\n    'false': [\n      set(state`repos.list.cerebral`, props`cerebral`),\n      set(state`repos.list.addressbar`, props`addressbar`),\n      showToast(string`The repos have ${starsCount} stars`, 5000, 'success')    \n    ]\n  }\n]\n```\n\n*factories/getRepo.js*\n```js\nfunction getRepoFactory (repoName) {\n  function getRepo ({http}) {\n    return http.get(`/repos/cerebral/${repoName}`)\n      .then((response) => {\n        return {[repoName]: response.result}\n      })\n      .catch((response) => {\n        return {error: response.error}\n      })\n  }\n\n  return getRepo\n}\n\nexport default getRepoFactory\n```\n\nThis is a good example of how Cerebral works. Note that there are no imports to this action factory. You just write out the logic of it, cause the context is decoupled from the actual logic.\n\n### components/App\nWe also need to split up our components a bit. The app component is now cleaned up a bit and it is using **CSS Modules** and the **classnames** tool.\n\n*index.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport styles from './styles.css'\nimport classnames from 'classnames'\nimport Toast from './Toast'\nimport Home from '../Home'\nimport Repos from '../Repos'\n\nexport default connect({\n  title: state`app.title`,\n  subTitle: state`app.subTitle`,\n  activeTab: state`app.activeTab`,\n  homeClicked: signal`home.clicked`,\n  reposClicked: signal`repos.clicked`\n},\n  function App ({\n    title,\n    subTitle,\n    activeTab,\n    homeClicked,\n    reposClicked\n  }) {\n    return (\n      <div>\n        <h1 className={styles.center}>{title}</h1>\n        <h2 className={styles.center}>{subTitle}</h2>\n        <div>\n          <div className={styles.tabs}>\n            <div\n              onClick={() => homeClicked()}\n              className={classnames(styles.tab, {\n                [styles.activeTab]: activeTab === 'home'\n              })}\n            >\n              Home\n            </div>\n            <div\n              onClick={() => reposClicked()}\n              className={classnames(styles.tab, {\n                [styles.activeTab]: activeTab === 'repos'\n              })}\n            >\n              Repos\n            </div>\n          </div>\n          <br />\n          {activeTab === 'home' ? <Home /> : null}\n          {activeTab === 'repos' ? <Repos /> : null}\n        </div>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\nNote here how css class names are actually being exported as a module to the component file. Allowing it to point to these classes with plain JavaScript. That is what css modules is all about and they are great for keeping you sane writing CSS in large applications. Lets look at how to refactor the css file:\n\n*styles.css*\n```css\n.center {\n  text-align: center;\n}\n\n.tabs {\n  display: flex;\n}\n\n.tab {\n  flex: 1;\n  font-size: 18px;\n  cursor: pointer;\n  text-align: center;\n  padding: 5px;\n}\n\n.activeTab {\n  background-color: #0086b3;\n  border-radius: 3px;\n  color: #FFF;\n}\n```\n\n### Finish the refactor\nWe have shown you the idea of the refactor here and now you can finish it. You need to refactor the following:\n\n1. Home component and styles (if any)\n2. Repos component and styles\n3. starsCount computed\n\nAnd some notes:\n\n1. Remember to changes paths to signals and state, they are now namespaced. For example: **repos.list** instead of **repos**\n2. There should not be any **styles.css** file linked to in **index.html**. All CSS should be related to a specific component\n\nCongratulations! You have reached the end of our *Get Started* - tutorial.\nThere is a lot of other good stuff on this website. So please check it out!\n\nWhen you are done with the refactor you can try to create a form input where on **onSubmit** it will fetch that repo and show its stars count. Remember to **preventDefault** on the form submit event! :)\n\nBuild your next big thing with **Cerebral** and please tell us about it on [discord chat](https://discord.gg/0kIweV4bd2bwwsvH) :)\n","title":"Organize"},"providers":{"raw":"# Providers\n\nProviders are added to the context of every action executed by a signal. Providers can be everything from a tool you are already using, to something Cerebral specific. The point of providers is to separate side effects from execution. That means you can create all the logic you want with chains and actions without creating any dependencies to other tools. This makes them highly testable and generally gives you more flexibility.\n\n## Just add a tool\nIf you are using libraries where you want access to everything they provide you can simply add them as a provider using an object:\n\n```js\nimport {Controller} from 'cerebral'\nimport {ContextProvider} from 'cerebral/providers'\nimport axios from 'axios'\nimport uuid from 'uuid'\n\nconst controller = Controller({\n  providers: [{axios, uuid}]\n})\n```\n\nNote that some tools has a very complex API that is difficult for Cerebral to analyze. With these kinds of tools it is a better idea to create your own provider, exposing APIs that you actually use from the original tool.\n\n## Creating a provider\nYou can use providers for pretty much anything, though typically it is to handle some kind of side effect. Examples of providers is [cerebral-provider-storage](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-provider-storage), [cerebral-provider-firebase](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-provider-firebase) and [cerebral-provider-http](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-provider-http).\n\nTo use a provider with Cerebral you put it in the providers array:\n\n```js\nconst controller = Controller({\n  providers: [\n    StorageProvider(),\n    HttpProvider(),\n    FirebaseProvider(),\n\n    // Let us create this\n    GreetProvider({\n      numberOfExclamationMarks: 3\n    })\n  ]\n})\n```\n\nThe convention on creating a provider looks like this:\n\n```js\n// We create a factory, allowing you to pass in options to it\nfunction GreetProviderFactory (options = {}) {\n  // We use a variable to cache the created provider\n  let cachedProvider = null\n\n  // Just some custom code to handle an option\n  let exclamationMarks = ''\n\n  for (let x = 0; x < options.numberOfExclamationMarks || 0; x++) {\n    exclamationMarks += '!'\n  }\n\n  // This is the function that creates the provider,\n  // typically just an object with some methods\n  function createProvider (context) {\n    return {\n      hello (name) {\n        return `Hello, ${name}${exclamationMarks}`\n      }\n    }\n  }\n\n  // The function that is run by Cerebral, providing the context\n  // for you to attach your provider to\n  function GreetProvider (context) => {\n    context.greet = cachedProvider = (cachedProvider || createProvider(context))\n\n    // You can wrap the provider with the debugger\n    // to show information about its usage in the debugger\n    if (context.debugger) {\n      context.debugger.wrapProvider('greet')\n    }\n\n    // Always return the context after mutating it\n    return context\n  }\n\n  return GreetProvider\n}\n\nexport default GreetProviderFactory\n```\n\nNow this provider is available to any action:\n\n```js\nfunction myAction ({greet}) {\n  greet.hello('Thor') // \"Hello Thor!!!\"\n}\n```\n\nAs mentioned above we use providers to separate side effects from execution, allowing us to provider our own custom API to our application.\n","title":"Providers"},"errors":{"raw":"# Errors\n\nHandling complex asynchronous flows is a challenging task for error handling. If things are not done correctly errors can be swallowed and you will have a hard time figuring out why your application does not work.\n\nError handling in Cerebral signals are done for you. Wherever you throw an error, it will be caught correctly and thrown to the console unless you have explicitly said you want to handle it. And even when you do explicitly handle it Cerebral will still show the error in the debugger, meaning you can never go wrong. The action in question is highlighted red, you will see the error message, the code related and even what executed related to you catching the error.\n\n![debugger_error](/images/debugger_error.png)\n\n## Catching errors\nTo catch an error from a signal you can define it with the signal definition:\n\n*someModule.js*\n```js\nexport default {\n  state: {},\n  signals: {\n    // Define the signal as an object\n    somethingHappened: {\n      signal: someSequence,\n      catch: new Map([\n        [FirebaseProviderError, someSequenceHandlingError]\n      ])\n    }\n  }\n}\n```\n\nIf you are not familiar with the **Map** JavaScript API, [you can read more here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map). We basically tell the signal that we are interested in any errors thrown by the Firebase Provider. Then we point to the sequence of actions we want to handle it. An error will be passed in to the sequence of actions handling the error:\n\n```js\n{\n  foo: 'bar', // already on payload\n  error: {\n    name: 'FirebaseProviderError',\n    message: 'Could not connect',\n    stack: '...'\n  }\n}\n```\n\n## Catching globally\nIn most applications error handling can be handled at a global level. That means you define your signals as normal and you rather define catch handlers on the controller itself:\n\n```js\nimport {Controller} from 'cerebral'\nimport {\n  FirebaseProviderAuthenticationError,\n  FirebaseProviderError\n} from 'cerebral-provider-firebase'\nimport {\n  HttpProviderError\n} from 'cerebral-provider-http'\n\nconst controller = Controller({\n  modules: {},\n  catch: new Map([\n    [FirebaseProviderAuthenticationError, []]\n    [FirebaseProviderError, []],\n    [HttpProviderError, []]\n  ])\n})\n```\n\n## Creating an error type\nJavaScript has a base error class of **Error**. When you create your own error types it makes sense to extend **Error**. This is only recently supported in browsers, but you can use [babel-plugin-transform-builtin-extend](https://github.com/loganfsmyth/babel-plugin-transform-builtin-extend) to make sure extending errors works correctly.\n\n```js\nclass AppError extends Error {\n  constructor(message) {\n    super(message)\n    this.name = 'AppError'\n  }\n}\n```\n\nThis allows you to create more specific errors by subclassing:\n\n```js\nclass AuthError extends AppError {\n  constructor(message, code) {\n    super(message)\n\n    this.name = 'AuthError'\n    this.code = code\n  }\n  // By adding a custom \"toJSON\" method you decide\n  // how the error will be shown when passed to the\n  // debugger and your catch handler\n  toJSON ()¬†{\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      stack: this.stack\n    }\n  }\n}\n```\n","title":"Errors"},"test":{"raw":"# Test\n\nCerebral makes it easy to test your application components and business logic.\n\n## Components\nThe **Container** you use to expose Cerebral to your components can also be used when testing, but you can also use the **StateContainer** which allows you to pass state down to your components as if it was extracted from the Cerebral controller.\n\n```js\nimport React from 'react'\nimport {mount} from 'enzyme'\nimport {StateContainer} from 'cerebral/react'\n\nimport Foo from './Foo'\n\ndescribe('<Foo />', () => {\n  it('allows us to set props', () => {\n    const state = {\n      foo: 'bar'\n    }\n    const wrapper = mount(\n      <StateContainer state={state}>\n        <Foo />\n      </StateContainer>\n    )\n    expect(wrapper.find('.foo')).to.have.length(1)\n  })\n})\n```\n\nThis approach allows you to pass down state wherever you want and ensure the components render as expected.\n\n## Computes\n\nThe `runCompute` test helper accepts the `compute` and `fixtures` arguments and returns the compute output.\n\n```js\nvar result = runCompute(compute, state)\n```\n\nThe optional `fixture` argument should be an object that contains any of the following:\n\n```js\n{\n  state: {}, // test state\n  props: {}  // props passed to the computed\n}\n```\n\n### Example\n\n```js\nimport {props, state} from 'cerebral/tags'\nimport {runCompute} from 'cerebral/test'\n\nimport Multiply from './Multiply'\n\nit('should multiply by the specified number', () => {\n  const multiply = Multiply(state`number`, props`number`)\n  const result = runCompute(multiply, {\n    state: { number: 5 },\n    props: { number: 2 }\n  })\n  assert.equal(result, 10)\n})\n```\n\n## Actions\n\nThe `runAction` test helper accepts the `action` and `fixture` arguments and returns a promise.\n\n```js\nrunAction(action, fixture).then((result) => {})\n```\n\nThe optional `fixture` argument should be an object that contains any of the following:\n\n```js\n{\n  state: {}, // test state\n  props: {}, // props passed to the action\n  // any other options that can be passed to the\n  // cerebral controller, including router, providers...\n}\n```\n\nThe `result` object passed when the promise resolves contains `state`, `controller`, `props` and `output` properties.\n\n```\n{\n  state,\n  controller,\n  props: {\n    // props data received by action\n  },\n  output: {\n    // action output data\n  }\n}\n```\n\n### Example\n\n```js\nimport {state} from 'cerebral/tags'\nimport {runAction} from 'cerebral/test'\n\nimport Increment from './Increment'\n\nit('should increment numbers in state', () => {\n  const increment = Increment(state`number`)\n\n  return runAction(increment, { state: { number: 1 } })\n    .then(({state}) => assert.equal(state.number, 2))\n})\n```\n\n## Signals\n\n### runSignal\n\nThe `runSignal` test helper accepts the `signal` (chain of actions or signal name) and `fixture` arguments and returns a promise. `runSignal` is designed to be called one time, to test calling multiple signals in a single test see the `RunSignal` factory below.\n\n```js\nrunSignal(signal, fixture. options).then((result) => {})\n```\n\nThe optional `fixture` argument should be an object that contains any of the following:\n\n```js\n{\n  state: {}, // test state\n  props: {}, // props passed to the signal\n  // any other options that can be passed to the\n  // cerebral controller, including signals, modules, router, providers...\n}\n```\n\nIf the `signal` argument is passed as a string, then the signal must be defined within the fixtures.\n\nThe optional `options` argument contain the the following options:\n\n`recordActions: true|false|'byName'`\n\nWhen `recordActions: true` is specified each action will record its props/output against its index within the signal action chain. When `recordActions: 'byName'` is specified each action will record its output against an named property in the result.\n\nThe `result` object passed when the promise resolves contains `state`, `controller` and an object for each named action in the signal chain with the same name as the actions with `props` and `output` properties.\n\n```\n{\n  state,\n  controller,\n  '2': {\n    props: {\n      // props data\n    },\n    output: {\n      // action output data\n    }\n  },\n  '1': {\n    props: {\n      // props data\n    },\n    output: {\n      // action output data\n    }\n  }\n}\n```\n\n#### Example\n\n```js\nimport {runSignal} from 'cerebral/test'\n\n// the buttonClicked signal has two actions: validateForm and updateIsValid\nimport buttonClicked from './buttonClick'\n\nit('should handle button clicks', () => {\n  const fixture = {\n    state: { isValid: false },\n    props: { buttonName: 'submit' }\n  }\n  return runSignal(buttonClicked, fixture, {recordActions: 'byName'})\n    .then(({validateForm, updateIsValid, state}) => {\n      assert.equal(validateForm.props.buttonName, 'submit')\n      assert.equal(updateIsValid.props.isValid, true)\n      assert.equal(state.isValid, true)\n    })\n})\n```\n\n### CerebralTest factory\n\nThe `CerebralTest` factory returns runSignal, setState and getState functions that can be called many times without resetting the controller in between.\n\n```js\nconst cerebral = CerebralTest(fixture. options)\ncerebral.setState(path, value)\ncerebral.runSignal(signal, props).then((result) => {})\nconst value = cerebral.getState(path)\n```\n\n#### Example\n\n```js\nimport {CerebralTest} from 'cerebral/test'\n\nit('should accumulate a count', () => {\n  const cerebral = CerebralTest({\n    modules: {\n      math: math()\n    }\n  })\n  cerebral.setState('math.count', 0)\n  return cerebral.runSignal('math.plusOne').then(({state}) => {\n    assert.equal(state.math.count, 1)\n    return cerebral.runSignal('math.plusTwo').then(() => {\n      assert.equal(cerebral.getState('math.count'), 3)\n    })\n  })\n})\n```\n","title":"Test"},"collaborate":{"raw":"# Collaborate\n\nWriting code is not only about you and the computer, it is about you and your team. You write the code not only to make the computer understand it, but also your team to understand. Cerebral is about building mental images of how your application works and therefor naturally makes it easier to collaborate on projects.\n\n## Components\n\nGenerally in projects it is a good idea to completely separate stateless basic UI components from components that you would connect to Cerebral. A typical example of this would be a **Button**. That is a stateless UI component, while a **Posts** component would most likely be connected to some state. When you think about components this way you can even keep them in two separate projects or folders.\n\nSo one approach to this is using [React Storybook](https://getstorybook.io/). You can set up your project which uses storybook to develop components with hot reloading. This also becomes a really great archive of your basic component types, which are composed together in the application project. In your Webpack setup you can use **alias** to point to these stateless components.\n\nGiven this folder structure:\n\n```js\nbase-components/\n  /Button\n  /Column\nsrc/\n  /components\n  /modules\n  controller.js\n  main.js\n```\n\n*webpack.config.js*\n```js\n{\n  ...,\n  resolve: {\n    alias: {\n      'base-components': path.resolve('base-components')\n    }\n  },\n}\n```\n\nBase components is a really good entrypoint to a project and coding in general. If you get new people on the team, let them get productive straight away building components.\n\n## Signals\nAn opportunity you get as a team using Cerebral is a \"framework to plan out logic\". Sometimes a user interaction leads to a single state change, but more often it can be rather complex. You will need to talk about logically what this user interaction should lead to.\n\nTogether you can define the signal. Since it is declarative there is no need to implement anything:\n\n```js\n[\n  set(state`posts.isLoading`, true),\n  getPosts, {\n    success: [\n      set(state`posts.list`, sort(props`posts`)),\n      redirect(string`/posts/${state`posts.list.0.id`}`)\n    ],\n    error: showError('Could not get posts')\n  }\n]\n```\n\nThis is a very simple signal, but just discussing where to store state, what to name it and how to best compose is something that should be a regular exercise in teams. This is not only related to Cerebral, but any shared codebase. Cerebral just gives you an abstraction that makes this very easy to do.\n","title":"Collaborate"}},"packages":{"index":{"raw":"# cerebral-router\n\n## Install\n**NPM**\n\n`npm install cerebral-router@next --save --save-exact`\n\n**YARN**\n\n`yarn add cerebral-router@next --exact`\n\n## Description\nThe router of Cerebral does not affect your view layer. A url change triggers a signal that puts your application in the correct state. Your view just reacts to this state, like any other state change.\n\n## API\n\n### instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst controller = Controller({\n  router: Router({\n    // Define routes and point to signal paths\n    routes: {\n      '/': 'app.homeRouted'\n    },\n\n    // Merge query params into payload of signal\n    query: false,\n\n    // Only react to hash urls\n    onlyHash: false,\n\n    // Set a base url, if your app lives on a subpath\n    baseUrl: null,\n\n    // Will allow none matching routes on same origin to run as normal\n    allowEscape: false,\n\n    // Will make the router not run the initial route\n    preventAutostart: false\n  })\n})\n```\n\n### routes\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst controller = Controller({\n  router: Router({\n    routes: {\n      // Trigger signal when root routed\n      '/': 'app.homeRouted',\n\n      // Trigger signal, passing in \"itemId\" on payload, example:\n      // \"/items/123\" -> {itemId: '123'}\n      '/items/:itemId': 'app.itemRouted',\n\n      // Nest routes\n      '/users': {\n        '/': 'app.usersRouted',\n        '/:userId': 'app.userRouted'\n      }\n    }\n  })\n})\n```\n\n### getUrl\n```js\nfunction myAction({router}) {\n  // Get current url, example: \"/items\"\n  router.getUrl()\n}\n```\n\n### goTo\n*action*\n```js\nfunction myAction({router}) {\n  // Go to a new url\n  router.goTo('/items')\n}\n```\n\n*factory*\n```js\nimport {goTo} from 'cerebral-router/operators'\n\nexport default [\n  goTo('/items')\n]\n```\n\n### redirect\n*action*\n```js\nfunction myAction({router}) {\n  // Go to a new url, replacing current url\n  router.redirect('/items')\n}\n```\n\n*factory*\n```js\nimport {redirect} from 'cerebral-router/operators'\n\nexport default [\n  redirect('/items')\n]\n```\n\n### redirectToSignal\n*action*\n```js\nfunction myAction({router}) {\n  // Trigger a signal bound to router\n  router.redirectToSignal('app.itemsRouted', {foo: 'bar'})\n}\n```\n\n*factory*\n```js\nimport {redirectToSignal} from 'cerebral-router/operators'\n\nexport default [\n  redirectToSignal('app.itemsRouted', props`payload`)\n]\n```\n","title":"cerebral-router"},"http":{"raw":"# cerebral-provider-http\n\n## install\n**NPM**\n\n`npm install cerebral-provider-http@next --save --save-exact`\n\n**YARN**\n\n`yarn add cerebral-provider-http@next --exact`\n\n## description\nThe HTTP provider exposes the ability to do HTTP requests both in actions and directly in signals. It supports **cors** and file upload, with progress handling. It default to **json**, but you can configure it to whatever you want.\n\n```js\nimport {set} from 'cerebral/operators'\nimport {httpGet} from 'cerebral-provider-http/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpGet(`/items/${props`itemKey`}`),\n  set(state`app.currentItem`, props`result`)\n]\n```\n\nAll factories of HTTP provider supports template tags.\n\n## instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport HttpProvider from 'cerebral-provider-http'\n\nconst controller = Controller({\n  providers: [\n    HttpProvider({\n      // Prefix all requests with this url\n      baseUrl: 'https://api.github.com',\n\n      // Any default headers to pass on requests\n      headers: {\n        'Content-Type': 'application/json; charset=UTF-8',\n        'Accept': 'application/json'\n      },\n\n      // When talking to cross origin (cors), pass cookies\n      // if set to true\n      withCredentials: false\n    })\n  ]\n})\n```\n\nYou can update these default options in an action:\n\n```js\nfunction updateDefaultHttpOptions({http}) {\n  http.updateOptions({\n    // Updated options\n  })\n}\n```\n\n## error\n\n### HttpProviderError\n\n```js\nimport {HttpProviderError} from 'cerebral-provider-http'\n\n// Error structure\n{\n  name: 'HttpProviderError',\n  message: 'Some potential error message',\n  body: 'Message or response body',\n  status: 200,\n  isAborted: false,\n  headers: {},\n  stack: '...'  \n}\n```\n\n## request\n\n```js\nfunction someGetAction ({http}) {\n  return http.request({\n    // Any http method\n    method: 'GET',\n\n    // Url you want to request to\n    url: '/items'\n\n    // Request body as object. Will automatically be stringified if json and\n    // urlEncoded if application/x-www-form-urlencoded\n    body: {},\n\n    // Query as object, will automatically be urlEncoded\n    query: {},\n\n    // If cross origin request, pass cookies\n    withCredentials: false,\n\n    // Any additional http headers, or overwrite default\n    headers: {},\n\n    // A function or signal path (foo.bar.requestProgressed) that\n    // triggers on request progress. Passes {progress: 45} etc.\n    onProgress: null\n  })\n}\n```\n\n## get\n\n*action*\n```js\nfunction someGetAction ({http}) {\n  return http.get('/items', {\n    // QUERY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpGet} from 'cerebral-provider-http/operators'\n\nexport default [\n  httpGet('/items'),\n\n  // Alternatively with explicit paths\n  httpGet('/items'), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n*output*\n```javascript\n{\n  result: 'the response',\n  status: 200,\n\n  // If aborted\n  isAborted: true\n}\n```\n\n## post\n\n*action*\n```js\nfunction somePostAction ({http}) {\n  return http.post('/items', {\n    // BODY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpPost} from 'cerebral-provider-http/operators'\nimport {props} from 'cerebral/tags'\n\nexport default [\n  httpPost('/items', {\n    title: props`itemTitle`,\n    foo: 'bar'\n  }),\n\n  // Alternatively with explicit paths\n  httpPost('/items', {\n    title: props`itemTitle`,\n    foo: 'bar'\n  }), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n*output*\n```javascript\n{\n  result: 'the response',\n  status: 200,\n\n  // If aborted\n  isAborted: true\n}\n```\n\n## put\n\n*action*\n```js\nfunction somePutAction ({http}) {\n  return http.put('/items/1', {\n    // BODY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpPost} from 'cerebral-provider-http/operators'\n\nexport default [\n  httpPut('/items', {\n    // BODY object\n  }),\n\n  // Alternatively with explicit paths\n  httpPut('/items', {\n    // BODY object\n  }), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n*output*\n```javascript\n{\n  result: 'the response',\n  status: 200,\n\n  // If aborted\n  isAborted: true\n}\n```\n\n## patch\n\n*action*\n```js\nfunction somePatchAction ({http}) {\n  return http.patch('/items/1', {\n    // BODY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpPost} from 'cerebral-provider-http/operators'\nimport {state, props, string} from 'cerebral/tags'\n\nexport default [\n  httpPatch(string`/items/${props`itemId`}`, state`patchData`),\n\n  // Alternatively with explicit paths\n  httpPatch(string`/items/${props`itemId`}`, state`patchData`), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n*output*\n```javascript\n{\n  result: 'the response',\n  status: 200,\n\n  // If aborted\n  isAborted: true\n}\n```\n\n## delete\n\n*action*\n```js\nfunction someDeleteAction ({http}) {\n  return http.delete('/items/1', {\n    // QUERY object\n  }, {\n    // Any options defined in \"Custom request\"\n  })\n}\n```\n\n*factory*\n```js\nimport {httpPost} from 'cerebral-provider-http/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  httpDelete(string`/items/${state`currentItemId`}`),\n\n  // Alternatively with explicit paths\n  httpDelete(string`/items/${state`currentItemId`}`), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n*output*\n```javascript\n{\n  result: 'the response',\n  status: 200,\n\n  // If aborted\n  isAborted: true\n}\n```\n\n## uploadFile\n\n*action*\n```js\nfunction someDeleteAction ({http, props}) {\n  return http.uploadFile('/upload', props.files, {\n    name: 'filename.png', // Default to \"files\"\n    data: {}, // Additional form data\n    headers: {},\n    onProgress(progress) {} // Upload progress\n  })\n}\n```\n\n*factory*\n```js\nimport {httpUploadFile} from 'cerebral-provider-http/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpUploadFile('/uploads', props`file`, {\n    name: state`currentFileName`\n  }),\n\n  // Alternatively with explicit paths\n  httpUploadFile('/uploads', props`file`, {\n    name: state`currentFileName`\n  }), {\n    success: [],\n    error: [],\n    abort: [], // Optional\n    '${STATUS_CODE}': [] // Optionally any status code, ex. 404: []\n  }\n]\n```\n\n*output*\n```javascript\n{\n  result: 'the response',\n  status: 200,\n\n  // If aborted\n  isAborted: true\n}\n```\n\n\n## response\n\n```js\nfunction someGetAction ({http}) {\n  return http.get('/items')\n    // All status codes between 200 - 300, including 200\n    .then((response) => {\n      response.status // Status code of response\n      response.result // Parsed response text\n      // The response headers are returned as an object with lowercase header\n      // names as keys. Values belonging to the same key are separated by ', '.\n      response.headers // Parsed response headers\n    })\n    // All other status codes\n    .catch((error) => {\n      // HttpProviderError\n      error.message // {status: 500, result: 'response text', headers: {}, isAborted: false}\n    })\n}\n```\n\n## abort\nYou can abort any running request, causing the request to resolve as status code **0** and set an **isAborted** property on the response object.\n\n```js\nfunction searchItems({input, state, path, http}) {\n  http.abort('/items*') // regexp string\n  return http.get(`/items?query=${input.query}`)\n    .then(path.success)\n    .catch((error) => {\n      if (error.message.isAborted) {\n        return path.abort()\n      }\n\n      return path.error({error: error.message})\n    })\n}\n\nexport default [\n  searchItems, {\n    success: [],\n    error: [],\n    abort: []\n  }\n]\n```\n\n## cors\nCors has been turned into a \"black box\" by jQuery. Cors is actually a very simple concept, but due to a lot of confusion of \"Request not allowed\", **cors** has been an option to help out. In HttpProvider we try to give you the insight to understand how cors actually works.\n\nCors has nothing to do with the client. The only client configuration related to cors is the **withCredentials** option, which makes sure cookies are passed to the cross origin server. The only requirement for cors to work is that you pass the correct **Content-Type**. Now, this depends on the server in question. Some servers allows any content-type, others require a specific one. These are the typical ones:\n\n- text/plain\n- application/x-www-form-urlencoded\n- application/json; charset=UTF-8\n\nNote that this is only related to the **request**. If you want to define what you want as response, you set the **Accept** header, which is *application/json* by default.\n","title":"cerebral-provider-http"},"firebase":{"raw":"# cerebral-provider-firebase\n\n## install\n**NPM**\n\n`npm install cerebral-provider-firebase@next --save --save-next`\n\n**YARN**\n\n`yarn add cerebral-provider-firebase@next --exact`\n\n## description\nThe Firebase provider is a Cerebral friendly wrapper around the Firebase client. By default the Firebase client is heavily event based, even just getting some value, handling authentication etc. This is useful in some types of apps, but Cerebral has a very straight forward way of thinking about side effects. You will find that a lot of the API exposed by the Firebase client is simplified!\n\n\n## instantiate\n\n```javascript\nimport {Controller} from 'cerebral'\nimport FirebaseProvider from 'cerebral-provider-firebase'\n\nconst controller = Controller({\n  providers: [\n    FirebaseProvider({\n      config: {\n        apiKey: '{apiKey}',\n        authDomain: '{authDomain}',\n        databaseURL: '{databaseURL}',\n        storageBucket: '{storageBucket}'\n      },\n      // When using tasks and firebase queue you can prefix\n      // the specs triggered. This is useful in development\n      // when multiple developers are working on the\n      // same instance\n      specPrefix: 'CJ'\n    })\n  ]\n})\n```\n\n**Important notes**\n\n- The Cerebral firebase provider uses **dot** notation to keep consistency with Cerebral itself\n\n- All factories supports template tags, allowing you to dynamically create paths and points to values\n\n## error\n\n### FirebaseProviderError (base)\n```js\nimport {FirebaseProviderError} from 'cerebral-provider-firebase'\n\n// Error structure\n{\n  name: 'HttpProviderError',\n  message: 'Some firebase error message'\n  stack: '...'  \n}\n```\n\n### FirebaseProviderAuthenticationError\n```js\nimport {FirebaseProviderAuthenticationError} from 'cerebral-provider-firebase'\n\n// Error structure\n{\n  name: 'HttpProviderError',\n  message: 'Some firebase error message'\n  code: 10 // firebase auth error code\n  stack: '...'  \n}\n```\n\n## set\nWrite data to this database location. This will overwrite any data at this location and all child locations. Passing **null** for the new value is equivalent to calling remove(); all data at this location or any child location will be deleted.\n\n*action*\n```javascript\nfunction someAction({firebase}) {\n  return firebase.set('foo.bar', 'baz')\n}\n```\n\n*factory*\n```javascript\nimport {props} from 'cerebral/tags'\nimport {set} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  set('foo.bar', props`foo`),\n\n  // Alternatively with explicit paths\n  set('foo.bar', props`foo`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\nNo output\n\n## update\nAs opposed to the set() method, update() can be use to selectively update only the referenced properties at the current location (instead of replacing all the child properties at the current location).\n\n*action*\n```javascript\nfunction someAction({firebase}) {\n  return firebase.update('some.path', {\n    'foo': 'bar',\n    'items.item1.isAwesome': true\n  })\n}\n```\n\n*factory*\n```javascript\nimport {props} from 'cerebral/tags'\nimport {update} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  update('some.path', {\n    'foo.bar': props`bar`,\n    'foo.baz': props`baz`\n  }),\n\n  // Alternatively with explicit paths\n  update('some.path', {\n    'foo.bar': props`bar`,\n    'foo.baz': props`baz`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\nNo output\n\n## push\nGenerates a new child location using a unique key and returns its reference from the action. An example being `{key: \"-KWKImT_t3SLmkJ4s3-w\"}`.\n\n*action*\n```javascript\nfunction someAction({firebase}) {\n  return firebase.push('users', {\n    name: 'Bob'\n  })\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {push} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  push('users', state`newUser`),\n\n  // Alternatively with explicit paths\n  push('users', state`newUser`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```javascript\n{key: 'theAddedKey'}\n```\n\n## remove\nRemove the data at this database location.\n\n*action*\n```javascript\nfunction someAction({ firebase}) {\n  return firebase.remove('foo.bar')\n}\n```\n\n*factory*\n```javascript\nimport {props, string} from 'cerebral/tags'\nimport {remove} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  remove(string`users.${props`userKey`}`),\n\n  // Alternatively with explicit paths\n  remove(string`users.${props`userKey`}`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\nNo output\n\n## transaction\nAtomically modifies the data at the provided location.\n\nUnlike a normal set(), which just overwrites the data regardless of its previous value, transaction() is used to modify the existing value to a new value, ensuring there are no conflicts with other clients writing to the same location at the same time.\n\nTo accomplish this, you pass transaction() an update function which is used to transform the current value into a new value. If another client writes to the location before your new value is successfully written, your update function will be called again with the new current value, and the write will be retried. This will happen repeatedly until your write succeeds without conflict or you abort the transaction by not returning a value from your update function.\n\n*action*\n```javascript\nfunction someAction({firebase}) {\n\n  function transactionFunction(currentData){\n    if (currentData === null) {\n      return { foo: 'bar' }\n    }\n\n    return // Abort the transaction.\n  }\n\n  return firebase.transaction('some.transaction.path', transactionFunction)\n    .then((result) => {\n      if(result.committed){\n        return {result: result.value}\n      } else {\n        throw new Error('Transaction failed')\n      }\n    })\n}\n```\n\n*factory*\n```javascript\nimport {transaction} from 'cerebral-provider-firebase/operators'\n\nfunction transactionFunction(currentData){\n  if (currentData === null) {\n    return { foo: 'bar' }\n  }\n\n  return // Abort the transaction.\n}\n\nexport default [\n  transaction('foo.bar', transactionFunction),\n\n  // Alternatively with explicit paths\n  transaction('foo.bar', transactionFunction), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```javascript\n{committed: true, value: 'new value'}\n```\n\nNote: Modifying data with set() will cancel any pending transactions at that location, so extreme care should be taken if mixing set() and transaction() to update the same data.\n\nNote: When using transactions with Security and Firebase Rules in place, be aware that a client needs .read access in addition to .write access in order to perform a transaction. This is because the client-side nature of transactions requires the client to read the data in order to transactionally update it.\n\n## value\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  return firebase.value('someKey.foo')\n}\n```\n\n*factory*\n```javascript\nimport {value} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  value('foo.bar'),\n\n  // Alternatively with explicit paths\n  value('foo.bar'), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```javascript\n{key: 'keyYouLookedUpValueOn', value: 'the value'}\n```\n\n## onValue\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  firebase.onValue('someKey.foo', 'someModule.fooUpdated',  {\n    payload: {}, // Merged with the payload passed on new data\n  });\n}\n```\nThis will **NOT** immediately grab the value and trigger the signal passed, the first event is discarded for more predictable behaviour. To grab existing value, just use `value`.\n\nTo stop listening for updates to the value:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('someKey.foo', 'onValue', 'someModule.fooUpdated');\n}\n```\n\n*factory*\n```javascript\nimport {onValue} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  onValue('foo.bar', 'some.signal')\n]\n```\n\n## onChildAdded\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildAdded('posts', 'posts.postAdded', {\n    payload: {}, // Merged with the payload passed on new data\n    limitToFirst: 5, // Read Firebase docs\n    limitToLast: 5, // Read Firebase docs\n    startAt: 5, // Read Firebase docs\n    endAt: 5, // Read Firebase docs\n    equalTo: 5, // Read Firebase docs\n    orderByChild: 'count', // Read Firebase docs\n    orderByKey: true, // Read Firebase docs\n    orderByValue: true // Read Firebase docs\n  });\n}\n```\nThis will immediately grab and trigger the signal `posts.postAdded` for every post grabbed. Note this is just registering a listener, not returning a value from the action. The signal is triggered with the payload: `{ key: 'someKey', value: {} }`.\n\nTo stop listening for updates to the posts:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildAdded', 'posts.postAdded');\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {onChildAdded} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  onChildAdded('foo.bar', 'some.signal', {\n    orderByChild: 'count',\n    limitToFirst: state`config.limitToFirst`\n  })\n]\n```\n\n## onChildRemoved\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildRemoved('posts', 'posts.postRemoved', {\n    // Same options as above\n  });\n}\n```\nThis will trigger the signal `posts.postRemoved` whenever a post is removed from the selection. The signal is triggered with the payload: `{ key: 'someKey' }`.\n\nTo stop listening:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildRemoved', 'posts.postRemoved');\n}\n```\n\n*factory*\n```javascript\nimport {onChildRemoved} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  onChildRemoved('foo.bar', 'some.signal', {\n    // Same options as above\n  })\n]\n```\n\n## onChildChanged\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildChanged('posts', 'posts.postChanged', {\n    // Same options as above\n  });\n}\n```\nThis will trigger the signal `posts.postChanged` whenever a post is changed in the selection. The signal is triggered with the payload: `{ key: 'someKey', value: {} }`.\n\nTo stop listening:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildChanged', 'posts.postChanged');\n}\n```\n\n*factory*\n```javascript\nimport {onChildChanged} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  onChildChanged('foo.bar', 'some.signal', {\n    // Same options as above\n  })\n]\n```\n\n## task\nIf you are using the [firebase-queue](https://github.com/firebase/firebase-queue) and need to create tasks, you can do that with:\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.task('create_post', {\n    uid: state.get('app.user.uid'),\n    text: state.get('posts.newPostText')\n  })\n}\n```\n\nThis will add a task at `queue/tasks`. There is no output from a resolved task, it just resolves when the action has been processed.\n\n*factory*\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {task} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  task('some_task', {\n    uid: state`user.uid`,\n    data: props`data`\n  }),\n\n  // Alternatively with explicit paths\n  task('some_task', {\n    uid: state`user.uid`,\n    data: props`data`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\nNo output\n\n## getUser\nWill resolve to `{user: {}}` if user exists. If user was redirected from Facebook/Google etc. as part of first sign in, this method will handle the confirmed registration of the user.\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  return firebase.getUser()\n}\n```\n\n*factory*\n```javascript\nimport {getUser} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  getUser(),\n\n  // Alternatively with explicit paths\n  getUser(), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```javascript\n{user: {}}\n```\n\n## signInAnonymously\nThis login will method will resolve to existing anonymous or create a new one for you.\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  return firebase.signInAnonymously()\n}\n```\n\n*factory*\n```javascript\nimport {signInAnonymously} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  signInAnonymously(),\n\n  // Alternatively with explicit paths\n  signInAnonymously(), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```javascript\n{user: {}}\n```\n\n## createUserWithEmailAndPassword\nRegister a new user with email and password.\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  const email = state.get('register.email')\n  const password = state.get('register.password')\n\n  return firebase.createUserWithEmailAndPassword(email, password)\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {createUserWithEmailAndPassword} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  createUserWithEmailAndPassword(state`newUser.email`, state`newUser.password`),\n\n  // Alternatively with explicit paths\n  createUserWithEmailAndPassword(state`newUser.email`, state`newUser.password`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```javascript\n{user: {}}\n```\n\n## signInWithEmailAndPassword\nSign in a user with email and password.\n\n*action*\n```js\nfunction someAction({ firebase, path, state }) {\n  const email = state.get('register.email')\n  const password = state.get('register.password')\n\n  return firebase.signInWithEmailAndPassword(email, password)\n}\n```\n\n*factory*\n```javascript\nimport {props} from 'cerebral/tags'\nimport {signInWithEmailAndPassword} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  signInWithEmailAndPassword(props`email`, props`password`),\n\n  // Alternatively with explicit paths\n  signInWithEmailAndPassword(props`email`, props`password`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```javascript\n{user: {}}\n```\n\n## signInWith{PROVIDER}\nSign in a user with Facebook, Google or Github.\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.signInWithFacebook({\n    redirect: false, // Use popup or redirect. Redirect typically for mobile\n    scopes: [] // Facebook scopes to access\n  })\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {signInWithFacebook} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  signInWithFacebook({\n    redirect: state`useragent.media.small`\n  }),\n\n  // Alternatively with explicit paths\n  signInWithFacebook({\n    redirect: state`useragent.media.small`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\nEither this will be a redirect or it outputs:\n\n```javascript\n{user: {}}\n```\n\nSimilar you can sign in with Google or GitHub.\nJust use `signInWithGoogle` or `signInWithGithub` instead of `signInWithFacebook`.\n\n## linkWithFacebook{PROVIDER}\nLink an anonymous account with Facebook, Google or Github.\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.linkWithFacebook({\n    redirect: false, // Use popup or redirect. Redirect typically for mobile\n    scopes: [] // Facebook scopes to access\n  })\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {linkWithFacebook} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  linkWithFacebook({\n    redirect: state`useragent.media.small`\n  }),\n\n  // Alternatively with explicit paths\n  linkWithFacebook({\n    redirect: state`useragent.media.small`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\nEither this will be a redirect or it outputs:\n\n```javascript\n{user: {}}\n```\n\nSimilar you can sign in with Google or GitHub.\nJust use `linkWithGoogle` or `linkWithGithub` instead of `linkWithFacebook`.\n\n## signOut\nSign out user. **getUser** will now not resolve a user anymore.\n\n*action*\n```js\nfunction someAction({ firebase }) {\n  return firebase.signOut()\n}\n```\n\n*factory*\n```javascript\nimport {signOut} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  signOut(),\n\n  // Alternatively with explicit paths\n  signOut(), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\nNo output\n\n## sendPasswordResetEmail\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.sendPasswordResetEmail(state.get('user.email'))\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {sendPasswordResetEmail} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  sendPasswordResetEmail(state`user.email`),\n\n  // Alternatively with explicit paths\n  sendPasswordResetEmail(state`user.email`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\nNo output\n\n## setOnDisconnect\nSets a value when Firebase detects user has disconnected.\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  firebase.setOnDisconnect(`activeUsers.${state.get('app.user.uid')}`, 'someValue')\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {setOnDisconnect} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  setOnDisconnect(string`activeUsers.${state`app.user.uid`}`, null)\n]\n```\n\n*output*\nNo output\n\n## cancelOnDisconnect\nCancel setting a value when Firebase detects disconnect.\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  firebase.cancelOnDisconnect()\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {cancelOnDisconnect} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  cancelOnDisconnect()\n]\n```\n\n*output*\nNo output\n\n## put\n\nUpload a new file at the given location. Please note that the file is **not** stored inside the realtime database but into Google Cloud Storage (please consult filrebase documentation). This means that you need to take care of storage security as well.\n\nNote that `put` expects a folder as first argument and will use the name of the provided file. If you want to control the filename, add this in the options. In this case, make sure to respect file type and extension...\n\n*action*\n```js\nfunction someAction({ firebase, props }) {\n  return firebase.put('folderName', props.file, {\n    progress({progress, bytesTransferred, totalBytes, state}) {\n      /* do whatever */\n    },\n    // Override name, make sure you set same extension\n    filename: 'customName.png'\n  })\n}\n```\n\n*factory*\n```js\nimport {props, signal, string, state} from 'cerebral/tags'\nimport {put} from 'cerebral-provider-firebase/operators'\n\n// we expect props.file to contain a file provided by\n// a user in an <input type='file' />\nexport default [\n  put(string`posts.all.${props`postId`}`, props`file`, {\n    // Trigger a signal which receives payload\n    progress: signal`gallery.progress`\n    // Set progress on a state value\n    progress: state`gallery.progress`\n  }),\n\n  // Alternatively with explicit paths\n  put(string`posts.all.${props`postId`}`, props`file`, {\n    progress: signal`gallery.progress`\n    progress: state`gallery.progress`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```js\n{url: 'urlToFile', filename: 'nameOfFile'}\n```\n\n## delete\n\nUse `delete` to remove an uploaded file. Specify the containing folder and filename.\n\n*action*\n```js\nfunction someAction({ firebase, props }) {\n  return firebase.delete('folderName', props.fileName)\n}\n```\n\n*factory*\n```js\nimport {props, state, string} from 'cerebral/tags'\nimport {delete as firebaseDelete} from 'cerebral-provider-firebase/operators'\n\nexport default [\n  firebaseDelete(\n    string`posts.all.${props`postId`}`,\n    state`posts.all.${props`postId`}.imageName`\n  ),\n\n  // Alternatively with explicit paths\n  firebaseDelete(\n    string`posts.all.${props`postId`}`,\n    state`posts.all.${props`postId`}.imageName`\n  ), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\nNo output\n","title":"cerebral-provider-firebase"},"useragent":{"raw":"# cerebral-module-useragent\n\n## install\n\n**NPM**\n\n`npm install cerebral-module-useragent@next --save --save-exact`\n\n**YARN**\n\n`yarn add cerebral-module-useragent@next --exact`\n\n## description\nThe useragent module puts information about the browser into your state tree, and it also updates this information when this information changes.\n\n- UA parser: browser and device\n- Window: size & orientation\n- Media queries\n- Feature detection\n- Internet connectivity\n\n## instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport Useragent from 'cerebral-module-useragent'\n\nconst controller = Controller({\n  modules: {\n    useragent: Useragent({\n      // Use CSS media queries to determine\n      // custom sizes available in your model.\n      // They will be toggle between true/false in your\n      // model\n      media: {\n        small: '(min-width: 600px)',\n        medium: '(min-width: 1024px)',\n        large: '(min-width: 1440px)',\n        portrait: '(orientation: portrait)'\n      },\n\n      // store all feature tests in model\n      feature: true,\n\n      parse: {\n        // parse useragent.browser from ua string\n        browser: true,\n        // parse useragent.device from ua string\n        device: true\n      },\n\n      // check the docs at: https://github.com/HubSpot/offline#advanced\n      offline: {\n        checkOnLoad: false,\n        interceptRequests: true,\n        reconnect: {\n          initialDelay: 3,\n          delay: 1.5\n        },\n        requests: false\n      },\n\n      // update window size on resize\n      window: true\n    })\n  }\n})\n```\n","title":"cerebral-module-useragent"},"forms":{"raw":"# cerebral-provider-forms\n\n## install\n**NPM**\n\n`npm install cerebral-provider-forms@next --save --save-exact`\n\n**YARN**\n\n`yarn add cerebral-provider-forms@next --exact`\n\n## description\nThe forms provider allows you to easily compute forms based on a number of rules. Easily add new rules, error messages and, if you want, add whatever you want to your fields for custom logic.\n\n## instantiate\n\n```javascript\nimport {Controller} from 'cerebral'\nimport FormsProvider from 'cerebral-provider-forms'\n\nconst controller = Controller({\n  providers: [\n    FormsProvider({\n      // Add additional rules\n      rules: {\n        myAddedRule (value, form, arg) {\n          value // value of the field\n          form // the form field is attached to\n          arg // arg passed to the rule\n\n          return true\n        }\n      },\n\n      // errorMessage property added to field when invalid with the following rules\n      errorMessages: {\n        minLength (value, minLength) {\n          return `The length is ${value.length}, should be equal or more than ${minLength}`\n        }\n      }\n    })\n  ]\n})\n```\n\n## form\nA form is just an object in the state tree:\n\n```js\n{\n  myForm: {}\n}\n```\n\n## field\nA field is just an object with a `value` property:\n\n```js\n{\n  myForm: {\n    myField: {\n      value: ''\n    }\n  }\n}\n```\n\n## nesting\nYou can nest this however you want, even with array:\n\n```js\n{\n  myForm: {\n    firstName: {value: ''},\n    lastName: {value: ''},\n    address: [{\n      street: {value: ''},\n      zipCode: {value: ''}\n    }],\n    interests: {\n      books: {value: false},\n      films: {value: false}\n    }\n  }\n}\n```\n\n## compute\nTo use a form you use the **form** computed, pointing to the form. Typically:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {form} from 'cerebral-provider-forms'\n\nexport default connect({\n  form: form(state`path.to.form`)\n},\n  function MyForm ({form}) {\n    // Value of some field\n    form.someField.value\n    // A true/false if field has a value\n    form.someField.hasValue\n    // A true/false if field has been changed\n    form.someField.isPristine\n    // A true/false if field is valid\n    form.someField.isValid\n    // The name of the rule that failed\n    form.someField.failedRule.name\n    // Any arg you passed to the failing rule\n    form.someField.failedRule.arg\n    // If you have defined global error messages and field is invalid\n    form.someField.errorMessage\n    // Get all invalid fields\n    form.getInvalidFields()\n    // Get all fields\n    form.getFields()\n  }\n)\n```\n\nYou can also use the **field** computed, pointing to the field.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {field} from 'cerebral-provider-forms'\n\nexport default connect({\n  field: field(state`path.to.form.name`)\n},\n  function MyField ({field}) {\n    // Value of some field\n    field.value\n    // A true/false if field has a value\n    field.hasValue\n    // A true/false if field has been changed\n    field.isPristine\n    // A true/false if field is valid\n    field.isValid\n  }\n)\n```\n\n## provider\nYou can also access your forms in actions.\n\n```js\nfunction myAction ({forms}) {\n  const form = forms.get('path.to.form')\n}\n```\n\n### toJSON\nTypically you want to convert your forms to a plain value structure.\n\n```js\nfunction myAction ({forms}) {\n  const form = forms.toJSON('path.to.form')\n}\n```\n\nThis form will now have the structure of:\n\n```js\n{\n  myField: 'theValue',\n  address: {\n    street: 'street value',\n    zipCode: 'zip code value'\n  }\n}\n```\n\n### reset\nReset the form to its default values (or empty string by default).\n\n```js\nfunction myAction ({forms}) {\n  forms.reset('path.to.form')\n}\n```\n\n### updateRules\nDynamically update available rules:\n\n```js\nfunction myAction ({forms}) {\n  forms.updateRules({\n    someNewRule () {}\n  })\n}\n```\n\n### updateErrorMessages\nDynamically update global error messages:\n\n```js\nfunction myAction ({forms}) {\n  forms.updateErrorMessages({\n    someRule () {}\n  })\n}\n```\n\n## defaultValue\nYou can define a default value for your fields. When the form is **reset**, it will put back the default value:\n\n```js\n{\n  myForm: {\n    firstName: {\n      value: '',\n      defaultValue: 'Ben'\n    }\n  }\n}\n```\n\n## isRequired\nDefine field as required. This will make the field invalid if there is no value. By default forms identifies a value or not\nusing the **isValue** rule. You can change this rule if you want, look below.\n\n```js\n{\n  myForm: {\n    firstName: {\n      value: '',\n      isRequired: true\n    }\n  }\n}\n```\n\n## isValueRules\nYou can change what defines a field as having a value. For example if your value is an array, you can use the **minLength** rule to\ndefine a required minimum of 3 items in the array.\n\n```js\n{\n  myForm: {\n    interests: {\n      value: [],\n      isRequired: true,\n      isValueRules: ['minLength:3']\n    }\n  }\n}\n```\n\n## operators\n\n### setField\nWhen you change the value of a field you will need to use this operator. Note that you point to the field, not the field value.\n\n```js\nimport {state, props} from 'cerebral/tags'\nimport {setField} from 'cerebral-provider-forms/operators'\n\nexport default [\n  setField(state`my.form.field`, props`value`)\n]\n```\n\n### isValidForm\nDiverge execution based on validity of a form.\n\n```js\nimport {state} from 'cerebral/tags'\nimport {isValidForm} from 'cerebral-provider-forms/operators'\n\nexport default [\n  isValidForm(state`my.form`) {\n    true: [],\n    false: []\n  }\n]\n```\n\n### resetForm\nReset a form.\n\n```js\nimport {state} from 'cerebral/tags'\nimport {resetForm} from 'cerebral-provider-forms/operators'\n\nexport default [\n  resetForm(state`my.form`)\n]\n```\n\n## validationRules\nYou add validation rules on the field:\n\n```js\n{\n  myForm: {\n    firstName: {\n      value: '',\n      validationRules: ['minLength:3']\n    }\n  }\n}\n```\n\n### regexp\n```js\n{\n  field1: {\n    value: 'foo', // valid\n    validationRules: [/foo/]\n  },\n  field2: {\n    value: 'bar', // not valid\n    validationRules: [/foo/]\n  }\n}\n```\n\n### isExisty\n```js\n{\n  field1: {\n    value: 0, // valid\n    validationRules: ['isExisty']\n  },\n  field2: {\n    value: [], // valid\n    validationRules: ['isExisty']\n  },\n  field3: {\n    value: null, // not valid\n    validationRules: ['isExisty']\n  }\n}\n```\n\n### isUndefined\n```js\n{\n  field1: {\n    value: undefined, // valid\n    validationRules: ['isUndefined']\n  },\n  field2: {\n    value: 'hello', // not valid\n    validationRules: ['isUndefined']\n  },\n  field3: {\n    value: 123, // not valid\n    validationRules: ['isUndefined']\n  }\n}\n```\n\n### isEmpty\n```js\n{\n  field1: {\n    value: '', // valid\n    validationRules: ['isEmpty']\n  },\n  field2: {\n    value: 'hello', // not valid\n    validationRules: ['isEmpty']\n  },\n  field3: {\n    value: 123, // not valid\n    validationRules: ['isEmpty']\n  }\n}\n```\n\n### isEmail\n```js\n{\n  field1: {\n    value: 'ho@hep.co', // valid\n    validationRules: ['isEmail']\n  },\n  field2: {\n    value: 'hello@', // not valid\n    validationRules: ['isEmail']\n  },\n  field3: {\n    value: 'hel.co', // not valid\n    validationRules: ['isEmail']\n  }\n}\n```\n\n### isUrl\n```js\n{\n  field1: {\n    value: 'http://www.test.com', // valid\n    validationRules: ['isUrl']\n  },\n  field2: {\n    value: 'http://www', // not valid\n    validationRules: ['isUrl']\n  },\n  field3: {\n    value: 'http//www', // not valid\n    validationRules: ['isUrl']\n  }\n}\n```\n\n### isTrue\n```js\n{\n  field1: {\n    value: true, // valid\n    validationRules: ['isTrue']\n  },\n  field2: {\n    value: 'true', // not valid\n    validationRules: ['isTrue']\n  },\n  field3: {\n    value: false, // not valid\n    validationRules: ['isTrue']\n  }\n}\n```\n\n### isFalse\n```js\n{\n  field1: {\n    value: false, // valid\n    validationRules: ['isFalse']\n  },\n  field2: {\n    value: 'false', // not valid\n    validationRules: ['isFalse']\n  },\n  field3: {\n    value: true, // not valid\n    validationRules: ['isFalse']\n  }\n}\n```\n\n### isNumeric\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['isNumeric']\n  },\n  field2: {\n    value: 123, // valid\n    validationRules: ['isNumeric']\n  },\n  field3: {\n    value: '123abc', // not valid\n    validationRules: ['isNumeric']\n  }\n}\n```\n\n### isAlpha\n```js\n{\n  field1: {\n    value: 'abc', // valid\n    validationRules: ['isAlpha']\n  },\n  field2: {\n    value: 'AbC', // valid\n    validationRules: ['isAlpha']\n  },\n  field3: {\n    value: '123abc', // not valid\n    validationRules: ['isAlpha']\n  }\n}\n```\n\n### isAlphanumeric\n```js\n{\n  field1: {\n    value: '123abc', // valid\n    validationRules: ['isAlphanumeric']\n  },\n  field2: {\n    value: '123', // valid\n    validationRules: ['isAlphanumeric']\n  },\n  field3: {\n    value: '123+abc', // not valid\n    validationRules: ['isAlphanumeric']\n  }\n}\n```\n\n### isInt\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['isInt']\n  },\n  field2: {\n    value: 123, // valid\n    validationRules: ['isInt']\n  },\n  field3: {\n    value: '22.5', // not valid\n    validationRules: ['isInt']\n  }\n}\n```\n\n### isFloat\n```js\n{\n  field1: {\n    value: '22.5', // valid\n    validationRules: ['isFloat']\n  },\n  field2: {\n    value: 22.5, // valid\n    validationRules: ['isFloat']\n  },\n  field3: {\n    value: '22', // not valid\n    validationRules: ['isFloat']\n  }\n}\n```\n\n### isWords\n```js\n{\n  field1: {\n    value: 'hey there', // valid\n    validationRules: ['isWords']\n  },\n  field2: {\n    value: 'wut √•√§√∂', // not valid\n    validationRules: ['isWords']\n  },\n  field3: {\n    value: 'hm 123', // not valid\n    validationRules: ['isWords']\n  }\n}\n```\n\n### isSpecialWords\n```js\n{\n  field1: {\n    value: 'hey there', // valid\n    validationRules: ['isSpecialWords']\n  },\n  field2: {\n    value: 'some  √•√§√∂', // valid\n    validationRules: ['isSpecialWords']\n  },\n  field3: {\n    value: 'hm 123', // not valid\n    validationRules: ['isSpecialWords']\n  }\n}\n```\n\n### isLength:Number\n```js\n{\n  field1: {\n    value: 'hey', // valid\n    validationRules: ['isLength:3']\n  },\n  field2: {\n    value: ['foo', 'bar'], // valid\n    validationRules: ['isLength:2']\n  },\n  field3: {\n    value: 'hm 123', // not valid\n    validationRules: ['isLength:3']\n  }\n}\n```\n\n\n### equals:Value\n```js\n{\n  field1: {\n    value: 123, // valid\n    validationRules: ['equals:123']\n  },\n  field2: {\n    value: '123', // valid\n    validationRules: ['equals:\"123\"']\n  },\n  field3: {\n    value: [], // not valid\n    validationRules: ['equals:[]']\n  }\n}\n```\n\n### equalsField:Field\n```js\n{\n  field1: {\n    value: 'foo', // valid\n    validationRules: ['equalsField:field2']\n  },\n  field2: {\n    value: 'foo', // valid\n    validationRules: ['equalsField:field1']\n  },\n  field3: {\n    value: 'bar', // not valid\n    validationRules: ['equalsField:field2']\n  }\n}\n```\n\n### maxLength:Number\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['maxLength:3']\n  },\n  field2: {\n    value: 'fo', // valid\n    validationRules: ['maxLength:3']\n  },\n  field3: {\n    value: ['foo', 'bar', 'baz', 'mip'], // not valid\n    validationRules: ['maxLength:3']\n  }\n}\n```\n\n### minLength:Number\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['minLength:3']\n  },\n  field2: {\n    value: 'fo', // not valid\n    validationRules: ['minLength:3']\n  },\n  field3: {\n    value: ['foo', 'bar', 'baz', 'mip'], // valid\n    validationRules: ['minLength:3']\n  }\n}\n```\n\n### isValue\n```js\n{\n  field1: {\n    value: 'test', // valid\n    validationRules: ['isValue']\n  },\n  field2: {\n    value: [], // not valid\n    validationRules: ['isValue']\n  },\n  field3: {\n    value: null, // not valid\n    validationRules: ['isValue']\n  },\n  field3: {\n    value: false, // not valid\n    validationRules: ['isValue']\n  }\n}\n```\n","title":"cerebral-provider-forms"},"storage":{"raw":"# cerebral-provider-storage\n\n## install\n**NPM**\n\n`npm install cerebral-provider-storage@next --save --save-exact`\n\n**YARN**\n\n`yarn add cerebral-provider-storage@next --exact`\n\n## description\nThis module exposes local storage or session storage as a provider,\nwhere it by default parses and serializes to JSON.\n\n## API\n\n### instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport StorageProvider from 'cerebral-provider-storage'\n\nconst controller = Controller({\n  providers: [StorageProvider({\n    // instance of storage, can be window.localStorage / localStorage\n    // or window.sessionStorage / sessionStorage\n    target: localStorage\n    // Serializes and parses to JSON by default\n    json: true,\n    // Synchronize state when it changes\n    sync: {\n      'someStorageKey': 'some.state.path'\n    },\n    // Set prefix for storagekey \"somePrefix.someStorageKey\"\n    prefix: 'somePrefix'\n  })]\n})\n```\n\n### set\nWrite data to storage.\n\n*action*\n```javascript\nfunction someAction({storage}) {\n  storage.set('someKey', {foo: 'bar'})\n}\n```\n\n*factory*\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {setStorage} from 'cerebral-provider-storage/operators'\n\nexport default [\n  setStorage(state`currentStorageKey`, props`someData`)\n]\n```\n\n### get\nGet data from storage.\n\n*action*\n```javascript\nfunction someAction({storage}) {\n  const data = storage.get('someKey')\n}\n```\n\n*factory*\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {getStorage} from 'cerebral-provider-storage/operators'\n\nexport default [\n  getStorage('someKey'),\n  function someAction ({props}) {\n    props.value // Whatever was on \"someKey\"\n  }\n]\n```\n\n### remove\nRemove data from storage.\n\n*action*\n```javascript\nfunction someAction({storage}) {\n  storage.remove('someKey')\n}\n```\n\n*factory*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {removeStorage} from 'cerebral-provider-storage/operators'\n\nexport default [\n  removeStorage(state`currentStorageKey`)\n]\n```\n","title":"cerebral-provider-storage"},"function_tree":{"raw":"# function-tree\n\n## Install\n**NPM**\n\n`npm install function-tree@next --save --save-exact`\n\n**YARN**\n\n`yarn add function-tree@next --exact`\n\n## Description\nFunction-tree is the what Cerebral extends to create its signal implementation. Basically a function-tree allows you to execute a tree of functions. You can use the Cerebral debugger to debug function tree execution in any JS environment.\n\nFunction-tree is somewhat in the same family as Rxjs and Promises. The main difference is that Rxjs and Promises  are based on value transformation. That means only the value returned from the previous function is available in the next. This works when you indeed want to transform values, but events in your application are rarely about value transformation, they are about running side effects and going through one of multiple execution paths. Function tree embraces the fact that most of what we do in application development is running side effects.\n\nRxjs and Promises are also about execution control, but neither of them have declarative conditional execution paths, you have to write an *IF* or *SWITCH* statement or decouple streams. With function tree you are able to diverge the execution down paths just as declaratively as functions. This helps readability.\n\n## API\n\n### instantiate\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nconst ft = new FunctionTree({\n  // add side effect libraries to context\n})\n\nft.run([\n// returns a promise\n  function someFunc (context) {},\n  function someOtherFunc (context) {}\n], {\n  foo: 'bar' // optional payload\n})\n.catch((error) => {\n  // Current payload with execution details,\n  // can be passed in to a new execution (will be indicated in debugger)\n  error.payload\n\n  // A serialized version of the error. Name, message and stack, or custom error serialization\n  error.payload.error\n})\n```\n\nYou can also add multiple custom context providers by using an array:\n\n```js\nconst ft = new FunctionTree([{\n    // add side effect libraries to context\n  },\n  SomeCustomProvider()\n])\n```\n\n## errors\n\n### FunctionTreeError (base)\n```js\nimport {FunctionTreeError} from 'function-tree'\n// Node:\n// const FunctionTreeError = require('function-tree').FunctionTreeError\n\n// Error structure\n{\n  name: 'FunctionTreeError',\n  message: 'Some function-tree error'\n  stack: '...'  \n}\n```\n\n### FunctionTreeExecutionError\n```js\nimport {FunctionTreeExecutionError} from 'function-tree'\n// Node:\n// const FunctionTreeExecutionError = require('function-tree').FunctionTreeExecutionError\n\n// Error structure\n{\n  name: 'FunctionTreeExecutionError',\n  message: 'Some execution error'\n  execution: {name: 'someName'},\n  funcDetails: {name: 'someFunction', functionIndex: 5},\n  payload: {foo: 'bar'},\n  stack: '...'  \n}\n```\n\n### devtools\nDownload the function tree standalone debugger for [Mac](https://drive.google.com/file/d/0B1pYKovu9Upyb1Bkdm5IbkdBN3c/view?usp=sharing), [Windows](https://drive.google.com/file/d/0B1pYKovu9UpyMGRRbG45dWR6R1k/view?usp=sharing) or [Linux](https://drive.google.com/file/d/0B1pYKovu9UpyMFQ5dEdnSy1aN0E/view?usp=sharing).\n\n```js\nimport FunctionTree from 'function-tree'\nimport Devtools from 'function-tree/devtools'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n// const Devtools = require('function-tree/devtools').Devtools\n\nconst devtools = new Devtools({\n  // Set url of remote debugger\n  remoteDebugger: 'localhost:8585',\n\n  // By default debugger tries to reconnect when it is not active\n  reconnect: true\n})\nconst ft = new FunctionTree([])\n\n// Add your function tree to the debugger\ndevtools.add(ft)\n\n// If you are not going to use it anymore, remove it\ndevtools.remove(ft)\n\n// Remove all function trees from debugger\ndevtools.destroy()\n```\n\nYou can use it when creating providers to easily wrap their usage:\n\n```js\nfunction MyProvider (options = {}) {\n  let cachedProvider = null\n\n  function createProvider (context) {\n    return {\n      doSomething() {},\n      doSomethingElse() {}\n    }\n  }\n\n  return (context) => {\n    context.myProvider = cachedProvider = (cachedProvider || createProvider(context))\n\n    if (context.debugger) {\n      context.debugger.wrapProvider('myProvider')\n    }\n\n    return context\n  }\n}\n```\n\n### sequence\nYou can use an array literal to define a sequence of functions.\n\n```js\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = [\n  someFunction,\n  someOtherFunction\n]\n```\n\nOr you can be explicit by using the **sequence** function:\n\n```js\nimport {sequence} from 'function-tree'\n// Node:\n// const sequence = require('function-tree').sequence\n\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = sequence([\n  someFunction,\n  someOtherFunction\n])\n```\n\nThe first argument to **sequence** can be a string, which names the sequence. This will be shown in the debugger. If it is the root sequence it will be used as the name of the execution itself.\n\n```js\nimport {sequence} from 'function-tree'\n// Node:\n// const sequence = require('function-tree').sequence\n\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = sequence('My awesome sequence', [\n  someFunction,\n  someOtherFunction\n])\n```\n\n### parallel\n```js\nimport {parallel} from 'function-tree'\n// Node:\n// const sequence = require('function-tree').parallel\n\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = parallel([\n  someFunction,\n  someOtherFunction\n])\n```\n\nEven though **someFunction** returns a Promise, **someOtherFunction** will be run immediately.\n\n### context\n\n#### props\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nfunction funcA (context) {\n  context.props.foo // \"bar\"\n}\n\nconst ft = new FunctionTree()\nconst tree = [\n  funcA\n]\n\nft.run(tree, {foo: 'bar'})\n```\n\n#### path\nThe path is only available on the context when the function can diverge the execution down a path.\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nfunction funcA (context) {\n  context.props.foo // \"bar\"\n\n  return context.path.pathA({foo2: 'bar2'})\n}\n\nfunction funcB (context) {\n  context.props.foo // \"bar\"\n  context.props.foo2 // \"bar2\"\n\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({foo3: 'bar3'})\n    }, 100)\n  })\n}\n\nfunction funcC(context) {\n  context.props.foo // \"bar\"\n  context.props.foo2 // \"bar2\"\n  context.props.foo3 // \"bar3\"\n}\n\nconst ft = new FunctionTree([])\nconst tree = [\n  funcA, {\n    pathA: [\n      funcB,\n      funcC\n    ],\n    pathB: []\n  }\n]\n\nft.run(tree, {foo: 'bar'})\n```\n\n### error\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\nconst ft = new FunctionTree([])\n\n// As an event (async)\nft.on('error', function (error, execution, payload) {})\n\n// As callback for single execution\n// Triggers sync/async depending on where error occurs\nft.run(tree, (error) => {})\n\n// As callback (sync)\nft.run(tree, (error, execution, payload) => {\n  if (error) {\n    // There is an error\n  }\n})\n```\n\n### provider\nA provider gives you access to the current context and other information about the execution. It is required that you return the context or a mutated version of it.\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nfunction MyProvider(context, functionDetails, payload) {\n  context // Current context\n  context.props // Input created by the PropsProvider (default)\n\n  payload // The current payload (Used by PropsProvider)\n\n  functionDetails.name // Name of the function\n  functionDetails.functionIndex // The index of the function in the tree, like an ID\n  functionDetails.function // A reference to the running function\n  functionDetails.isParallel // If the function is running in parallel with others\n\n  context.execution.name // Function tree id\n  context.execution.id // Current execution id\n  context.execution.staticTree // The static representation of the tree\n  context.execution.datetime // Time of execution\n  context.execution.functionTree // The function tree instance\n\n  return context // Always return the changed context\n}\n\nconst ft = new FunctionTree([\n  MyProvider\n])\n```\n\nProviders lets us do some pretty amazing things. The debugger for **function-tree** is actually just a provider that sends information to the debugger about execution and exposes an API for other providers to send their own data to the debugger.\n\n#### StopExecutionProvider\nBy using a condition you can tell the function tree to stop executions.\n\n```js\nimport {StopExecutionProvider} from 'function-tree'\n// Node:\n// const StopExecutionProvider = require('function-tree').StopExecutionProvider\n\nconst ft = new FunctionTree([\n  StopExecutionProvider({\n    nameOfExecution (context) {\n      return context.props.stop\n    }\n  })\n])\n```\n\nIf the condition returns true the execution will throw an error and stop.\n\n### events\nThe execute function is also an event emitter.\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nconst ft = new FunctionTree([])\nconst tree = [\n  funcA\n]\n\n// When an error is thrown, also catches promise errors\nft.on('error', (error, execution, payload) => {})\n\n// When a function tree is executed\nft.on('start', (execution, payload) => {})\n\n// When a function tree execution has ended\nft.on('end', (execution, payload) => {})\n\n// When a function tree goes down a path\nft.on('pathStart', (execution, payload) => {})\n\n// When a function tree ends execution of a path\nft.on('pathEnd', (execution, payload) => {})\n\n// When a function in a function tree starts executing\nft.on('functionStart', (execution, functionDetails, payload) => {})\n\n// When a function in a function tree stops executing\nft.on('functionEnd', (execution, functionDetails, payload) => {})\n\n// Triggers when an async function has been run\nft.on('asyncFunction', (execution, functionDetails, payload) => {})\n\n// When a parallel execution is about to happen (array in array)\nft.on('parallelStart', (execution, payload, functionsToResolveCount) => {})\n\n// When a function in parallel execution is done executing\nft.on('parallelProgress', (execution, payload, functionsStillResolvingCount) => {})\n\n// When a parallel execution is done\nft.on('parallelEnd', (execution, payload, functionsExecutedCount) => {})\n\nft.run(tree)\n```\n","title":"function-tree"},"firebase_admin":{"raw":"# function-tree-firebase-admin\n\n## install\n**NPM**\n\n`npm install function-tree-firebase-admin@next --save --save-exact`\n\n**YARN**\n\n`yarn add function-tree-firebase-admin@next --exact`\n\n## description\nThe firebase admin package for function-tree allows you to easily handle Firebase Queues. With the Cerebral debugger you will even be able to merge execution data cross client/server. This package helps you set up a **QueueHandler** which registers your specs with queues and lets you know when new tasks are ready to be run.\n\n## Provider\nFirst you create a function tree with the Firebase provider. You will need to add the Devtools with the same port as the client to merge execution.\n\n```js\nconst FunctionTree = require('function-tree').FunctionTree\nconst Devtools = require('function-tree/devtools')\nconst FirebaseProvider = require('function-tree-firebase-admin').Provider\n\nconst devtools = Devtools({\n  // Connect to same port as the client to merge execution\n  remoteDebugger: 'localhost:8787'\n})\n\nconst runTask = new FunctionTree([\n  devtools.Provider(),\n  FirebaseProvider({\n    serviceAccount: {} // your service account details\n    databaseURL: '', // Your database url\n  })\n  /* Your other providers */\n])\n\ndevtools.watchExecution(runTask)\n\nmodule.exports = runTask\n```\n\n### value\nGet value. Outputs {key: 'theKey', value: 'theValue'}.\n```js\nfunction updateItems (context) {\n  return context.firebase.value('some/path')\n}\n```\n\n### transaction\nRun a transaction. Outputs nothing.\n```js\nfunction updateItems (context) {\n  return context.firebase.transaction('some/path', (maybeValue) => {\n    if (!maybeValue) {\n      return 'bar'\n    }\n\n    return context.props.data.foo\n  })\n}\n```\n\n### set\nSet new data. Output nothing.\n```js\nfunction addItem (context) {\n  return context.firebase.set(`items/${context.props.data.itemKey}`, context.props.data.item)\n}\n```\n\n### push\nPush new data. Outputs {key: 'keyAdded'}.\n```js\nfunction addItem (context) {\n  return context.firebase.push('items', context.props.data.item)\n}\n```\n\n### update\nUpdate multiple paths. Outputs nothing.\n```js\nfunction updateItems (context) {\n  return context.firebase.update({\n    'items/1': context.props.data.item1Data,\n    'items/2': context.props.data.item2Data\n  })\n}\n```\n\n### createKey\nCreate a new Firebase key at some path.\n```js\nfunction authenticate (context) {\n  const newKey = context.firebase.createKey('some/path')\n}\n```\n\n### deleteUser\nDelete a user from Firebase. Outputs nothing.\n```js\nfunction deleteProfile (context) {\n  return context.firebase.deleteUser(context.props.uid)\n}\n```\n\n### remove\nRemove key. Outputs nothing.\n```js\nfunction removeItem (context) {\n  return context.firebase.remove(`items/${context.props.itemKey}`)\n}\n```\n\n## QueueHandler\nThe QueueHandler is responsible for registering Firebase Queues with your defined specs and what trees should run when new tasks arrive in Firebase. The QueueHandler also automatically authenticates the tasks using **verifyIdToken**.\n\n```js\nconst runTask = require('./runTask')\nconst firebase = require('firebase-admin')\nconst username = require('username')\nconst QueueHandler = require('function-tree-firebase-admin').QueueHandler\n\nmodule.exports = new QueueHandler({\n  // If you are using a specPrefix on the client during development\n  // you will have to use it here as well, to pick up the correct\n  // queue tasks. It is automatically removed in production\n  specPrefix: username.sync(),\n\n  // An array of specs and corresponding trees to run\n  tasks: [{\n    specId: 'some_spec_name',\n    numWorkers: 100,\n    tree: [\n      /* Some tree to run */\n    ]\n  }],\n\n  // A reference in Firebase to your queue\n  queueRef: firebase.database().ref('queue')\n}, (specId, tree, payload) => {\n  runTask(specId, tree, payload)\n    .catch((error) => {\n      // Handle error. Payload has error property with details\n      runTask('ERROR', [/* A tree handling errors */], error.payload)\n    })\n});\n```\n\nWhen a task runs you have access to the following **props**:\n\n```js\nfunction someFunc (context) {\n  context.props.uid // Uid of user who made the task\n  context.props.data // Data passed from client\n  context.props.task.resolve // Resolve the task\n  context.props.task.reject // Reject the task\n}\n```\n\n## TestTasks\nYou can easily test tasks. The TestTasks includes a local [firebase-server](https://github.com/urish/firebase-server) and allows you to define a state of your Firebase instance before running tasks and assert its state after the tasks are run.\n\n```js\nconst TestTasks = require('function-tree-firebase-admin').TestTasks\n\nconst testTasks = new TestTasks([\n  /* Any mocked providers */\n])\n\nmodule.exports = testTasks\n```\n\nIn your test framework of choice:\n\n```js\nconst someTreeToRun = require('./someTreeToRun')\nconst test = require('./testTasks');\nconst assert = require('assert');\n\ndescribe('example', () => {\n  it('should test for foo', (done) => {\n    const runTest = test.create({\n      foo: 'bar'\n    }, {\n      // The tree to be run\n      task: someTreeToRun,\n\n      // Data to pass into tree execution\n      data: {\n        bip: 'bop'\n      }\n    }, (data) => {\n      assert.equal(data.foo, 'bar')\n    });\n\n    runTest(done)\n  })\n})\n```\n\nRun multiple tasks:\n\n```js\nconst someTreeToRun = require('./someTreeToRun')\nconst test = require('./testTasks');\nconst assert = require('assert');\n\ndescribe('example', () => {\n  it('should test for foo', (done) => {\n    const runTest = test.create({\n      foo: 'bar'\n    }, [{\n      task: someTreeToRun,\n      data: {\n        foo: 'bop'\n      },\n      // You can do assertions between running tasks\n      assert (data) {\n        assert.equal(data.foo, 'bop')\n      }\n    }, {\n      task: someTreeToRun,\n      data: {\n        foo: 'bap'\n      }\n    }], (data) => {\n      assert.equal(data.foo, 'bap')\n    });\n\n    runTest(done)\n  })\n})\n```\n","title":"function-tree-firebase-admin"}},"migration":{"index":{"raw":"# From 1.x to 2.x\n\nWhen migrating from 1.x to 2.x you need to take the following under consideration.\n\n- There are no models left to choose from. Cerebral now comes with one model.\n- Services have been removed in favor of function-tree/providers.\n\n## Controller\nInstead of choosing your model and connecting to the *Controller* as in 1.x as shown below\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nconst controller = Controller(Model({\n  // You can add some initial state here if you want\n}))\n\nexport default controller\n```\n\nYou would simply do the following in 2.x\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {\n    // You can add some initial state here if you want\n  }\n})\n\nexport default controller\n```\n\n**controller.getSignals()** is removed from 2.x so favor **controller.getSignal('some.signal')** instead.\n\n## Modules\nIn 1.x you would have done something like this\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  home: Home,\n  admin: Admin\n})\n\nexport default controller\n```\n\nIn 2.x the modules are defined along with the controller\n\n```js\nimport {Controller} from 'cerebral'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller({\n  modules: {\n    home: Home(),\n    admin: Admin()\n  }\n})\n\nexport default controller\n```\n\nSub-modules can be defined by each module in the same way (see below).\n\nIn 1.x you would create your own module like this\n\n```js\n// 1.x\nexport default module => {\n  module.addState({\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  })\n\n  module.addSignals({\n    newItemTitleSubmitted: submitNewItemTitle\n  })\n}\n```\n\naddState, addSignals have been removed, so in 2.x you simply return an object\n\n```js\n// 2.x\nexport default {\n  state: {\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  },\n  modules: {\n    subModule: SubModule()\n  },\n  signals: {\n    newItemTitleSubmitted: submitNewItemTitle\n  }\n}\n```\n\n## Operators\nThe biggest change to Cerebral 2.x is the operators. You can read more about them in the Operators docs. They have become very powerful and you can create your own operators. Operators in Cerebral 2.x has been moved into core Cerebral. You can still use the old operators if you want by installing them via npm.\n\n```js\nnpm install cerebral-operators --save\n```\n\nThe new operators now use tagged template literals and you can reduce number of actions and instead use the new operators. Here is a quick sample. As you can see you import them from 'cerebral/operators'\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  set(state`foo.bar`, props`bar`)\n]\n```\n\nOther operators include: wait, when, equals, debounce, push, pop, shift, toggle, unset, splice\n\n## Signals\nYou handle signals mostly the same way as in 1.x. You can describe signals in a module or in the controller directly.\n\n### 1.x\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral-model-immutable'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller(Model({}))\n\ncontroller.addSignals({\n  buttonClicked: doSomething,\n  fieldChanged: { immediate: true, chain: updateField }\n})\n```\n### 2.x\n```js\nimport {Controller} from 'cerebral'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller({\n  signals: {\n    buttonClicked: doSomething,\n    fieldChanged: updateField\n  }\n})\n```\n\nOne note when using signals is that the **immediate** option is gone. This keeps the api cleaner.\n\n## Actions\nSince cerebral 2.x is using **function-tree** under the hood we have other, more powerful options than before. The state is the same, but output is gone and input is renamed to props. You can just return an object from the action that will be available in the props for the next action. You can also return a **path** that is a new concept in Cerebral 2.x and outdates output. **path** is used to determine the execution path for your chain. You do no longer have services as an argument in the context, use providers instead.\n\n### 1.x\n```js\nfunction myAction({props, state, output, services}) {\n\n}\n```\n\nIn 2.x you have the following. Instead of services you hook up providers that supersedes services.\n\n```js\nfunction myAction({props, state, path /*, myProvider, otherProvider */ }) {\n\n}\n```\n\nWhen you wanted to output to paths in 1.x you would do something like this\n```js\nfunction myAction({state, output}) {\n  if (state.get('app.isAwesome')) {\n    output.awesome()\n  } else {\n    output.notSoAwesome()\n  }\n}\nmyAction.outputs = ['awesome', 'notSoAwesome']\n```\n\nWith the new **path** concept this is simpler. In 2.x you would just do what is stated below. Please note the **return path...**. The same is true with promises. They need to be returned.\n\n```js\nfunction myAction({state, path}) {\n  if (state.get('app.isAwesome')) {\n    return path.awesome()\n  } else {\n    return path.notSoAwesome()\n  }\n}\n```\n\nIf you don't want to take another path in the execution tree you could return a new object that would be available in the props object.\n\n```js\nfunction myAction({state, path}) {\n  return {\n    someData: 'Some new data available at output.someData'\n  }\n}\n```\n\nWhen doing async operations you would do something like this in 1.x\n\n```js\nfunction myAction({output}) {\n  setTimeout(() => {\n    output({ /* optional output */ }) // or output.pathName({ /* optional output */ })\n  }, 1000)\n}\n\nmyAction.async = true\n```\n\nIn Cerebral 2 you you must resolve or reject a returned promise.\n\n```js\nfunction myAction({path}) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n ¬† ¬†  resolve({ /* optional output */ }) // or resolve(path.pathName({ /* optional output */ }))\n    }, 1000)\n  })\n}\n```\n\nIn 1.x you could set a path that wasn't defined yet in the state tree. Let's say your state looked like this.\n\n```js\n{\n  app: {\n    nodes: {}\n  }\n}\n```\n\nYou could do this in an action.\n\n```js\nfunction myAction({state}) {\n  state.set('app.nodes.some.state.more', {updated: true})\n}\n```\n\nWith 2.x this is no longer possible. It's easy to mistype paths and therefore this option is no longer available. Your paths need to be in place before setting values to them.\n\nWhen using computed data in an action you could call **state.computed(myComputed())** in the action. This has changed in 2.x in favor of\n**state.compute(myComputed)**. You can also pass props to the compute function.\n\n```js\nfunction myAction({state}) {\n  state.compute(someComputed)\n  state.compute(someComputed.props({foo: 'bar'}))\n}\n```\n\nThis works the same in context for 2.x\n\n```js\nconnect({\n  foo: someComputed,\n  foo2: someComputedFactory({foo: 'bar'})\n})\n```\n\n## Providers (outdates services)\n\nIn 1.x you could add services that would be available to you in the actions. Typically, you would do something like this in 1.x\n\n```js\nimport someExternalApi from 'some-external-api'\n\nexport default (options = {}) => module => {\n\n  if (!options.apiKey) {\n    throw new Error('This service needs an apiKey')\n  }\n\n  module.addServices({\n    connect() {\n      return someExternalApi.connect({\n        apiKey: options.apiKey\n      })\n    }\n  })\n\n}\n```\n\nIn 2.x you would use providers instead.\n\n```js\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  providers: [\n    ContextProvider({\n      axios\n    })\n  ]\n})\n```\n\nor manually\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  provider(context) {\n    context.myProvider = {\n      doSomething() {}\n    }\n    return context\n  }\n})\n```\n\nNow instead of having services in the context object in an action you would have the **axios** object.\n\n```js\nfunction myAction({axios}) {\n\n}\n```\n\n## Views\nHow you import view specific packages has changed. In 1.x you would import Container like this.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral-view-react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x you would not import the Container from another package.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nThe same is true when connecting Cerebral to your component. In 1.x you would import it like this.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral-view-react'\n\nexport default connect({\n  isLoading: 'app.isLoading'\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 2.x you would have to use a different import.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 1.x you would first connect state, then signals as separate arguments in connect. In Cerebral 2.x these are combined, tags are used to differentiate between state, signals and props.\n\n```js\n// 2.x\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {props, state, signal} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`,\n  item: state`items.${props`itemId`}`,\n  someSignal: signal`app.someSignal`\n}.\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIf you really want all signals in props as in 1.x you can set this as an option in the controller.\n\n```js\n// 2.x\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  options: {\n     signalsProp: true\n   }\n})\n```\n\n\n##  Model\nThe following functions have been removed from Cerebral 2.x when using state inside an action\n\n- logModel\n- export\n- findWhere\n- keys\n- import\n- toJs\n- toJson\n\n## Strict render mode\nTo setup strict render mode in 1.x for React was specified as follows.\n\n```js\nrender(\n  <Container controller={controller} strict>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x this is the only mode\n\n## Devtools\nThe devtools has changed as well. Go to chrome store and install cerebral2 debugger. The setup has slightly changed from 1.x to 2.x as well as the import.\n\n### 1.x\n```js\nimport Controller from 'cerebral'\nimport Model from 'cerebral/model/immutable'\nimport Devtools from 'cerebral-module-devtools'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools()\n})\n\nexport default controller\n```\n\n### 2.x\n```js\nimport Controller from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools(),\n  modules: {\n    ...\n  }\n})\n\nexport default controller\n```\n","title":"From 1.x to 2.x"}},"api":{"index":{"raw":"# Controller\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  // Defines the top level state\n  state: {},\n\n  // Defines the top level signals\n  signals: {},\n\n  // Defines the top level modules\n  modules: {}\n})\n\nexport default controller\n```\n\n## Errors\n\n### Signal\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  signals: {\n    somethingHappened: {\n      signal: [somAction],\n      catch: new Map([\n        [SomeCustomErrorInstanceType, [someCustomCatchHandlerSequence]],\n        [Error, [someCatchHandlerSequence]]\n      ])\n    }\n  }\n})\n\nexport default controller\n```\n\n### Global\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  catch: new Map([\n    [SomeCustomErrorInstanceType, [someCustomCatchHandlerSequence]],\n    [Error, [someCatchHandlerSequence]]\n  ])\n})\n\nexport default controller\n```\n\nYou can also define a global error handler. This error handler will be called no matter if an error is caught or not. Useful for tracking failures in production.\n\n```js\ncontroller.on('error', (error) => {})\n```\n\n## Methods\n\n### getState(path)\nReturns state from the state tree\n\n```js\nconst someState = controller.getState('some.state')\n```\n\n### getSignal(path)\nReturns signal from Cerebral\n\n```js\nconst someSignal = controller.getSignal('some.signal')\n// Run signal\nsomeSignal({foo: 'bar'})\n```\n\n### getModel()\nReturns the model (state tree) of Cerebral\n\n```js\nconst model = controller.getModel()\n```\n\n### flush(force)\nFlushes out changes to UI based on recent state changes, can be forced\n\n```js\ncontroller.flush()\n```\n\n### runSignal(name, definition, payload)\nAllows you to run an arbitrary function tree definition\n\n```js\ncontroller.runSignal('someSignal', [actionA, actionB], {foo: 'bar'})\n```\n\n### addModule(path, module)\nAllows you to add modules to the controller after instantiation (lazy)\n\n```js\ncontroller.addModule('someModule', module)\n```\n\n### removeModule(path, module)\nAllows you to remove modules from the controller\n\n```js\ncontroller.removeModule('someModule')\n```\n\n## Events\n\n### initialized\nTriggers when Cerebral controller has initialized.\n\n```js\ncontroller.on('initialized', () => {})\n```\n\n### flush\nTriggered whenever Cerebral flushes out changes to the UI. Passes a map of changes.\n\n```js\ncontroller.on('flush', (changes) => {})\n```\n\n### start\nTriggered whenever Cerebral starts a signal execution.\n\n```js\ncontroller.on('start', (execution, payload) => {})\n```\n\n### end\nTriggered whenever Cerebral ends a signal execution.\n\n```js\ncontroller.on('end', (execution, payload) => {})\n```\n\n### pathStart\nTriggered whenever Cerebral starts execution a path in a signal\n\n```js\ncontroller.on('pathStart', (execution, payload) => {})\n```\n\n### pathEnd\nTriggered whenever Cerebral ends execution a path in a signal\n\n```js\ncontroller.on('pathEnd', (execution, payload) => {})\n```\n\n### functionStart\nTriggered whenever Cerebral starts executing an action.\n\n```js\ncontroller.on('functionStart', (execution, functionDetails, payload) => {})\n```\n\n### functionEnd\nTriggered whenever Cerebral ends executing an action.\n\n```js\ncontroller.on('functionEnd', (execution, functionDetails, payload) => {})\n```\n\n### asyncFunction\nTriggered whenever Cerebral executed an async action.\n\n```js\ncontroller.on('asyncFunction', (execution, functionDetails, payload) => {})\n```\n\n### parallelStart\nTriggered whenever Cerebral executes actions in parallel.\n\n```js\ncontroller.on('parallelStart', (execution, payload, functionsToResolveCount) => {})\n```\n\n### parallelProgress\nTriggered whenever Cerebral executes actions in parallel.\n\n```js\ncontroller.on('parallelProgress', (execution, payload, functionsStillResolvingCount) => {})\n```\n\n### parallelEnd\nTriggered whenever Cerebral ends executing actions in parallel.\n\n```js\ncontroller.on('parallelEnd', (execution, payload, functionsExecutedCount) => {})\n```\n\n### remember\nTriggered whenever Cerebral travels back in time. Passes the timestamp it travelled to.\n\n```js\ncontroller.on('remember', (datetime) => {})\n```\n","title":"Controller"},"sequence":{"raw":"# Sequence\nA sequence runs actions one after the other. If an action returns a promise it will hold until the promise is resolved or rejected.\n\nSimple format of a sequence is to use an array literal:\n```js\nimport someAction from '../actions/someAction'\n\nexport default [\n  someAction\n]\n```\n\nYou can explicitly create a sequence:\n```js\nimport {sequence} from 'cerebral'\nimport someAction from '../actions/someAction'\n\nexport default sequence([\n  someAction\n])\n```\n\nYou can name a sequence, which will be displayed in debugger:\n```js\nimport {sequence} from 'cerebral'\nimport someAction from '../actions/someAction'\n\nexport default sequence('my sequence', [\n  someAction\n])\n```\n\nYou can compose a sequence into existing sequence. The debugger will show this composition:\n```js\nimport someAction from '../actions/someAction'\nimport someOtherSequence from './someOtherSequence'\n\nexport default [\n  someAction,\n  someOtherSequence\n]\n```\n","title":"Sequence"},"parallel":{"raw":"# Parallel\nA parallel runs all actions right after each other, even if they return a promise.\n\n```js\nimport {parallel} from 'cerebral'\nimport someAsyncAction from '../actions/someAsyncAction'\nimport someOtherAsyncAction from '../actions/someOtherAsyncAction'\n\nexport default parallel([\n  someAsyncAction,\n  someOtherAsyncAction\n])\n```\n\nYou can name a parallel, which will be displayed in debugger:\n```js\nimport {parallel} from 'cerebral'\nimport someAsyncAction from '../actions/someAsyncAction'\nimport someOtherAsyncAction from '../actions/someOtherAsyncAction'\n\nexport default parallel('my parallel', [\n  someAsyncAction,\n  someOtherAsyncAction\n])\n```\n\nYou can compose parallel into any existing sequence:\n```js\nimport {parallel} from 'cerebral'\nimport someAction from '../actions/someAction'\nimport someAsyncAction from '../actions/someAsyncAction'\nimport someOtherAsyncAction from '../actions/someOtherAsyncAction'\n\nexport default [\n  someAction,\n  parallel('my parallel', [\n    someAsyncAction,\n    someOtherAsyncAction\n  ])\n]\n```\n","title":"Parallel"},"devtools":{"raw":"# Devtools\nYou can pass some options to the devtools to balance the processing and memory footprint:\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: process.env.NODE_ENV === 'production' ? null : Devtools({\n    // Connect to Electron debugger (external debugger). It will\n    // fall back to chrome extension if unable to connect\n    remoteDebugger: 'localhost:8585',\n\n    // By default the devtools tries to reconnect\n    // to debugger when it can not be reached, but\n    // you can turn it off\n    reconnect: true,\n\n    // Time travel\n    storeMutations: true,\n\n    // Warnings on mutating outside \"state\" API\n    preventExternalMutations: true,\n\n    // Shows a warning when you have components with number of\n    // state dependencies or signals above the set number  \n    bigComponentsWarning: 5,\n\n    // In addition to these basic JavaScript types: Object, Array, String, Number\n    // and Boolean, types of File, FileList, Blob, ImageData and RegExp is allowed to be stored in state\n    // tree. You can add additional types if you know what you are doing :)\n    allowedTypes: [\n     Blob\n    ]\n  })\n})\n```\n\nTurning these options to false will free up memory and CPU. Typically this is not an issue at all, but if you work with data heavy applications it might make a difference.\n","title":"Devtools"},"context":{"raw":"# Context\n\nWhen actions run they are passed a context. This context is created by Cerebral for every action run.\n\n```js\nfunction iAmAnAction (context) {}\n```\n\nThe context is populated by Cerebral and you can configure this by creating **providers**. By default Cerebral adds the following providers on the context.\n\n## Props\n\nWhen you trigger a signal you can pass it a payload. This payload is the starting point of the props to the signal. Given the signal:\n\n```js\n[\n  actionA,\n  actionB\n]\n```\n\n```js\nsomeSignal({\n  foo: 'bar'\n})\n```\n\nThe first action will receive the payload passed into the signal.\n\n```js\nfunction actionA ({props}) {\n  props // {foo: \"bar\"}\n\n  return {\n    bar: 'baz'\n  }\n}\n```\n\nBy returning a new object the next action will see an extended payload:\n\n```js\nfunction actionB ({props}) {\n  props // {foo: \"bar\", bar: \"baz\"}\n}\n```\n\nSo returning an object from actions, either directly or from a promise, extends the payload for later actions to handle.\n\n## State\nTo change the state of your application you use the state API. It is available to every action.\n\n```js\nfunction setSomething ({state}) {\n  state.set('some.path.foo', 'bar')\n}\n```\n\nAll common state operations are available as a method. Instead of first pointing to a value and then operate, you operate first and give the path to the value.\n\n```js\n// Traditional approach\nsomeArray.push('newItem')\n// With Cerebral\nstate.push('path.to.array', 'newItem')\n```\n\nThis is the one core concept of Cerebral that gives all its power. This simple approach allows for a few important things:\n\n1. Track mutations in the application so that it can be passed to the debugger\n2. Track mutations so that it can inform components depending on the changes\n3. Only allow mutations through the API, and nowhere else in the application (using freezing during development)\n\n## Path\nThe path on the context is only available if there is actually expressed a path after the action in question:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport actionC from '../actions/actionC'\n\nexport default [\n  actionA,\n  actionB, {\n    foo: [actionC]\n  }\n]\n```\n\nIn this scenario only *actionB* has the path on its context. As explained in **Chains and paths**, the path allows you to diverge execution of the signal.\n\n## Resolve\nWhen you ramp up your game with Cerebral you will most certainly take more advantage of **tags** and **computed** in your actions, typically related to action factories. To resolve an argument passed to a factory you can use resolve:\n\n```js\nfunction someActionFactory(someArgument) {\n  function someAction ({resolve}) {\n    // The argument can be anything, even plain values\n    const value = resolve.value(someArgument)\n  }\n\n  return someAction\n}\n```\n\nYou can also use resolve to check the value type and extract for example the path of tags:\n\n```js\nfunction someActionFactory(someArgument) {\n  function someAction ({resolve}) {\n    if (resolve.isTag(someArgument)) {\n      const path = resolve.path(someArgument)\n    }\n  }\n\n  return someAction\n}\n```\n\n\n## Controller\nYou have access to the controller instance on the context:\n\n```js\nfunction someAction ({controller}) {}\n```\n\n## Execution\nYou have access to function tree execution as well. This holds information about the current execution, mostly used by the devtools to inform the debugger.\n\n```js\nfunction someAction ({execution}) {}\n```\n","title":"Context"},"state":{"raw":"# State\n\n## Get state\nThe only way to get state in your application is by connecting it to a component or grabbing it in an action.\n\n```js\nfunction someAction({state}) {\n  // Get all state\n  const allState = state.get()\n  // Get by path\n  const stateAtSomePath = state.get('some.path')\n}\n```\n\n\n## Updating state\nThe only way to update the state of your application is in an action. Here is a list of all possible state mutations you can do:\n\n```js\nfunction someAction({state}) {\n  // Set or replace a value\n  state.set('some.path', 'someValue')\n  // Unset a key and its value\n  state.unset('some.path')\n  // Merge the keys and their values into existing object. Handled as a\n  // change on all paths merged in\n  state.merge('some.path', {\n    some: 'value'\n  })\n  // Pushes a value to the end of the array\n  state.push('some.path', 'someValue')\n  // Puts the value at the beginning of the array\n  state.unshift('some.path', 'someValue')\n  // Removes last item in array\n  state.pop('some.path')\n  // Removes first item in array\n  state.shift('some.path')\n  // Concats passed array to existing array\n  state.concat('some.path', ['someValueA', 'someValueB'])\n  // Splices arrays\n  state.splice('some.path', 2, 1)\n}\n```\n\n## Special values support\nWhen building an application you often need to keep things like files and blobs in your state for further processing. Cerebral supports these kinds of values because they will never change, or changing them can be used with existing state API. This is the list of supported types:\n\n- **File**\n- **FilesList**\n- **Blob**\n- **ImageData**\n- **RegExp**\n\nIf you want to force Cerebral to support other types as well, you can do that with a devtools option. This is perfectly okay, but remember all state changes has to be done through the state API.\n","title":"State"},"tags":{"raw":"# Tags\nTags allows you to target things in Cerebral. They are based on [template literal tags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals). They can be used by **operators**, **connect** and **compute**. Some of them can also be used with other Cerebral modules. The great thing about tags is their composability. For example:\n\n```js\nimport {state, props} from 'cerebral/tags'\n\nstate`items.${state`currentItemKey`}`\n\nstate`items.${props`itemKey`}`\n```\n\nThis allows you to express signals and component dependencies a lot more effectively. There are 4 tags in Cerebral.\n\n- **state** - Used in signals and connect to target state\n- **props** - Used in signals to target payload and in connect to target component props\n- **signal** - Used in signals and connect to target a signal\n- **string** - Used in signals to evaluate a composed string\n","title":"Tags"},"container":{"raw":"# Container\nExposes the controller to your components, allowing you to connect to it.\n\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Controller} from 'cerebral'\nimport {Container} from 'cerebral/react'\nimport App from './components/App'\n\nconst controller = Controller()\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n","title":"Container"},"connect":{"raw":"# Connect\n\n## Exposing state\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`\n},\n  function App(props) {\n    props.isLoading\n  }\n)\n```\n\nExpose state based on props passed to component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, props} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`${props`module`}.isLoading`\n},\n  function App(props) {\n    props.isLoading\n  }\n)\n```\n\n## Exposing signals\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {signal} from 'cerebral/tags'\n\nexport default connect({\n  clicked: signal`app.somethingClicked`\n},\n  function App(props) {\n    props.clicked\n  }\n)\n```\n\nExpose signals based on props passed to component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {signal, props} from 'cerebral/tags'\n\nexport default connect({\n  clicked: signal`${props.module}.somethingClicked`\n},\n  function App(props) {\n    props.clicked\n  }\n)\n```\n\n## Optimize rendering\nDue to Cerebrals \"render on path change\" it is possible to optimize component rendering.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  array: state`app.array.*`,\n  map: state`app.map.*`,\n},\n  function App (props) {\n    props.list // [0, 1, 2, 3]\n    props.map // ['foo', 'bar']\n  }\n)\n```\n\nThis component will only render when any keys are added or removed, meaning that nested change to a child does not cause a new render.\n\n## Override props\nYou can add an additional function to connect that gives you full control of properties of the component and dependencies. The returned object from this function will be the exact props passed into the component.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {signal, state} from 'cerebral/tags'\n\nexport default connect({\n  foo: signal`app.foo`,\n  clicked: signal`app.somethingClicked`\n}, (dependencyProps, ownProps, resolve) => {\n  return {}\n},\n  function App(props) {\n\n  }\n)\n```\n\n**dependencyProps** are the props you connected.\n\n**props** are the props passed into the component by the parent.\n\n**resolve** allows you to resolve computed etc., just like resolve in actions.\n","title":"Connect"},"modules":{"raw":"# Modules\n\nA module is basically an object. Modules helps you structure your state and signals. You can think of them as namespaces for state and signals.\n\n```js\nexport default {\n  // Define module state, namespaced by module path\n  state: {},\n  // Define module signals, namespaced by module path\n  signals: {},\n  // Define submodules, namespaced by module path\n  modules: {},\n  // Add a global provider when module instantiates\n  provider(context, functionDetails, payload) {}\n}\n```\n\nIt is also possible to define a module using a function.\n\n```js\nexport default (module) => {\n  module.name // Name of module\n  module.path // Full path to module\n  module.controller // The controller the module is attached to\n\n  return {\n    state: {},\n    signals: {},\n    modules: {},\n    provider(context, functionDetails, payload) {}\n  }\n}\n```\n\nYou attach a module simply by referencing it:\n\n```js\nimport {Controller} from 'cerebral'\nimport FeedModule from './modules/Feed'\n\nconst controller = Controller({\n  modules: {\n    feed: FeedModule\n  }\n})\n```\n","title":"Modules"},"operators":{"raw":"# Operators\nYou can call operators to create actions for you. These actions will help you change state and control the flow of execution.\n\n## State operators\n\nThe methods for changing state within actions is also available as operators. All state operators support using both **state** and **props** tags as values.\n\nAll operators are imported as members of the 'cerebral/operators' module. For example, this imports **state** and **set**:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n```\n\n### concat\n\nConcatenate a value to an array\n\n```js\nconcat(state`some.list`, ['foo', 'bar'])\n```\n\n### merge\n\nMerge objects into existing value. If no value exists, an empty object will be created. Merge supports using operator tags on key values:\n\n```js\nmerge(state`clients.$draft`, props`newDraft`, {\n  foo: 'bar',\n  bar: props`baz`\n})\n```\n\n### pop\n\nPop a value off an array (removes last element from array).\n\n```js\npop(state`some.list`)\n```\n\n### push\n\nPush value into an array (adds the element at the end of the array).\n\n```js\npush(state`some.list`, 'foo')\n```\n\n### set\n\nSet a target value in the state or props.\n\n```js\nset(state`foo.bar`, true),\nset(props`foo`, true)\n```\n\n### shift\n\nShift a value off an array (removes first element in array).\n\n```js\nshift(state`some.list`),\n```\n\n### splice\n\nSplice an array in place.\n\n```js\nsplice(state`some.list`, 0, 2)\n```\n\n### toggle\n\nToggle a boolean value.\n\n```js\ntoggle(state`user.$toolbar`)\n```\n\n### unset\n\nUnset key from object.\n\n```js\nunset(state`clients.all.${props`key`}`)\n```\n\n### unshift\n\nUnshift a value into an array (adds the element at the start of the array).\n\n```js\nunshift(state`some.list`, 'foo')\n```\n\n## Flow control operators\n\nThese operators help control the execution flow.\n\n### equals\n\nThis operator chooses a specific path based on the provided value.\n\n```js\nimport {equals} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  equals(state`user.role`), {\n    admin: [],\n    user: [],\n    otherwise: [] // When no match\n  }\n],\n```\n\n### debounce\n\nHold action until the given amount of time in milliseconds has passed. If the\nsignal triggers again within this time frame, the previous signal goes down the\n\"discard\" path while the new signal holds for the given time. This is\ntypically used for typeahead functionality. For a debounce that is shared\nacross different signals, you can use `debounce.shared()` (see example below).\n\nPlease note that the `discard` path has to be present even if it is most often\nempty because debounce is a flow operator that routes the flow depending on\ntime and action trigger.\n\n```js\nimport {debounce} 'cerebral/operators'\n\nexport default [\n  debounce(200), {\n    continue: [runThisAction],\n    discard: []\n  },\n]\n```\n\n`debounce.shared()` is typically used with factories, for example to show\nnotifications where a previous notification should be cancelled by a new one.\n\n```js\nimport {debounce, set, unset} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nconst sharedDebounce = debounce.share()\nfunction showNotificationFactory(message, ms) {\n  return [\n    set(state`notification`, message),\n    sharedDebounce(ms), {\n      continue: [unset(state`notification`)],\n      discard: []\n    }\n  ]\n}\n```\n\nNow when this notification factory is used in different signals, the call to\n`debounceShared` will share the same debounce execution state:\n\n```js\nimport showNotification from './showNotification'\n\nexport default [\n  // ... user log in, etc\n  ...showNotification('User logged in', 5000)\n]\n```\n\n### wait\n\nWait for the given time in milliseconds and then continue chain.\n\n```js\nimport {wait} from 'cerebral/operators'\n\nexport default [\n  wait(200),\n  doSomethingAfterWaiting\n]\n```\n\nIf you need to wait while executing in parallel, you should use a `continue`\npath to isolate the actions to be run:\n\n```js\nimport {wait} from 'cerebral/operators'\nimport {parallel} from 'cerebral'\n\nexport default \n  someAction,\n  parallel('my parallel with wait', [\n    wait(200), {\n      continue: [doSomethingAfterWaiting]\n    },\n    otherActionInParallel\n  ])\n]\n```\n\n### when\n\nRun signal path depending on a truth value or function evaluation.\n\n```js\nimport {when} from 'cerebral/operators'\n\nexport default [\n  when(state`foo.isAwesome`), {\n    true: [],\n    false: []\n  },\n  // You can also pass your own function\n  when(state`foo.isAwesome`, (value) => value.length === 3 ), {\n    true: [],\n    false: []\n  }\n]\n```\n\nWhen used with a truth function, the `when` operator supports more then a single\n\"value\" argument. The truth function must come last.\n\n```js\nimport {when} from 'cerebral/operators'\nimport {props, state} from 'cerebral/tags'\n\nexport default [\n  when(state`clients.$draft.key`, props`key`,\n    (draftKey, updatedKey) => draftKey === updatedKey\n  ), {\n    true: [\n      // Another person edited client, reset form to new value\n      set(state`clients.$draft`, props`value`)\n    ],\n    false: []\n  }\n]\n```\n","title":"Operators"},"providers":{"raw":"# Providers\n\nProviders are functions that runs before any action in any signal. Their purpose is to define and sometimes manipulate the context passed into every action. The providers run before every action, meaning that each action has a unique context object.\n\nTo add something to the context you create a provider:\n\n```js\nfunction MyProvider (context, functionDetails, payload, prevPayload) {\n  // The current context object, which can be mutated\n  context\n\n  // The details of the action running, like name, index (id) etc.\n  functionDetails\n\n  // The current payload passed to the action\n  payload\n\n  // The previous payload\n  prevPayload\n\n  // You have to return the context after it has bee mutated\n  return context\n}\n```\n\nThere are a few things already available on the context when your provider runs:\n\n```js\nfunction MyProvider(context) {\n  context.execution // Information on the function tree execution\n  context.controller // The Cerebral controller\n  context.debugger // If devtools is added, you can send messages to the debugger\n  context.props // Current payload\n  context.path // If any paths are defined after the action to be executed\n  context.state // The state API\n  context.resolve // Resolve values and tag paths\n\n  return context\n}\n```\n","title":"Providers"},"compute":{"raw":"# Compute\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default compute(\n  state`user.name`,\n  (name) => {\n    return `Hi ${name}`\n  }  \n)\n```\n\nA compute takes any number and type of arguments, where each argument is passed to the next function argument.\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\nimport someOtherComputed from './someOtherComputed'\n\nexport default compute(\n  state`user.name`,\n  'foo',\n  (name, foo) => {\n    return `Hi ${name}`\n  },\n  someOtherComputed,\n  (computedHello, someOtherComputedValue) => {\n    return `${computedHello} - ${someOtherComputedValue}`\n  }\n)\n```\n\nThat last argument of each function is **get**, it allows you to manually extract state and props.\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default compute(\n  state`user.id`,\n  (userId, get) => {\n    return get(state`projects.${userId}`).length > get(props`limit`)\n  }  \n)\n```\n","title":"Compute"},"statecontainer":{"raw":"# StateContainer\n\n\"Can I use Cerebral on the server?\". Yes, technically you can, but you actually should not. Cerebral is a framework for building applications with user interfaces. Running code related to talking to a server on the server does not really make sense. What does make sense though is pre-rendering and handle complex flows on server side logic.\n\n## Pre-rendering\nBoth [react](https://facebook.github.io/react/) and [inferno](https://github.com/trueadm/inferno) supports rendering your application on the server. But that does not mean your application runs on the server. The only thing you need to pre-render your application is state. The **StateContainer** allows you to render your application by just passing an object as the state of your app:\n\n```js\nimport {StateContainer} from 'cerebral/react'\nimport {renderToString} from 'react-dom/server'\n\nconst html = renderToString(\n  <StateContainer state={someServerCreatedState}>\n    <App />\n  </StateContainer>\n)\n```\n\nInstead of passing the Cerebral controller to the container, you just pass it the state of the application. This will render your application in the correct state. How you produce this state is up to you though. Applications are very different related to producing state on the server so there is not \"one answer\" here.\n\nIt might be a good idea to define the state of your application in one file, instead of using modules:\n\n```js\nexport default {\n  app: {},\n  posts: {}\n}\n```\n\nThis way you can import the same state file on your client and on the server. On the server you just populate the missing state.\n\n## Business logic\nYou might also be tempted to use Cerebral to handle server side business logic. But Cerebral is actually a small wrapper around [function-tree](https://github.com/cerebral/function-tree). Function-tree has its own debugger and gives you more flexibility in handling complexities on the server as well.\n","title":"StateContainer"}}}