{"install":{"index":{"raw":"# Cerebral\n\nTo install Cerebral you need to use the Node Package Manager. NPM is part of [Node](https://nodejs.org/en/), so please install that on your computer first. You should install Node version 5 or later. If you are not familiar with Node and/or Webpack it can be a good idea to start out with [the tutorial](../tutorial/01_introduction.html).\n\nTo install Cerebral Alpha you have to explicitly install Cerebral and its dependency:\n\n`npm install cerebral@next --save --save-exact`\n","title":"Cerebral"},"debugger":{"raw":"# Debugger\n\nCerebral has a powerful development tool. It knows about all the state in your application, all the state updates, side effects run, state paths currently active in your components and when they render. All the things Cerebral helps you with, it visualizes in the debugger.\n\n## Install debugger\nThe Cerebral debugger is a standalone application and a chrome extension. You can use both if you want, as the chrome extension is the fallback if the standalone debugger is not opened. You can install the chrome extension from [the google store](https://chrome.google.com/webstore/detail/cerebral2-debugger/ghoadjdodkgkbbmhhpbfhgikjgjelojc).\n\nThe standalone debugger connects to your application through websockets. You will need to configure the **devtools** for this purpose (see below). Download and extract the zip for your target OS: [Mac](https://docs.google.com/uc?id=0B1pYKovu9UpybHRMRm9YZU10WUU&export=download), [Windows](https://docs.google.com/uc?id=0B1pYKovu9UpyU0lkU2UyWklMV28&export=download) or [Linux](https://docs.google.com/uc?id=0B1pYKovu9UpyWE85UWVHNFRCQkk&export=download)\n\n## Initialize the devtools\nYou initialize the devtools by adding it to the controller.\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  // You do not want to run the devtools in production as it\n  // requires a bit of processing and memory to send data from\n  // your application\n  devtools: (\n    process.env.NODE_ENV === 'production' ?\n      null\n    :\n      Devtools({\n        // If running standalone debugger\n        remoteDebugger: 'localhost:8585'\n      })\n  )\n})\n```\n\nYou can pass some options to the devtools to balance the processing and memory footprint:\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: process.env.NODE_ENV === 'production' ? null : Devtools({\n    // Connect to Electron debugger (external debugger). It will\n    // fall back to chrome extension if unable to connect\n    remoteDebugger: 'localhost:8585',\n\n    // Time travel\n    storeMutations: true,\n\n    // Warnings on mutating outside \"state\" API\n    preventExternalMutations: true,\n\n    // Warnings when strict render path usage is wrong\n    verifyStrictRender: true,\n\n    // Throw error when overwriting existing input property\n    preventInputPropReplacement: false,\n\n    // Turn off the warning of not pointing to children of\n    // objects/arrays when declearing state dependencies\n    preventDependencyWarning: false,\n\n    // Shows a warning when you have components with number of\n    // state dependencies or signals above the set number  \n    bigComponentsWarning: 5,\n\n    // Will reset debugger to currently focused application\n    multipleApps: true,\n\n    // In addition to basic JavaScript types Object, Array, String, Number\n    // and Boolean, File, FileList and Blob is allowed to be stored in state\n    // tree. You can add additional types if you know what you are doing :)\n    allowedTypes: []\n  })\n})\n```\n\nTurning these options to false will free up memory and CPU. Typically this is not an issue at all, but if you work with data heavy applications it might make a difference.\n","title":"Debugger"},"boilerplate":{"raw":"# Boilerplates\n\n## create-react-app\n\nFacebook released a boilerplating tool for React, called [create-react-app](https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html). As a beginner it can be a good idea to create a project with create-react-app first and install Cerebral as instructed in [Install Cerebral](01_cerebral.html).\n","title":"Boilerplates"},"tools":{"raw":"# Tools\nCerebral comes with official and community made tools.\n\n## cerebral-forms\nA simple and insightful way to handle the complexity of form validation.\n\n[Go to repo](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-forms)\n\n## cerebral-module-useragent\nProduces state related to useragent, media, window size, network status etc.\n\n[Go to repo](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-module-useragent)\n\n##  cerebral-provider-firebase\nA simplifying wrapper around firebase client, making developing firebase applications a breeze\n\n[Go to repo](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-provider-firebase)\n\n## cerebral-provider-http\nA JSON http provider with file upload and ability to abort requests\n\n[Go to repo](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-provider-http)\n","title":"Tools"},"function_tree":{"raw":"# Function Tree\nYou might want to use the low level [function-tree](https://github.com/cerebral/cerebral/tree/master/packages/function-tree) project, which Cerebral wraps. Especially on the server, function-tree and its debugger will help you express complex logic and debug it.\n\n`npm install function-tree@next --save`\n\n### Debugger\nFunction tree currently only has a standalone debugger for [Mac](https://drive.google.com/open?id=0B1pYKovu9UpybFc1YUxOT3JlaVE), [Windows](https://drive.google.com/open?id=0B1pYKovu9UpyUWt6SHM5N2xYYnc) and [Linux](https://drive.google.com/open?id=0B1pYKovu9UpybzVJWjVpRk9OTjg).\n","title":"Function Tree"}},"tutorial":{"index":{"raw":"# Introduction\n\nRequirements for this tutorial is that you have [Node](https://nodejs.org/en/) version 5 or higher installed. You would definitely benefit from a fresh cup of coffee or a beer as well, ready to learn something new :)\n\nThis tutorial will take you through the core concepts of Cerebral.\n\n## Step 1\nTo get started you will need to clone the cerebral Github repository. To do so you need [git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) installed, or the [Github desktop](https://desktop.github.com/) client. Now clone the repo to a folder on your computer, either by command line:\n\n`git clone https://github.com/cerebral/cerebral.git`\n\nor using the desktop application.\n\n## Step 2\nThen go to directory **cerebral/docs/tutorial** and run the command:\n\n`npm install`\n\n## Step 3 (Alpha note)\nDuring the alpha you also need to do the following after the install:\n\n`npm install cerebral@next function-tree@next cerebral-provider-http@next cerebral-router@next --save --save-exact`\n\nThis may take a little while and does **not** mean that Cerebral is a huge download. In fact Cerebral as a production build is very small compared to other popular frameworks.\n\n## The features\nOur Goal now is to go through some concepts and show off the features of Cerebral:\n\n- **Controller**\n- **State**\n- **Signals**\n- **Connect**\n- **Providers**\n- **Routing**\n\nThey are all explained in depth in the [In depth](../in-depth/01_the-architecture.html) section.\n\n## How does this tutorial work?\nTo start the tutorial, run:\n\n`npm start`\n\nThis fires up the actual development server. Go to your browser and *localhost:3000*. It also provides you a list of the chapters directly in the terminal. Just change chapters there when you want to move on. The application running in the browser will update.\n\nFor beginners in web development we have the following advice: Just follow the tutorial, don't get too much distracted by advanced concepts. Learning new things takes some iterations and often it is more helpful to try to build something yourself. Please head over to our [discord chat](https://discord.gg/0kIweV4bd2bwwsvH) and we are more than happy to help you out.\n\n### Structure and bootstrapping\n\n```\n.\n├── public\n|\t├── index.html\n|   \n├── src\n|\t├── components\n|\t|\t├── App\n|\t|\t├── ...\n|\t|\t├── ...\t\t\n|\t|\n|\t└── index.js\n|\n├── DO_NOT_TOUCH\n| ├── 01\n| | ├── ...\n| ├── 02\n| | ├── ...\n| ├── ...\n|\n├── package.json\n├── ...\n```\n#### The components - folder\nCurrently holds App, a React component which is responsible for the title you are seeing. There will be more components in here as we move on in the tutorial.\n\n#### The index.html - file\n```html\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <link rel=\"stylesheet\" href=\"blaze.min.css\">\n    <link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\">\n    <title>Cerebral Tutorial</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n\n```\nNothing special as you can see, though you might wonder where the magic actually starts? This file is actually a template file used by [Webpack](https://webpack.github.io/), the tool the builds your application. It will automatically inject your application into this HTML file when the development server starts.\n\n#### The index.js - file\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Controller} from 'cerebral'\nimport App from './components/App'\nimport {Container} from 'cerebral/react'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: Devtools()\n})\n\nrender((\n  <Container controller={controller}>\n    <App/>\n  </Container>\n), document.querySelector('#root'))\n```\nThis the entry point of your application and this is where we bring it all together.\n\n1. We import the necessary dependencies for our application to run\n2. We instantiate a Cerebral controller and the **Devtools** which will give us a lot of insight into our running application\n3. We render the application using React by exposing the **controller** through a **Container** wrapper\n\nIf you are not familiar with [JSX](https://facebook.github.io/react/docs/jsx-in-depth.html), the syntax that looks like HTML, it can be explained briefly as \"some sugar over normal JavaScript\". This is **not** html in JavaScript, it is pure JavaScript, it just allows you to define the UI with familiar syntax. You might think this is \"icky\", but trust us... UIs has become a lot more complex over the years and we need the power of JavaScript to describe and manage them!\n\n### Installing the debugger\nPlease install either the standalone or chrome extension debugger, following [these instructions](../get-started/02_debugger.html)\n","title":"Introduction"},"define_state":{"raw":"# Define State\n\n**Load up chapter 01** - [Preview](01)\n\nAll interactive user interfaces needs **state** in one way or another. Cerebral stores this state in something we call a **state tree**. The state tree is the description of the state your application is in. Since Cerebral uses a state tree the debugger can visualize the whole state description of the application.\n\nYou might be more familiar with frameworks where state is described with classes, either multiple model classes and/or components. In Cerebral you do not put state into multiple models or components. The state is not wrapped in classes either. You have this one state tree where you insert plain values. Objects, arrays, strings, numbers and boolean. There is no \"right way\" to do things, but using a single state tree and store all the state of our application in that tree gives you the ability to read, write and explore all the state of your application coherently. This approach also gives other benefits not possible with the class approach.\n\nTo define the initial state of the application all we need to do is to is add it to our **Controller** in *src/index.js*\n\n```js\n...\nconst controller = Controller({\n  devtools: Devtools(),\n  state: {\n    title: 'Hello from Cerebral!'\n  }\n})\n...\n```\n\nThats it! The application should automatically reload and you will see this state in the Chrome debugger.\n\n\n**Want to dive deeper?** - [Go in depth](../in-depth/03_state.html), or move on with the tutorial\n","title":"Define State"},"render_state":{"raw":"# Render state\n\n**Load up chapter 02** - [Preview](02)\n\nNow lets get that state displayed in our application.\nFirst of all we need to tell our component (App) to **connect** to the state.\n\nSo please change the *src/components/App/index.js* to:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`\n},\n  function App (props) {\n    return (\n      <div className=\"o-container o-container--medium\">\n        <h1>{props.title}</h1>\n      </div>\n    )\n  }\n)\n```\n\nAnd voilà, your application should now display the title state. And this is the essence of creating web applications. We define state and how that state should be displayed in the user interface.\n\nWe used something called a **tag** to define our state dependency. If you are unfamiliar with [template literals and template literal tags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) in JavaScript, you should read about them or just accept their awesome power :)\n\nBut our application does not do much. We have to introduce the concept of change. With the debugger we can actually force a change to our state and make the UI update. Click the title state in the debugger, change it and hit enter. You will see the application display your changed state.\n\nThanks to...\n```js\nconnect({\n  title: state`title`\n}, ...)\n```\n...we told Cerebral that this component is interested in the value on the path **title**, and we wanted it exposed as **title** to our component as well. Because this component now depends on the **title** state it gets rendered whenever the path has a change.\n\nCongratulations, you have now created application state and exposed it to a component. You have now gained the power of translating the state of the application into something a user can understand. You will notice with Cerebral that this is a very clear separation. You define your application state in Cerebral and you use components to translate this state into a user interface.\n\n## The signature\nLet us quickly talk about the syntax before moving on. The signature of connect most commonly uses two arguments:\n\n**connect(dependencies, Component)**\n\nWe usually write this out as:\n\n```js\nconnect({\n  title: state`title`\n},\n  function App (props) {\n    return (\n      <div className=\"o-container o-container--medium\">\n        <h1>{props.title}</h1>\n      </div>\n    )\n  }\n)\n```\n\nCause it just looks nicer. It is also very nice to read the dependencies of your component first and then what the component does with those dependencies.\n\n## Challenge\n\nIt's time for your first challenge!\n\n- Add another state to the store called *subTitle*\n- Connect *subTitle* to the App component and display it in a *H3* element\n\n**Want to dive deeper?** - [Go in depth](../in-depth/10_connect.html), or move on with the tutorial\n","title":"Render state"},"update_state":{"raw":"# Update state\n\n**Load up chapter 03** - [Preview](03)\n\nDefining state and user interfaces is more about describing how something should look, rather than how it should update. Updates are the tricky part, this is where we usually introduce complexity in our applications.\n\nCerebral allows you to describe updates the same way you describe state and user interfaces, in a declarative manner. We call them **signals** and they will help you handle complexity both in code and in your head, trying to reason about how your application works.\n\n## Adding a signal\nLet us add a signal to our Controller in **src/index.js**:\n\n```js\nimport {set} from 'cerebral/operators'\n...\n...\n...\nconst controller = Controller({\n  devtools: Devtools(),\n  state: {\n    title: 'Hello from Cerebral!',\n    subTitle: 'Working on my state management'\n  },\n  signals: {\n    buttonClicked: [\n      function updateSubtitle ({state}) {\n        state.set('subTitle', 'Updating some state')\n      }\n    ]\n  }\n})\n```\nWe now defined a signal named **buttonClicked**. The signal tells us \"what happened to make this signal run\". A signal is defined using an array containing functions. What we want to happen when this signal triggers is to update the **subTitle** in our state with a static value. We do this by defining a function inline into the signal definition. Normally you define this in a separate file. The **updateSubtitle** function is one of possibly multiple functions that will run when **buttonClicked** runs.\n\nAs you can see functions in a signal receives an argument, which we [destructure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) to grab the *state*. The argument itself is called the **context**. So **input** is on the **context**.\n\n## Trigger the change\nPlease take a closer look at *./src/components/App/index.js*:\n\n```js\n...\nconnect({\n  title: state`title`,\n  subTitle: state`subTitle`\n},\n  ...\n)\n```\nAs you can see the App-Component depends on **subTitle**. That means it will render automatically whenever **subTitle** changes. Because our **updateSubtitle** function changes the path **subTitle**, Cerebral just knows which components need to update and thus there is no dirty checking or other value comparison needed.\n\nTo trigger the signal we need to wire up a click-handler on a button and add our signal **buttonClicked** to the **connect(..)** method (*./src/components/App/index.js*):\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  buttonClicked: signal`buttonClicked`\n},\n  function App (props) {\n    return (\n      <div className=\"o-container o-container--medium\">\n        <h1>{props.title}</h1>\n        <h3>{props.subTitle}</h3>\n        <button\n          className=\"c-button c-button--info c-button--block\"\n          onClick={() => props.buttonClicked()}\n        >\n          Update state\n        </button>\n      </div>\n    )\n  }\n)\n```\nNow click it and take a look at the debugger. You will see the debugger list the execution of the signal, with information about what happened. This is also a tool the Cerebral debugger provides to give you insight into your application. Very handy for example when you need to dig into a **complex application** after not touching it for a long time, introduce a new team member to the application or debug complex execution flows.\n\nSo changing the *subTitle* is kind of a silly state change on a button click. Let's introduce a very simple \"Toast\"-Component. It has already been added for you on the next chapter.\n\n**Want to dive deeper?** - [Go in depth](../in-depth/04_signals.html), or move on with the tutorial\n","title":"Update state"},"chains":{"raw":"# Chains\n\n**Load up chapter 04** - [Preview](04)\n\nA signal can trigger an array of functions. This array we call a **chain** and the functions we call **actions**. For now we have seen it trigger a function that changes the **subTitle** path. In this chapter we have added a **Toast** component which displays any message set on its related state.\n\nCreating a function for any kind of state change will be tedious. That is why Cerebral has **operators**. These operators are just functions that returns an action for you. There is an operator for every kind of state change and also other operators, which will we see an example of now.\n\n## Operators\nLet us first change out our **updateSubtitle** action with an operator instead. Since we did a *set*, we change it out with the **set** operator. Operators also takes advantage of the tags. In this case the first argument uses a tag to target our state. The second argument could also have been a tag, but we hardcode a value instead.\n\nNow lets add a **wait** operator and another **set** to close our toast message after a few seconds. So go ahead and change our **buttonClicked** signal in *src/index.js* to execute a 2 more actions:\n\n```js\n...\nimport {set, wait} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n...\n{\n  buttonClicked: [\n    set(state`toast`, 'Button Clicked!'),\n    wait(4000),\n    set(state`toast`, null)\n  ]\n}\n```\n\nNow when we check again in the debugger you will see all the 3 actions executed when signal *buttonClicked* got triggered.\n\nStill speaking of the debugger did you notice the **Input: {}** in front of every action executed? Looks quite empty. Let us look at that in the next chapter!\n","title":"Chains"},"actions":{"raw":"# Actions\n\n**Load up chapter 05** - [Preview](05)\n\nSignals can take an input-object which can be further processed by its actions.\n\nLet us say you have a user input which should get written to state.\nAs we now know, the only correct way to write to state is to use **signals** with **actions**.\n\nJust like we grabbed the **state** from the context of an action, we can also grab the input. This input object can be populated when a signal triggers and it can also be extended by actions. Any object returned from an action will be merged into the current input and passed to the next action.\n\n## Create an action\nLet us create a new action that will take an input to the signal and add some exclamation marks.\n\n```js\nfunction shoutIt ({input}) {\n  return {\n    message: `${input.message}!!!`\n  }\n}\n```\n\nAs you can see we grabbed the input just like we grabbed the state. The object we return from the action will be merged with the existing input. That means we are overriding the **message** with exclamation marks.\n\nOn our first **set** operator we rather now use a tag, *input*, to define that we want to set the message from the input.\n\n```js\n...\nimport {set, wait} from 'cerebral/operators'\nimport {state, input} from 'cerebral/tags'\n...\n{\n  buttonClicked: [\n    shoutIt,\n    set(state`toast`, input`message`),\n    wait(4000),\n    set(state`toast`, null)\n  ]  \n}\n```\n\n## Passing a payload\nNow we just need to change our button click to actually pass a message (*src/components/App/index.js*):\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport Toast from './Toast'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  buttonClicked: signal`buttonClicked`\n},\n  function App (props) {\n    return (\n      <div className=\"o-container o-container--medium\">\n        <h1>{props.title}</h1>\n        <h3>{props.subTitle}</h3>\n        <button\n          className=\"c-button c-button--info c-button--block\"\n          onClick={() => props.buttonClicked({\n            message: 'Please shout me'\n          })}\n        >\n          Update state\n        </button>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\n\nNow we are ready to test drive our changes. Click the button and you should see the toast message appear with three exclamation marks behind. Please keep an eye on the **debugger**. You can track how the flow of the input between the actions as they execute. Keep in mind that the result object from an action will be merged with the input and handed over to the next action. You might just as well used a different property for the shouted message.\n\n## Challenge\n\n- Add another custom action which transforms the input value to Uppercase. You may override existing properties on the input or create a new one\n\n**Want to dive deeper?** - [Go in depth](../in-depth/06_actions.html), or move on with the tutorial\n","title":"Actions"},"async_actions":{"raw":"# Async actions\n\n**Load up chapter 06** - [Preview](06)\n\nUntil now we have mostly used synchronous actions inside our **signals** and the flow was therefore straightforward. Example:\n\n```js\n{\n  somethingHappened:[\n    action1,\n    action2\n  ]\n}\n```\nBecause action2 appears after action1, action1 finishes before action2 starts. Clear enough. But now what happens when action1 executes asynchronously?\n\nWe already have an example of this in our code. The **wait** operator runs asynchronously. It runs for 4 seconds before the toast message is reset.\n\n```js\n{\n  buttonClicked:[\n    set(state`toast`, input`message`),\n    wait(4000),\n    set(state`toast`, null)\n  ]\n}\n```\n\nThe signal executes with the same behavior, it waits for an action to resolve before moving to the next.\n\n## Creating factories\nLet us look at how **wait** is defined:\n\n```js\nfunction waitFactory (ms) {\n  function wait () {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms)\n    })\n  }\n\n  return wait\n}\n```\n\nWe have just defined a **factory**. A function that returns an action. The action itself (wait) returns a promise. This promise is what tells the signal to hold its execution until it is resolved.\n\nCerebral factories are not only restricted to actions, you can also have chain factories.\n\n## Chain factories\nLet us create our own custom **showToast** chain factory. Instead of returning an action, we return a chain. As you can see we have moved the actions we defined previously into this array, using the arguments passed into the factory.\n\n```js\n...\nfunction showToast(message, ms) {\n  return [\n    set(state`toast`, message),\n    wait(ms),\n    set(state`toast`, null)\n  ]\n}\n...\nconst controller = Controller(...)\n```\n\nWe need to adjust *src/index.js*:\n```js\n{\n  buttonClicked: [\n    ...showToast(input`message`, 1000)\n  ]\n}\n```\n\nSince **showToast** returns an array we use the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) to merge into our existing chain.\n\nCongratulations! You have successfully mastered the power of factories. But there are couple of more concepts that will help you define state changes, jump over to the next chapter to find out more.\n","title":"Async actions"},"paths":{"raw":"# Paths\n\n**Load up chapter 07** - [Preview](07)\n\nIn the previous chapter we introduced async actions. But what about the following scenario: \"User gets data async from a server, server responds with either a success or error\". To handle not only the so called *Happy Path* we should also allow our signals to branch out into a different flows (which is just another chain of actions and operators) depending on the result of the previous action.\n\n## Http Provider\nSo let us build that scenario introducing *cerebral-http-provider*. *cerebral-http-provider* is a simple http-provider which enables you to request data from servers. You could have used any other HTTP library if you wanted to. We have already added it as a configuration of the controller. The concept of **Providers** will be covered in more detail in the next chapter.\n\nTo handle any kind of diverging execution in a signal we can use the concept of **paths**. A simple signal using paths and a sample async action named *getData* could look like this:\n\n```js\n{\n  submitClicked:[\n    getData, {\n      success:[\n        processResults,\n        showSuccessMessage\n      ],\n      error: [\n        showErrorMessage\n      ]\n    }\n  ]\n}\n```\n\nWhere *success* and *error* are our **paths**.\n\n## Grabbing a repo\nLet us implement something similar. We are going to grab information about github repos and display it in the toast:\n\n```js\n...\nimport {set, wait} from 'cerebral/operators'\nimport {state, input, string} from 'cerebral/tags'\n...\n{\n  buttonClicked: [\n     ...showToast(string`Loading data for repo: ${input`repo`}`, 2000),\n     getRepo, {\n       success: [\n          ...showToast(string`How cool is that. ${input`repo`} has ${input`data.subscribers_count`} subscribers and ${input`data.stargazers_count`} stars!`, 5000, 'success')\n       ],\n       error: [\n         ...showToast(string`Ooops something went wrong: ${input`data.message`}`, 5000, 'error')]\n      }\n  ]\n}\n```\n\nAs you can see you can configure as many and whatever paths you like. Just add an object after an action and the action will know about possible paths to execute.\n\nThe **getRepo** action can look like this:\n\n```js\n...\nfunction getRepo({input, http, path}) {\n  return http.get(`/repos/cerebral/${input.repo}`)\n    .then(response => path.success({data: response.result}))\n    .catch(error => path.error({data: error.result}))\n}\n\nconst controller = Controller(...)\n```\n\nThe path **success** and **error** are now available inside the action because we defined those paths after the action in the chain. Last, but not least, we need to pass in a **repo** property on our button click:\n\n*src/components/App/index.js*\n```js\n...\n<button\n  className=\"c-button c-button--info c-button--block\"\n  onClick={() => props.buttonClicked({\n    repo: 'cerebral'\n  })}\n>\n...\n```\n\n## Parallel execution\nBut there is an issue here. Did you notice that the message *Loading data for repo...* is blocking the execution for 2 seconds? It would be nice to indicate to Cerebral that actions can execute in parallel. Relax and take a sip from your coffee or beer, Cerebral has you covered!\n\nReplace your signal with the following snippet:\n\n```js\n{\n  buttonClicked: [\n    [\n      ...showToast(string`Loading data for repo: ${input`repo`}`, 2000),\n      getRepo, {\n        success: [\n           ...showToast(string`How cool is that. ${input`repo`} has ${input`data.subscribers_count`} subscribers and ${input`data.stargazers_count`} stars!`, 5000, 'success')\n        ],\n        error: [\n          ...showToast(string`Ooops something went wrong: ${input`data.message`}`, 5000, 'error')]\n       }  \n    ]\n  ]\n}\n```\n\nWhat is happening here? Did you spot the additional **[** and **]**? Well whenever Cerebral encounters an Array in a Array  **[action1,[action2,action3],action4]** it will start the actions within that array in parallel, so after action1 finishes action2 and action3 are executed right after each other, even though they run promises. After action2 and action3 finish, action4 will be executed.\n\nWe got even more flow control now, telling Cerebral to execute actions/operators in parallel by using JS arrays, and objects to diverge execution. By reading the signals you get a good understanding what the application will do. And don't forget, you do not even have to look at code to understand this, the debugger reflects parallel execution, state changes and even **paths** chosen.\n\n## Handling time\nBut... there is an other issue here. Did you notice that these **showToast** action factories does not cancel each other out? So the initial 2 second wait might close the toast where it was supposed to hold for 5 seconds after a success?\n\nInstead of using **wait**, we can use **debounce**. It is difficult to wrap your head around debounce. Simply said it ensures that whenever we run **showToast**, any pending toast timer will be discarded. But that is not enough, cause we have multiple *showToast* in our signal. So we need this behaviour to be shared across them. Whenever any *showToast* is called, we want the existing pending toast timer to be discarded. This just ensures whenever we display a toast it will stay there for the time set, unless a new toast is triggered.\n\n```js\n...\nimport {set, merge, debounce} from 'cerebral/operators'\nimport {state, input, string} from 'cerebral/tags'\n...\nconst toastDebounce = debounce.shared()\nfunction showToast (message, ms, type = null) {\n  return [\n    // We use merge as it supports evaluating tags in an object\n    merge(state`app.toast.message`, {type, message}),\n    toastDebounce(ms), {\n      continue: [\n        set(state`app.toast`, null)\n      ],\n      discard: []\n    }\n  ]\n}\n...\n{\n  buttonClicked: [\n    [\n      ...showToast(string`Loading data for repo: ${input`repo`}`, 2000),\n      getRepo, {\n        success: [\n        ...showToast(string`How cool is that. ${input`repo`} has ${input`data.subscribers_count`} subscribers and ${input`data.stargazers_count`} stars!`, 5000, 'success')\n        ],\n        error: [\n          ...showToast(string`Ooops something went wrong: ${input`data.message`}`, 5000, 'error')]\n      }\n    ]\n  ]\n}\n```\n\nCongratulations! Now you know how to control your flow using **paths**. And if you need **parallel actions/operators**, well just add another array **[]** to the chain. You have even gotten insight into very complex control flow using **debounce**.\n\n## Challenge\n\nWe would like you to run two getRepo(...) requests. One to *cerebral/cerebral* and one to *cerebral/addressbar*. So it is a good idea to make *getRepo* a factory instead. On their successes they should insert their data into the state tree.\n\n**Want to dive deeper?** - [Go in depth](../in-depth/05_chains-and-paths.html), or move on with the tutorial\n","title":"Paths"},"compute_state":{"raw":"# Compute state\n\n**Load up chapter 08** - [Preview](08)\n\nIn our application we want to sum up the number of stars. One approach would be to create an action in our signal:\n\n```js\nfunction setStarsCount({state}) {\n  state.set('starsCount',\n    state.get('repos.cerebral.stargazers_count') +\n    state.get('repos.addressbar.stargazers_count')\n  )\n}\n```\n\nThis is a perfectly okay approach for our simple scenario, but computing state like this can be tedious in large applications. We might want to use this state multiple places in our application and we want to make sure it is the same wherever we use it.\n\n## Computing\nIn Cerebral we can automatically compute state by using **compute**. It is basically a function that takes any number of arguments to produce a value. Let us look at how it works with our scenario:\n\n```js\nimport {compute} from 'cerebral'\n\nexport default compute(function starsCount (get) {\n  const repos = get.state('repos')\n\n  return Object.keys(repos).reduce((currentCount, repoKey) => {\n    return currentCount + repos[repoKey].stargazers_count\n  }, 0)\n})\n```\nWe depend on our repos state and declear that we also care about any changes to them. Then we just count the stars and return it. The **get** would also allows you to grab props if it was used with a component or input if it was used in a signal. When the compute is used with a component it will automatically track whatever dependencies it has and only runs when any of those dependencies change.\n\nLet us finish this example. To do so please create a new folder named *./src/computeds* and save a file named *starsCount.js* containing the snippet we just looked at. Then we would like to use our computed both in the signal and we also want to show the count in our component.\n\n## Replacing with computed\nLet us remove the **setStarsCount** action and just use the computed directly:\n\n```js\n...\nimport starsCount from './computeds/starsCount'\n...\n{\n  buttonClicked: [\n    [\n      ...showToast('Loading data for repos...', 2000),\n      getRepo('cerebral'), {\n        success: [set(state`repos.cerebral`, input`result`)],\n        error: []\n      },\n      getRepo('cerebral-debugger'), {\n        success: [set(state`repos.cerebral-debugger`, input`result`)],\n        error: []\n      }\n    ],\n    ...showToast(string`The repos have ${starsCount} stars`, 5000)\n  ]\n}\n...\n```\n\nYou can use computeds directly in tags, with operators, in actions and in components:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport starsCount from '../../computeds/starsCount'\nimport Toast from '../Toast'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  buttonClicked: signal`buttonClicked`,\n  starsCount\n},\n  function App (props) {\n    return (\n      <div className=\"o-container o-container--medium\">\n        <h1>{props.title}</h1>\n        <h3>{props.subTitle}</h3>\n        <button\n          className=\"c-button c-button--info c-button--block\"\n          onClick={() => props.buttonClicked()}\n        >\n          Update star count ({props.starsCount})\n        </button>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\nIf you wonder why the button updates its star count before the toast, it is because we have said the \"Loading data for repos\" should stick for 2 seconds.\n\nThats it for now regarding *Compute*. Of course summarizing some numbers is pretty simple stuff, but you can compute anything.\n\nBut now it has only been Cerebral stuff, what if you want to use other libraries in your action flow? Well, refill your coffee or open up another drink and enjoy the next chapter introducing **providers**.\n\n**Want to dive deeper?** - [Go in depth](../in-depth/11_computed.html), or move on with the tutorial\n","title":"Compute state"},"providers":{"raw":"# Providers\n\n**Load up chapter 09** - [Preview](09)\n\nGood news, we have already used a provider before. Do you remember the *http-provider* we are using to get data from servers?\n\nA provider basically adds itself to the context object of our actions. Let us check out our existing code in *./src/index.js*. Note the *http* - object on the context of the *get* action returned:\n```js\n...\nfunction getRepoFactory(repoName) {\n  function getRepo({http, path}) {\n    return http.get(`/repos/cerebral/${repoName}`)\n      .then(response => path.success({data: response.result}))\n      .catch(error => path.error({data: error.result}))\n  }\n\n  return getRepo\n}\n...\n```\n\n## Adding a provider\nWhat needs to be done? Well not too much. Just add the provider in your controller in *./src/index.js*\n\nThats how it looks right now:\n```js\n...\nimport HttpProvider from 'cerebral-provider-http'\n...\n    providers: [\n      HttpProvider({\n        baseUrl: 'https://api.github.com'\n      })\n    ]\n...\n```\n\nWhat are the **benefits** of using a provider in this way? Well we have decoupled the dependency of the HTTP tool in all our actions, meaning that when testing actions we can just pass in a resolved or rejected promise as **http.get** to simulate a response. As well the **Debugger** can now track and visualize the execution of providers.\n\nJust keep in mind that you could use any library as an provider, we've just used http-provider here because it is very lightweight and has some additional benefits when http-requests need to report back progress and the likes (because it also uses Cerebral-Signals for doing that). Let us add another one. Why not provide additional logging functionality to our actions? Let us use [js-logger](https://github.com/jonnyreeves/js-logger) one.\n\n## Adding a 3rd party provider\nWe have already installed the library using npm. So it was sitting there and waiting and now the time is ready to use it! Because we add a 3rd-party provider we need to wrap it up into a so called *ContextProvider* to get the benefits mentioned above.\n\nSo please add the following imports to your *./src/index.js*\n```js\n...\nimport logger from 'js-logger'\nimport {ContextProvider} from 'cerebral/providers'\n...\nlogger.useDefaults()\n...\n```\n\nNow we are ready to register it to our controller:\n```js\n...\n  providers: [\n    HttpProvider({\n      baseUrl: 'https://api.github.com'\n    }),\n    ContextProvider({\n      logger\n    })\n  ]\n...\n```\n\nNow we have the logger in place so let us use it to track request times:\n```js\nfunction getRepoFactory(repoName) {\n  function getRepo({logger, http, path}) {\n    logger.time(`request ${repoName}`)\n    return http.get(`/repos/cerebral/${repoName}`)\n      .then(response => {\n        logger.timeEnd(`request ${repoName}`)\n        return path.success({data: response.result})\n      })\n      .catch(error => {\n        logger.timeEnd(`request ${repoName}`)\n        return path.error({data: error.result})\n      })\n  }\n\n  return getRepo\n}\n```\n\nNow run your code and check the console after doing a request do a server.\nThats it! You have just successfully integrated another provider!\n\n**Want to dive deeper?** - [Go in depth](../in-depth/07_providers.html), or move on with the tutorial\n","title":"Providers"},"routing":{"raw":"# Routing\n\n**Load up chapter 10** - [Preview](10)\n\nNow that our tutorial UI gets more complex it is a good idea to separate it a little bit. We want a home tab and a repos tab. Our two repos should load when we click the repos tab or hit the url directly.\n\n## Adding some tabs\nLet us introduce the tabs first. We will just shove everything into our one component. Normally you would split this up into multiple components of course. You would probably also use JavaScript to map over a list of tabs or something similar, but let us be explicit now. Please change *./src/components/App/index.js* to:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\nimport Toast from '../Toast'\n\nexport default connect({\n  title: state`title`,\n  subTitle: state`subTitle`,\n  repos: state`repos`,\n  activeTab: state`activeTab`,\n  homeRouted: signal`homeRouted`,\n  reposRouted: signal`reposRouted`\n},\n  function App (props) {\n    return (\n      <div className=\"o-container o-container--medium\">\n        <h1>{props.title}</h1>\n        <h3>{props.subTitle}</h3>\n        <div className=\"c-tabs\">\n          <div className=\"c-tabs__headings\">\n            <div\n              onClick={(event) => props.homeRouted()}\n              className={`c-tab-heading ${\n                props.activeTab === 'home' ? 'c-tab-heading--active' : ''\n              }`}\n            >\n              Home\n            </div>\n            <div\n              onClick={(event) => props.reposRouted()}\n              className={`c-tab-heading ${\n                props.activeTab === 'repos' ? 'c-tab-heading--active' : ''\n              }`}\n            >\n              Repos\n            </div>\n          </div>\n          <br />\n          <div className={`c-tabs__tab ${\n            props.activeTab === 'home' ? 'c-tabs__tab--active' : ''\n          }`}>\n            <h5>Home page content</h5>\n          </div>\n          <div className={`c-tabs__tab ${\n            props.activeTab === 'repos' ? 'c-tabs__tab--active' : ''\n          }`}>\n            <ul>\n              {Object.keys(props.repos).map((repoKey, index) => {\n                const name = props.repos[repoKey].name\n                const count = props.repos[repoKey].stargazers_count\n\n                return (\n                  <li key={index}>\n                    {name} ({count})\n                  </li>\n                )\n              })}\n            </ul>\n          </div>\n        </div>\n        <Toast />\n      </div>\n    )\n  }\n)\n```\n\nWe also need to add new state in *./src/index.js*:\n```js\n...\n{\n  title: 'Hello from Cerebral!',\n  subTitle: 'Working on my state management',\n  toast: null,\n  repos: {},\n  activeTab: 'home'  \n}\n...\n```\nAnd update the signals as well:\n```js\n...\n{\n  homeRouted: [\n    set(state`activeTab`, 'home')\n  ],\n  reposRouted: [\n    set(state`activeTab`, 'repos'),\n    [\n      ...showToast('Loading data for repos...', 2000),\n      getRepo('cerebral'), {\n        success: [set(state`repos.cerebral`, input`data`)],\n        error: []\n      },\n      getRepo('addressbar'), {\n        success: [set(state`repos.addressbar`, input`data`)],\n        error: []\n      }\n    ],\n    ...showToast('Repos loaded', 2000, 'success')\n  ]\n}\n...\n```\nNow you can testdrive your changes. You should see the first tab activated. Now go to debugger and change *activeTab* state to 'repos' and you will see the second tab. If you click the tabs you will actually trigger the signals which appears in the debugger. Nice! But what has this to do with Routing?\n\n## Introducing the router\nTraditional routers is a wrapper around your components and they manipulate what components to display based on the url. That is not how routing works in Cerebral. In Cerebral you connect urls to signals. So:\n\n1. A url is hit or changed\n2. The respective signal is triggered putting your application in the correct state\n3. The components now renders based on the state of the application\n\nThis is a really good thing because most route changes requires quite a few state changes and side effects, like server requests, to be run. This is exactly what signals do so well.\n\nLet us introduce **cerebral-router** to our project by adding an import to the top of our *./src/index.js*:\n\n```js\nimport Router from 'cerebral-router'\n\n```\n\nAnd go ahead by doing the router config as follows inside the controller:\n```js\n...\nconst controller = Controller({\n  devtools: Devtools(),\n  router: Router({\n    routes: {\n      '/': 'homeRouted',\n      '/repos': 'reposRouted'\n    },\n    onlyHash: true // Use hash urls\n  })\n  ...\n})\n...\n```\n\nAs you can see, defining *routes* is as easy as linking them to *signals*. Now go to your browsers addressbar and enter *localhost/#/repos* and voilà the reposRouted signal gets called. And it also works the other way around. When you now click your tabs the url will also update!\n\n## Challenge\n\nGo to your browsers addressbar and enter an invalid route like: localhost/#/*foo* and press Enter. Now check the console! The challenge is to add another route which catches those *unknown* routes, runs a signal and display a toast with an error.\n\n**Want to dive deeper?** - [Go in depth](../in-depth/12_routing.html), or move on with the tutorial\n","title":"Routing"},"modules":{"raw":"# Modules\n\n**Load up chapter 11** - [Preview](11)\n\nGlad you are still with us! Hopefully you have enjoyed our journey so far and hopefully you still have a sip left of your coffee or drink. It's time for cleaning up.\n\nWelcome to the world of **modules**. We will build the following structure:\n\n```\n.\n├── public\n|\t├── index.html\n|\t└── ...\n├── src\n|\t├── components\n|\t|\t├── App\n|\t|\t├── Toast\n|\t├── modules\n|\t|\t├── Home\n|\t|\t├── Repos\n|\t└── index.js\n├── package.json\n├── ...\n```\n\nOur *./src/index.js* looks a lot cleaner and we have put our code into the conventional folders recommended by the Cerebral community. Let us look closer at the changes:\n\n```js\n...\nimport app from './modules/app'\nimport home from './modules/home'\nimport repos from './modules/repos'\n...\nconst controller = Controller({\n  modules: {app, home, repos}\n  ...\n})\n...\n```\n\nFirst of all we now load all our state and signals from modules. An example of a module is:\n\n```js\nimport openRepos from './chains/openRepos'\n\nexport default {\n  state: {\n    list: {}\n  },\n  signals: {\n    routed: openRepos\n  }\n}\n```\n\nThe signals references chain that lives in their own files. This makes it super easy to compose chains into multiple signals.\n\nThe only difference now is that the modules namespaces our state and signals, which means we need to prefix the pointers in the router and components to the correct path.\n\n```js\nexport default connect({\n  title: state`app.title`,\n  subTitle: state`app.subTitle`,\n  repos: state`repos.list`,\n  activeTab: state`app.activeTab`,\n  ...\n}, ...)\n```\n\nSo there is no magic to **modules**, they just namespace signals and state. There is no isolation going on. Any module can change any state of the application. This prevents you from getting into problems as your application grows.\n\n## Final touch\nWe also did one last fix here on **showToast**. We allowed it to stick. That way we can show a message while our repos are loading and then hide it with a timed showToast later. We simply return two different chains based on a set time being passed in:\n\n```js\n...\nconst toastDebounce = debounce.shared()\nfunction showToast (message, ms, type = null) {\n  if (ms) {\n    return [\n      merge(state`app.toast.message`, {type, message}),\n      toastDebounce(ms), {\n        continue: [\n          set(state`app.toast`, null)\n        ],\n        discard: []\n      }\n    ]\n  }\n\n  return [\n    set(state`app.toast`, {}),\n    merge(state`app.toast.message`, {type, message})\n  ]\n}\n...\n```\n\nAnd we move our sticky *showToast* to the beginning of loading repos, without a set time:\n\n```js\n...\nexport default [\n  set(state`app.activeTab`, 'repos'),\n  ...showToast('Loading data for repos...'),\n  [\n    getRepo('cerebral'), {\n      success: [set(state`repos.list.cerebral`, input`data`)],\n      error: []\n    },\n    getRepo('addressbar'), {\n      success: [set(state`repos.list.addressbar`, input`data`)],\n      error: []\n    }\n  ],\n  ...showToast('Repos loaded', 2000, 'success')\n]\n```\n\nCongratulations! You have reached the end of our *Get Started* - tutorial.\nThere is a lot of other good stuff on this website. So please check it out!\n\nAs a **last challenge**: Build your next big thing with **Cerebral** and please tell us about it on [discord chat](https://discord.gg/0kIweV4bd2bwwsvH) :)\n","title":"Modules"}},"in depth":{"index":{"raw":"# The architecture\n\nCerebral is based on the simple concept of three things your application does in order to function. **Store state**, **render state** and **update state**.\n\n## Store state\nWhere to store the state of an application is a highly debated subject. Should we allow the components to store state? Should we have multiple models? Stores? Reducers? Services? There are many concepts that can store state. In Cerebral you store all your state in \"a single state tree\". That means you do not create classes or other abstractions around state, it is all basically one big object of plain JavaScript types. Objects, arrays, strings, numbers and booleans:\n\n```js\n{\n  auth: {\n    isLoggedIn: false,\n    user: {}\n  },\n  posts: {\n    list: [],\n    selectedPostIndex: 0\n  }\n}\n```\n\nWith this approach we get some benefits not possible with other approaches.\n\n### Simple and consistent API\nTypically a state update changes a value, pushes an item in a list or merges an object into another. With a single state tree we can create an API that does exactly that:\n\n```js\nstate.set('user.prefs.style', 'dark')\nstate.push('user.friends', 'Joe')\nstate.merge('user.info', {\n  email: 'cheetah@jungle.com',\n  name: 'Cheetah'\n})\n```\n\nWith a single state tree we can point to parts of the state using paths (the first argument). We use dot notation to point to nested paths, like **auth.user.name**.\n\n### Optimized rendering\nCerebral does not look at the updates in your application as \"value updates\", but as \"path updates\". This allows Cerebral to make optimizations not possible in other frameworks:\n\n1. There is no need for immutability in Cerebral because a change to a path means that any component depending on that path should render (no value comparison). In applications with large data structures immutability has a high cost. There is no need to hack objects and arrays to observe changes to them either. There is nothing special about the state you put into Cerebrals state tree\n2. Since there is no value comparison in Cerebral it uses what we call **strict render**. Traditionally if you change an item in an array, also the array itself has a change. This means that the component handling the array will render whenever an item needs to render. This does not happen in Cerebral\n\n## Render state\nIn smaller applications it does not matter that much where you define the state of the application. It is easy to reason about the application because it is small enough to fit in ones head. In larger application it becomes a problem if state is defined \"all over the place\".\n\nSince Cerebral stores all the state of the application in a single state tree we need a way to expose that state to the components. In some frameworks this is done by passing the whole model or collection of models/stores from the top of the application and down from one component to the next. This can become very tedious and fragile as all nested components completely depend on their parent. In Cerebral the state of the application is directly connected to each component:\n\n```js\nconnect({\n  userName: state`app.user.name`\n},\n  function User(props) {\n    props.userName // \"some name\" (value stored in 'app.user.name')\n  }\n)\n```\n\n**connect** tells Cerebral that the component is interested in a path where the user name happens to be. When that path changes the component will render. The component is now completely independent of other components. You can move it wherever you want in the component tree and it will still work.\n\n## Update state\nThis is where Cerebral really differs from other approaches to application development. Updating the state of an application can be anything from:\n\n- flipping a **true** to a **false**\n- setting some value, like a filter\n- reading (and storing) something in local storage\n- requesting data from the server and, depending on the status code of the response, do something with that response which might lead to new requests and/or setting up a listener for data on the server\n- etc...\n\nThe point is, updating state can be a very complex flow of operations. This is often where spaghetti code comes from and we use abstractions to hide it. The problem with abstractions is that it is very difficult to understand how things actually work and it becomes more difficult to make changes.\n\nTo handle everything from a simple toggle to very complex operations, Cerebral has the concept of **signals**. These allow you to compose functions together into a flow that is not only about the \"happy path\" but properly takes the actual paths of execution into account, them being errors or other reasons to diverge execution. You can define many different execution paths based on whatever you want (a status code, an error, some state, etc). This allows you to write decoupled code, while still bringing everything together in the form of a higher abstraction which greatly helps understanding how things relate to one another (in what order they will run, when they will run, etc). Under the hood, signals are based on [function-tree](https://github.com/cerebral/function-tree), a project that came out of the initial experimentations in the first version of Cerebral.\n\nAnother powerful feature of **signals** (aka function-tree) is that there is a debugger that can track execution and understands when a signal triggers, what functions are run, what state is being updated and what other side effects are triggered.\n\n## Summary\nThe architecture of Cerebral is defined to give you insight. The single state tree and the way state is connected to the components all support this vision. Creating a Cerebral application allows you and your team members to never question what actually happens when a page loads, a specific button is clicked, etc. Decoupling of state, components and state updates also makes it an overall better experience when scaling up an application as the components will be just a dumb layer that transforms a given state to a user interface.\n","title":"The architecture"},"controller":{"raw":"# Controller\n\nCerebral is what we call a controller. It controls the requests for state change, runs them and notifies the UI when an update is due. It is in complete control of your application and knows everything that is going on. That is why the debugger can give you so much insight into your running application.\n\nYour application will have one single controller:\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({})\n```\n\nThe controller is where you define how your application is going to work. Everything from the state, to signals, providers and modules.\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {},\n  signals: {},\n  modules: {},\n  providers: []\n})\n```\n\nThe controller will then be exposed to your components.\n\n```js\nimport {Controller} from 'cerebral'\nimport {Container} from 'cerebral/react'\nimport {render} from 'react-dom'\nimport App from './components/App'\n\nconst controller = Controller({\n  state: {},\n  signals: {},\n  modules: {},\n  providers: []\n})\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\nThe **Container** exposes the controller on the *context*, allowing any component to register to it.\n","title":"Controller"},"state":{"raw":"# State\n\nCerebral uses a single state tree to store all the state of your application. It is just a single object:\n\n```js\n{}\n```\n\nThat's it.\n\nYou will normally store other objects, arrays, strings, booleans and numbers in it. Forcing you to think of your state in this simple form gives us benefits.\n\n1. The state of the application is exposed as simple values. There are no classes or other abstractions hiding the state of your application\n2. The state can be stored on the server, local storage and passed to the debugger. It is what we call **serializable** state\n3. All the state of your application can be inspected through one object\n4. All state is related to a path. There is no need to import and/or pass around model instances into other model instances to access state\n\n## State in modules\nWhen you create a new module in your application, for example...\n\n```js\nimport {Controller} from 'cerebral'\n\nconst AppModule = {\n  state: {\n    foo: 'bar'\n  }\n}\n\nconst controller = Controller({\n  modules: {\n    app: AppModule\n  }\n})\n```\n\n... Cerebral will put this into the single state tree as:\n\n```js\n{\n  app: {\n    foo: 'bar'\n  }\n}\n```\n\nYou can now point to this state with a path: **\"app.foo\"**. To handle large amounts of state you simply namespace it by putting the state into a module.\n\nUsing the plain value types of JavaScript gives Cerebral all its power. That said, there are times you need to store things like files or blobs. Cerebral supports this as well. The reason files are supported, but not **Date** for example, is because a date can be mutated directly. For example:\n\n```js\nconst date = new Date()\ndate.setHours(8)\n```\n\nThere is no way to keep track of these kinds of changes. Object oriented programming like this definitely makes things easier, but a functional approach opens up for new possibilities. For example...\n\n```js\nconst date = Date.now()\nconst newDate = setHours(date, 8)\n```\n\n...allows us to pass and store the date wherever we want, because it is just a number. But do not worry about this. You can still use the Date object, or [Moment](http://momentjs.com/), in your app. It is only related to storing state you in this case use a number or a string.\n\nAnd that is basically all there is to state in Cerebral. If you know about the basic JavaScript types, you know what can be stored in the Cerebral state tree :)\n","title":"State"},"signals":{"raw":"# Signals\n\nThe signals of Cerebral are named in past tense. So typically you would name a signal **inputChanged** or **mounted**. You call a signal just like you would call a function, the difference is that you start a function tree execution.\n\nCerebral uses the [function-tree](https://github.com/cerebral/function-tree) project to implement its signals. A function-tree allows you to define a tree of functions to be executed. In Cerebral world we call the arrays in a function-tree **chains**. These chains contains functions, we call them **actions**. So to sum up: *\"signals are chains of actions\"*.\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\n\nexport default [\n  actionA,\n  actionB\n]\n```\n\nTo trigger a signal you can grab it from the controller:\n\n```js\nimport {Controller} from 'controller'\nimport someChain from './chains/someChain'\n\nconst controller = Controller({\n  signals: {\n    somethingHappened: someChain\n  }\n})\n\nconst signal = controller.getSignal('somethingHappened')\nsignal()\n```\n\nThis signal triggers synchronously and you can pass it a payload.\n\n```js\n...\nsignal({\n  foo: 'bar'\n})\n```\n\nThis payload is brought into the signal execution and acts as the **input** of the signal. Typically you will not trigger signals manually this way, but rather from within a component.\n\n```js\nconnect({\n  foo: state`app.foo`,\n  somethingHappened: signal`app.somethingHappened`\n},\n  function MyComponent (props) {\n    return <button onClick={() => props.somethingHappened()}>Click me</button>\n  }\n)\n```\n\nThe payload passed to a signal is typically the core value types of JavaScript. Object, Array, String, Number or Boolean. It is also possible to pass in some special value types, like files. For a full list of supported value types, check the [state API documentation](../api/02_state.html).\n","title":"Signals"},"chains_and_paths":{"raw":"# Chains and paths\n\nWhen you trigger a signal it will run a chain of actions. We express this chain as an array and reference whatever actions we want to run:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\n\nexport default [\n  actionA,\n  actionB\n]\n```\n\nCerebral runs one action after the other synchronously. When an action returns a promise it will hold until the promise resolves and then continue.\n\n## Parallel execution\nYou can also run these actions in parallel. You do that by grouping them in another array:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport actionC from '../actions/actionC'\n\nexport default [\n  [\n    actionA,\n    actionB\n  ],\n  actionC\n]\n```\n\nIf actionA returns a promise actionB will still be run instantly, meaning that they run in parallel. When both actionA and actionB is done, actionC is run.\n\n## Composing\nChains can be composed into an other chain by using the spread operator. This is a powerful concept that allows you to compose large pieces of logic into other parts of your application.\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport chainA from '../chains/chainA'\n\nexport default [\n  actionA,\n  ...chainA,\n  actionB\n]\n```\n\nCerebral will now run this as one signal, first running *actionA*, then whatever is expressed in *chainA* and then run *actionB* last.\n\n## Paths\nChain can also express execution paths. For example:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport actionC from '../actions/actionC'\n\nexport default [\n  actionA, {\n    foo: [\n      actionB\n    ],\n    bar: [\n      actionC\n    ]\n  }\n]\n```\n\nYou can think of this as \"if statements\" in the chain. When a path is expressed after an action, the context of that action will have a **path** on its context. For example in this example:\n\n```js\nfunction actionA ({path}) {\n  path.foo // function\n  path.bar // function\n}\n```\n\nWhen the action returns one of these paths, that path will be executed:\n\n```js\nfunction actionA ({path}) {\n  return path.foo()\n}\n```\n\nThis is possible due to Cerebrals static analysis of the signals. It knows exactly how it is going to run before it is executed.\n\nYou can also pass a payload to the path:\n\n```js\nfunction actionA ({path}) {\n  return path.foo({\n    foo: 'bar'\n  })\n}\n```\n\nThis is merged into the *input* and made available to the next actions. If you return a promise from an action you just resolve the path:\n\n```js\nfunction actionA ({path}) {\n  return new Promise((resolve) => {\n    resolve(path.foo({\n      foo: 'bar'\n    }))\n  })\n}\n```\n","title":"Chains and paths"},"actions":{"raw":"# Actions\n\nA signal runs actions and actions are actually just functions.\n\n```js\nfunction iAmAnAction () {}\n```\n\nThat means you do not need any API to define an action. This makes actions highly testable.\n\n## The context\nWhen actions run they are passed a context. This context is created by Cerebral for every action run.\n\n```js\nfunction iAmAnAction (context) {}\n```\n\nThe context is populated by Cerebral and you can configure this by creating **providers**. By default Cerebral adds the following providers on the context.\n\n### Input\n\nWhen you trigger a signal you can pass it a payload. This payload is the starting point of the input to the signal. Given the signal:\n\n```js\n[\n  actionA,\n  actionB\n]\n```\n\n```js\nsomeSignal({\n  foo: 'bar'\n})\n```\n\nThe first action will receive the payload passed into the signal.\n\n```js\nfunction actionA ({input}) {\n  input // {foo: \"bar\"}\n\n  return {\n    bar: 'baz'\n  }\n}\n```\n\nBy returning a new object the next action will see an extended input:\n\n```js\nfunction actionB ({input}) {\n  input // {foo: \"bar\", bar: \"baz\"}\n}\n```\n\nSo returning an object from actions extends the input for later actions to handle.\n\n### State\nTo change the state of your application you use the state API. It is available to every action.\n\n```js\nfunction setSomething ({state}) {\n  state.set('some.path.foo', 'bar')\n}\n```\n\nAll common state operations are available as a method. Instead of first pointing to a value and then operate, you operate first and give the path to the value.\n\n```js\n// Traditional approach\nsomeArray.push('newItem')\n// With Cerebral\nstate.push('path.to.array', 'newItem')\n```\n\nThis is the one core concept of Cerebral that gives all its power. This simple approach allows for a few important things:\n\n1. Track mutations in the application so that it can be passed to the debugger\n2. Track mutations so that it can inform components depending on the changes\n3. Only allow mutations through the API, and nowhere else in the application (using freezing during development)\n\n### Path\nThe path on the context is only available if there is actually expressed a path after the action in question:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport actionC from '../actions/actionC'\n\nexport default [\n  actionA,\n  actionB, {\n    foo: [actionC]\n  }\n]\n```\n\nIn this scenario only *actionB* has the path on its context. As explained in **Chains and paths**, the path allows you to diverge execution of the signal.\n\n### Controller\nYou have access to the controller instance on the context:\n\n```js\nfunction someAction ({controller}) {}\n```\n\n### Execution\nYou have access to function trees execution as well. This holds information about the current execution, mostly used by the devtools to inform the debugger.\n\n```js\nfunction someAction ({execution}) {}\n```\n","title":"Actions"},"providers":{"raw":"# Providers\n\nProviders are added to the context of every action executed by a signal. Providers can be everything from a tool you are already using, to something Cerebral specific. The point of providers is to separate side effects from execution. That means you can create all the logic you want with chains and actions without creating any dependencies to other tools. This makes them highly testable and generally gives you more flexibility.\n\nAdding a provider is done by:\n\n```js\nimport {Controller} from 'cerebral'\n\nfunction MyProvider (context, functionDetails, payload, prevPayload) {\n  // The current context object, which can be mutated\n  context\n\n  // The details of the action running, like name, index (id) etc.\n  functionDetails\n\n  // The current payload passed to the action\n  payload\n\n  // The previous payload\n  prevPayload\n\n  // You have to return the context after it has bee mutated\n  return context\n}\n\nconst controller = Controller({\n  providers: [\n    MyProvider\n  ]\n})\n```\n\n## Context Provider\nThere is a built in provider with Cerebral you can use to expose tools. The provider will wrap the tool so that you can see its usage in the debugger:\n\n```js\nimport {Controller} from 'cerebral'\nimport {ContextProvider} from 'cerebral/providers'\nimport axios from 'axios'\nimport uuid from 'uuid'\n\nconst controller = Controller({\n  providers: [\n    ContextProvider({axios, uuid})\n  ]\n})\n```\n\nNote that some tools has a very complex API that **ContextProvider** has a hard time analyzing. With these kinds of tools it is a better idea to create your own provider, exposing APIs that you actually use from the original tool.\n\n## Creating a provider\nYou can use providers for pretty much anything, though typically it is to handle some kind of side effect. Examples of providers is [cerebral-provider-firebase](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-provider-firebase) and [cerebral-provider-http](https://github.com/cerebral/cerebral/tree/master/packages/cerebral-provider-http).\n\n```js\nfunction MyProvider (options = {}) {\n  let cachedProvider = null\n\n  function createProvider (context) {\n    return {\n      doSomething() {},\n      doSomethingElse() {}\n    }\n  }\n\n  return (context) => {\n    context.myProvider = cachedProvider = cachedProvider || createProvider(context)\n\n    if (context.debugger) {\n      context.debugger.wrapProvider('myProvider')\n    }\n\n    return context\n  }\n}\n```\n\nThis is a very typical setup for a provider. It creates and caches it. It also wraps and methods exposed if the debugger is available, tracking its execution.\n","title":"Providers"},"tags":{"raw":"# Tags\nJavaScript ES2015 has gotten a lot of nice features. One of these feature is template strings.\n\n```js\nconst name = 'Bob'\n\n`Hello there ${name}` // Hello there Bob\n```\n\nBut a not very well known feature of template strings is [template tags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals). We use this functionality in Cerebral to target things when you define signals, computeds and connect components.\n\nThis is how typical usage of operators tags look:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`foo.bar`, 'baz')\n]\n```\n\nWhen the following code runs...\n\n```js\nstate`foo.bar`\n```\n\n...it will return a Tag. This Tag can be used inside action factories to grab details.\n\n```js\nimport {Tag} from 'cerebral/tags'\n\nfunction someFactory(statePath) {\n  function someAction ({state, input, resolve}) {\n    const isTag = resolve.isTag(statePath, 'state') // true/false\n    const path = resolve.path(statePath) // \"foo.bar\"\n    const value = resolve.value(statePath) // The value on path \"foo.bar\" in state tree\n  }\n\n  return someAction\n}\n```\n\n## Action factories with tags\nYou can easily create your own action factories and use the tags. Here showing the implementation of a **set**\n\n```js\nimport {Tag} from 'cerebral/tags'\n\nfunction setFactory(target, value) {\n  function set({state, input, resolve}) {\n    if (!resolve.isTag(target, 'state', 'input')  ) {\n      throw new Error('You have to use STATE or INPUT tag as set target')\n    }\n\n    // resolve.value will return tag value, computed value or plain value\n    state.set(resolve.path(target), resolve.value(value))\n  }\n\n  return set\n}\n```\n\nCustom operators often wants to extract paths, though not necessarily related to state or input. That is why we have the tag **string**.\n\n```js\nimport {string} from 'cerebral/tags'\nimport showMessage from '../factories/showMessage'\nimport starsCount from '../computeds/starsCount'\n[\n  showMessage(string`There are ${starsCount} left`)\n]\n```\n","title":"Tags"},"operators":{"raw":"# Operators\n\nEverything that happens in a signal is based on actions. But these actions can be dynamic, in the sense that you rather call a function with some parameters and based on those parameters creates a function for you. This is what operators is all about.\n\nFor example:\n\n```js\nimport {wait} from 'cerebral/operators'\n\nexport default [\n  wait(200), {\n    continue: []\n  }\n]\n```\n\nThe *wait* function returns an action based on the parameter passed in. Let us look at how it is implemented.\n\n```js\nfunction waitFactory (ms) {\n  function wait ({path}) {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(path.continue())\n      }, ms)\n    })\n  }\n\n  return wait\n}\n```\n\nSo operators are quite simple as you can see. A more generic term is *action factories*, which you most certainly will take advantage of in your own application. So operators are really the core *action factories* of Cerebral.\n","title":"Operators"},"factories":{"raw":"# Factories\nFunction factories is a common term in programming. It is basically a function that returns a function:\n\n```js\nfunction createHelloMessage (name) {\n  function helloMessage () {\n    console.log(`Hello there ${name}`)\n  }\n\n  return helloMessage\n}\n\nconst helloBob = createHelloMessage('Bob')\nhelloBob() // Logs: \"Hello there Bob\"\n```\n\nIn Cerebral you will find yourself creating a lot of factories. Factories for creating actions and even factories for creating chains. Actually the Cerebral **operators** are action and chain factories.\n\n## Action factory\n```js\nfunction hasUserRoleFactory (role) {\n  function hasUserRole ({state, path}) {\n    if (state.get('user.role') === role) {\n      return path.true()\n    }\n\n    return path.false()\n  }\n\n  return hasUserRole\n}\n```\n\nSo this factory can now be used in any chain:\n\n```js\nimport hasUserRole from '../factories/hasUserRole'\n\nexport default [\n  hasUserRole('admin'), {\n    true: [],\n    false: []\n  }\n]\n```\n\n## Chain factory\n```js\nimport {set, wait} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nfunction showMessageFactory (message, ms) {\n  return [\n    set(state`app.message`, message),\n    wait(ms),\n    set(state`app.message`, null)\n  ]\n}\n```\n\nNow this can be used in any chain:\n\n```js\nimport showMessage from '../factories/showMessage'\n\nexport default [\n  ...showMessage('Hello there!', 500)\n]\n```\n\nChain factories should always be **spread** into chains. Think of it as \"merging it in\". Usually it does not matter, cause it will just be treated as a parallel execution, but it is good practice.\n","title":"Factories"},"connect":{"raw":"# Connect\n\nIn Cerebral you always connect state where you need it. This give some benefits:\n\n1. Cerebral will optimize the component\n2. The debugger will know about this component and visualize its state dependencies and when it renders\n3. Increased readability as every component explicitly tells you what state it needs and where it gets it from\n4. You can safely move the component wherever you want without breaking chain of props passing\n\nWhen you connect a component like this...\n\n```js\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  foo: state`app.foo`\n},\n  function MyComponent () {\n\n  }\n)\n```\n\n...the component will be registered to the **Container** which is used to expose the controller. The *Container* actually has a register of all connected components in your application. This information is passed to the debugger and whenever Cerebral flushes out changes made to different state paths, the *Container* will figure out what components should render.\n\nAll connected components are automatically optimized, meaning that they will only render if a parent component passes a changed prop or the *Container* tells it to render.\n","title":"Connect"},"compute":{"raw":"# Compute\n\nVery often the components needs to produce state based on a combination of other state. A very typical example is to show items of a list based on a dynamic limit. The whole list is stored in your state tree, but you only want to show for example the 10 latest. Instead of defining this in the component itself, you can use **compute**.\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default compute(\n  state`items.limit`,\n  state`items.list`,\n  (limit, list) => {\n    return items.filter((item, index) => index < limit)    \n  }\n)\n```\n\nTo use this computed in your component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport limitedList from '../../computed/limitedList'\n\nexport default connect({\n  limitedList\n},\n  function List(props) {\n    props.limitedList\n  }\n)\n```\n\nIt would also be possible to pass in the limit as a property, maybe from the props passed into the component:\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default function (passedLimit) {\n  return compute(\n    passedLimit,\n    state`items.limit`,\n    (limit, list) => {\n      return items.filter((item, index) => index < limit)    \n    }\n  )\n}\n```\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport limitedList from '../../computed/limitedList'\n\nexport default connect({\n  limitedList: limitedList(props`limit`)\n},\n  function List(props) {\n    props.limitedList\n  }\n)\n```\n\nThe computed values are automatically cached.\n\n### Relational data\nA challenge using a single state tree is handling relational data. Since data is typically stored in multiple places you need to bring them together. For example a user with projects. In Cerebral we favor storing data as objects due to advantages in lookups and optimistically creating new items. Let us look at an example of a state tree:\n\n```js\n{\n  users: {\n    'user-1': {\n      name: 'Bob',\n      projects: ['project-1', 'project-2']\n    },\n    'user-2': {\n      name: 'Dale',\n      projects: ['project-1']\n    }\n  },\n  projects: {\n    'project-1': {title: 'Awesome project'},\n    'project-2': {title: 'Also awesome project'}\n  }\n}\n```\n\nWe want to display a user with its related projects. Now... what to think of now is that even though projects relate to users it is not always the case that we want to show this data together. Maybe we only want to show data related to the user itself, or only the project. That is why we express this relationship when we bring the data into the component. So for example, only showing the user:\n\n```js\n// Only a user\nconnect({\n  user: state`users.${props`userKey`}`\n})\n// Only a project\nconnect({\n  user: state`projects.${props`projectKey`}`\n})\n```\n\nIf you want to bring in a user and its related projects you can define a computed for that. The way you would bring it into connect could be:\n\n```js\nconnect({\n  user: user(props`userKey`)\n})\n```\n\nYou would define **user** as:\n\n```js\nfunction user (passedUserKey) {\n  return compute(\n    passedUserKey,\n    (userKey, get) => {\n      const user = state(`users.${userKey}`)\n\n      return {\n        ...user,\n        projects: user.projectIds.map((id) => get(state`projects.${id}`))\n      }\n    }\n  )\n}\n```\n\nNow your component depends on the user and any changes to its children. It also depends on each specific project of the user and any changes to their children.\n\nBut you could split this up. You could keep the **user** as:\n\n```js\nfunction user (passedUserKey) {\n  return compute(\n    passedUserKey,\n    (userKey, get) => {\n      return get(state`users.${userKey}`)\n    }\n  )\n}\n```\n\nAnd rather add a new compute to grab the projects:\n\n```js\nconst userProjects = compute((user, get) => {\n  return {\n    ...user,\n    projects: user.projectIds.map((id) => get(state`projects.${id}`)\n  }\n})\n```\n\nAnd then you can choose what to grab in different components.\n\n```js\n// I only want the user\nconnect({\n  user: user(props`userKey`)\n})\n// I want the user with projects\nconnect({\n  user: compute(user(props`userKey`), userProjects)\n})\n```\n\nSo compute is a very powerful tool. It is up to the project and your preferences to use what makes most sense. Maybe you just need to use a simple computed, or maybe you need to take it up a notch and compose. Or maybe you do not even need compute at all and can just use tags.\n","title":"Compute"},"routing":{"raw":"# Routing\n\nTypically applications uses a router. To instantiate the Cerebral router you install it as a separate package:\n\n`npm install cerebral-router@next --save`\n\nThen you instantiate it on the controller:\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst controller = Controller({\n  router: Router({\n    routes: {}, // Route definitions\n    query: false, // Query support\n    onlyHash: false, // Use hash urls\n    baseUrl: '/' // Only handle url changes on nested path\n  })\n})\n```\n\n## Defining routes\nRoutes in Cerebral does not affect the components, they affect signals. The signals puts your application in a specific state and then your components decides what to render based on that state. So the router is completely decoupled from your components. This is a very good thing because a route can now translate to any kind of state changes and side effects.\n\nLet us create a small app:\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\nimport HomeModule from './modules/Home'\nimport PostsModule from './modules/Posts'\n\nconst controller = Controller({\n  router: Router({\n    routes: {\n      '/': 'home.routed',\n      '/posts': 'posts.routed'\n    }\n  }),\n  state: {\n    currentPage: 'home'\n  },\n  modules: {\n    home: HomeModule,\n    posts: PostsModule\n  }\n})\n```\n\nAs we can see, when the root route is hit we want to trigger a signal that says that home is routed:\n\n*modules/Home/index.js*\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default {\n  signals: {\n    routed: [\n      set(state`currentPage`, 'home')\n    ]\n  }\n}\n```\n\nThe **/posts** route points to a different module and signal.\n\n*modules/Posts/index.js*\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default {\n  signals: {\n    routed: [\n      set(state`currentPage`, 'posts')\n    ]\n  }\n}\n```\n\n## Render based on state\nSo we do not render anything based on the route. We render based on state, like we do with everything else. A route never affects the components, it only affects your state.\n\n*components/App/index.js*\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\nimport Home from '../Home'\nimport Posts from '../Posts'\n\nconst pages = {\n  home: Home,\n  posts: Posts\n}\n\nexport default Connect({\n  currentPage: state`currentPage`\n},\n  function App(props) {\n    const Page = pages[props.currentPage]\n\n    return <Page />\n  }\n)\n```\n\nSo this was simple page handling routing, but you can imagine that a route does not have to be a page change. It can opening a modal, highlight some item or whatever. You are completely free to structure this. If some data fetching was needed before changing the page you would just put this in the signal.\n","title":"Routing"}},"best practices":{"index":{"raw":"# Organizing\n\nCerebral uses a concept called **modules** to organize application code. These allow you to wrap state and signals into a namespace without isolating them. Any action run in a signal can change any state in the application.\n\nTypically the file structure for modules looks like this. We call it the **chains pattern**. This is where a signal points to one or multiple chains when they are defined:\n\n```js\n/modules\n  /home\n    /actions\n    /chains\n    index.js\nmain.js\n```\n\n```js\nimport doThis from './chains/doThis'\n\nexport default {\n  signals: {\n    somethingHappened: doThis\n  }\n}\n```\n\nThe **signals** pattern looks like this:\n\n```js\n/modules\n  /home\n    /actions\n    /signals\n    index.js\nmain.js\n```\n\n```js\nimport somethingHappened from './signals/somethingHappened'\n\nexport default {\n  signals: {\n    somethingHappened\n  }\n}\n```\n\nThere is no \"correct way\" to do this, do what makes sense to you and your team.\n\n\nIn the **main.js** file, the module is added to the controller:\n\n```js\nimport {Controller} from 'cerebral'\nimport home from './modules/home'\n\nconst controller = Controller({\n  modules: {\n    home\n  }\n})\n```\n\nAny signal and state defined inside the *home* module will live on the namespace chosen during controller instantiation. In the example above, this is: **home**.\n\nThe *modules/home/index.js* typically looks like this:\n\n```js\nimport updateLatestPosts from './chains/updateLatestPosts'\n\nexport default {\n  state: {\n    latestPosts: []\n  },\n  signals: {\n    mounted: updateLatestPosts\n  }\n}\n```\n\nAnd this is how an application scales: by defining modules and submodules. Actions or chains that are common are often placed in a folder called **common**:\n\n```js\n/common\n  /actions\n  /chains\n/modules\n  /home\n    /actions\n    /chains\n    index.js\nmain.js\n```\n\n## Components\n\nA very important point in Cerebral is that your components do not affect the structure of the application state. Modules are defined in terms of what makes sense for state and signals. Sometimes this is similar to how components are structured, but more often it is not. This is why components usually live in their own **components** folder, separated from the modules:\n\n```js\n/components\n  /Home\n    index.js\n/common\n  /actions\n  /chains\n/modules\n  /home\n    /actions\n    /chains\n    index.js\nmain.js\n```\n\nAnd this is it. You will never get in trouble creating a module because any action can change any state in your application. Modules are just a way to structure state and signals, not isolate them.\n","title":"Organizing"},"constants":{"raw":"# Constants\n\nWhen building larger applications it can be a good idea to define paths as constants. For example:\n\n*src/pathConstants.js*\n```js\nexport const ADMIN = 'admin'\nexport const FEED = 'home.feed'\n```\n\nInside your actions your can now do:\n\n```js\nimport {ADMIN} from '../../pathConstants'\n\nfunction someAction({paths, state}) {\n  state.set(`${ADMIN}.isLoading`, true)\n}\n```\n\nAnd in components you can:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\nimport {ADMIN} from '../../pathConstants'\n\nexport default connect({\n  isLoading: state`${ADMIN}.isLoading`\n},\n  function MyComp(props) {\n\n  }\n)\n```\n\nUsing constants in general makes your codebase less fragile to changes. You might want to change around where modules are defined and using constants will let you safely do that and change the path at one location.\n","title":"Constants"},"testing":{"raw":"# Testing\n\nCerebral makes it easy to test your application components and business logic.\n\n## Components\nThe **Container** you use to expose Cerebral to your components can also be used when testing, but you can also use the **StateContainer** which allows you to pass state down to your components as if it was extracted from the Cerebral controller.\n\n```js\nimport React from 'react'\nimport {mount} from 'enzyme'\nimport {StateContainer} from 'cerebral/react'\n\nimport Foo from './Foo'\n\ndescribe('<Foo />', () => {\n  it('allows us to set props', () => {\n    const state = {\n      foo: 'bar'\n    }\n    const wrapper = mount(\n      <StateContainer state={state}>\n        <Foo />\n      </StateContainer>\n    )\n    expect(wrapper.find('.foo')).to.have.length(1)\n  })\n})\n```\n\nThis approach allows you to pass down state wherever you want and ensure the components render as expected.\n\n## Actions\nActions are just functions. You just have to give them what they operate on. It is just like testing pure functions.\n\nGiven the action:\n```js\nfunction someAction({state, axios, path}) {\n  return axios.get(`/user/${state.get('user.id')}`)\n    .then((response) => path.success({user: response.data}))\n    .catch((error) => path.error({error: error.response.data}))\n}\n```\n\nYou can test it like:\n\n```js\nimport sinon from 'sinon'\nimport assert from 'assert'\n\ndescribe('Something', () => {\n  it('should return object with user', (done) => {\n    const mockedContext = {\n      axios: {get: Promise.resolve({data: {name: 'Arne'}})},\n      path: {success: sinon.spy()},\n      state: {get() {}}\n    }\n    someAction(mockedContext).then((result) => {\n      assert.ok(mockedContext.path.success.called)\n      assert.deepEqual(result, {user: {name: 'Arne'}})\n    })\n  })\n})\n```\n\n## Signals\nTo test signals you need to mock the context for all running actions. Since signals are defined decoupled from what is running them, you can define a new controller where you mock out whatever does side effects.\n\n```js\nimport sinon from 'sinon'\nimport assert from 'assert'\nimport {Controller} from 'cerebral'\nimport someChain from '../src/chains/someChain'\n\ndescribe('Something', () => {\n  it('should get data', (done) => {\n    const controller = Controller({\n      state: {\n        isLoading: false,\n        user: null\n      },\n      signals: {\n        testRun: someChain\n      },\n      providers: [\n        function (context) {\n          context.axios = {\n            get() {\n              assert.ok(controller.getState('isLoading'))\n\n              return Promise.resolve({data: {name: 'Arne'}})\n            }\n          }\n\n          return context\n        }\n      ]\n    })\n\n    controller.on('signalEnd', () => {\n      assert.deepEqual(controller.getState(), {\n        isLoading: false,\n        user: {name: 'Arne'}\n      })\n      done()\n    })\n    controller.getSignal('testRun')()\n  })\n})\n```\n","title":"Testing"},"load_initial_data":{"raw":"# Load initial data\n\nTypically you need to fetch some initial data when your application loads. Since the only place to do this is in signals, you need to trigger a signal when your application loads.\n\nThe most straight forward way to do this is when to trigger a signal when your application loads.\n\nIn your root component, typically **App**:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  title: state`app.title`\n  mounted: signal`app.mounted`\n},\n  class App extends React.Component {\n    componentDidMount() {\n      this.props.mounted()\n    }\n    render() {\n      return (\n        <div>\n          <h1>{this.props.title}</h1>\n        </div>\n      )\n    }\n  }\n)\n```\n\nNow you do whatever data fetching and state updates you need in the **mounted** signal.\n\n## With routing\nWhen you use the router there might be multiple entry points to your application and at any point you need to load some initial data. This is where factories comes in handy. Imagine one of the modules:\n\n```js\nimport openModule from './chains/openModule'\nimport withInitialData from '../../common/factories/withInitialData'\n\nexport default {\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    routed: withInitialData(openModule)\n  }\n}\n```\n\nYou would do the same with any other routing entry points. The **withInitialData** factory simply does something like this:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nfunction withInitialData (continueChain) {\n  return [\n    set(state`app.isLoading`, true),\n    [\n      getThisData, {\n        success: [],\n        error: []\n      }\n      getThatData, {\n        success: [],\n        error: []\n      }\n    ],\n    set(state`app.isLoading`, false),\n    ...continueChain\n  ]\n}\n```\n\nWe basically run a chain and compose in whatever we want to continue doing when it is done.\n","title":"Load initial data"},"storing_server_data":{"raw":"# Storing server data\n\nYour application usually needs to talk to a backend, grab some data and show it to the users. There are thousands of different types of backends and thousands of ways to structure the data. Discussions on how to store this data in the client, caching, optimistic updates, naming properties and endpoints are endless. Cerebral can only show you its preferred practice to solving this, but you are free to do whatever makes sense to you.\n\n## Store as objects, compute to arrays\nWhy do we store data in arrays? And why do we store them as objects? So for example a list of users:\n\n```js\n// As array\n[{\n  id: '123',\n  name: 'Bob'\n}]\n\n// As object\n{\n  '123': {\n    id: '123',\n    name: 'Bob'\n  }\n}\n```\n\nThese ways of storing data has different benefits. Arrays are really great for views. Typically views only wants to map over an array of data and create a component for each item in array. Objects though are really great for lookups. If you have the ID of the user it requires way less computation and syntax to grab the user data:\n\n```js\nconst id = '123'\n\nconst userFromArray = users.filter(user => user.id === id)[0]\n\nconst userFromObject = users[id]\n```\n\nSo which one should you choose? Well, both! Use objects to structure data in the model and use arrays in your components. Let us see how to achieve that. Imagine you get this data structure from the server:\n\n```js\n[{\n  id: '123',\n  name: 'Bob'\n},\n...]\n```\n\nWhen this data is received you want to convert it to an object:\n\n```js\nfunction setUsers({input, state}) {\n  const users = input.result.reduce((usersMap, user) => {\n    usersMap[user.id] = user\n\n    return usersMap\n  }, {})\n\n  state.set('app.users', users)\n}\n```\n\nNow we have created a map of our users instead for easy lookup:\n\n```js\n{\n  '123': {\n    id: '123',\n    name: 'Bob'\n  },\n  ...\n}\n```\n\nSo let us show all the users in a **Users** component. A naive implementation would be to just grab all the users in the component, iterate over them and create a new **User** component for each user and pass in the user. We will soon see why. So let us use a Computed to do this right:\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default compute(\n  state`app.users`,\n  (users) => {\n    return Object.keys(users)\n  }\n)\n```\n\nSo here we are returning only the keys of all the users. Inside our **Users** component we will only pass the key of the user to the children:\n\n```js\nimport {connect} from 'cerebral-view-whatever'\nimport usersKeys from '../../computed/usersKeys'\nimport User from '../User'\n\nexport default connect({\n  usersKeys\n},\n  function Users(props) {\n    return (\n      <ul>\n        {props.usersKeys.map((userKey) => (\n          <User key={userKey} userKey={userKey} />\n        ))}\n      </ul>\n    )\n  }\n)\n```\n\nWith this approach we can now bind each user specifically to the state it needs, meaning that we isolate the rendering when any of the users update. That means only the component responsible for a specific user will render when that user changes:\n\n```js\nimport {connect} from 'cerebral/react'\nimport {state, props} from 'cerebral/tags'\nexport default connect({\n  user: state`users.${props`userKey`}`\n},\n  function User(props) {\n    return (\n      <li>{props.user.name}</li>\n    )\n  }\n)\n```\n\nSo this is one of the benefits we get. Optimized rendering. Now lets look what happens when we want to sort our users. Back in our computed:\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default compute(\n  state`app.users`,\n  state`app.sortOrder`,\n  (users, sortOrder) => {\n    return Object.keys(users).sort((userAKey, userBKey) => {\n      const userA = users[userAKey]\n      const userB = users[userBKey]\n\n      if (userA.name.toLowerCase() > userB.name.toLowerCase()) {\n        return sortOrder === 'asc' ? -1 : 1\n      } else if (userA.name.toLowerCase() < userB.name.toLowerCase()) {\n        return sortOrder === 'asc' ? 1 : -1\n      }\n\n      return 0\n    })\n  }\n)\n```\n\nNow we have a really good data structure for doing lookups of users, but we also have a powerful concept of producing an array of data that the component can use. The good thing is that these computed will only run when their depending state changes and they are in use in the component.\n\nWhat is also important to remember here is that doing these kind of plain javascript computations is extremely fast, it is rendering the view that takes time.\n\n## Optimistic updates\nBut we can get other benefits from this as well. Instead of using the user ID as the key, we can create our own:\n\n```js\nimport uuid from 'uuid'\n\nfunction setUsers({input, state}) {\n  const users = input.result.reduce((usersMap, user) => {\n    usersMap[uuid.v4()] = user\n\n    return usersMap\n  }, {})\n\n  state.set('app.users', users)\n}\n```\nEverything works exactly the same, but now we have a client specific reference to our users, instead of ids. This allows us to do optimistic updates.\n\n```js\nimport uuid from 'uuid'\n\nfunction addUser({input, state, output}) {\n  const newUserKey = uuid.v4()\n\n  state.set(`app.users.${newUserKey}`, {\n    id: null,\n    name: input.name\n  })\n\n  return {newUserKey}\n}\n```\n\nWe also return the new userKey to the signal so that actions after it can use it to update the user with an ID when the server responds etc.\n\nIf you look at the [cerebral-todomvc](https://cerebral.github.io/todomvc) project you can see this pattern in action.\n","title":"Storing server data"},"lists":{"raw":"# Lists\nTypically when working with lists you would:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  items: state`app.items`\n},\n  function Items(props) {\n    return (\n      <ul>\n        {props.items.map((item, index) => {\n          <Item key={index} item={item} />\n        })}\n      </ul>\n    )\n  }\n)\n```\n\nThis is perfectly okay if the list is not very large or the list is not related to entities (objects with ids). But when working with Cerebral and entities you should favor storing them as a map instead. That means:\n\n```js\n{\n  items: {\n    id1: {},\n    id2: {},\n    id3: {}\n  }\n}\n```\n\nThis gives you three benefits:\n\n1. If you give each item a client side id, for example using [uuid](https://www.npmjs.com/package/uuid), you can very easily optimistically add new items without worrying about their place in some list. They will get a client side id and can always be referenced by that\n2. It will be faster and less code to look up entities when you have an id to reference them with. You just point to **items.id2** and you have the item. No array search\n3. Your components can connect directly to an entity\n\nSo let us imagine we have a map of items instead:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  items: state`app.items`\n},\n  function List(props) {\n    return (\n      <ul>\n        {Object.keys(props.items).map((itemKey) => {\n          <Item key={itemKey} itemKey={itemKey} />\n        })}\n      </ul>\n    )\n  }\n)\n```\n\nWe are now giving the component only a reference to the item it should connect to. That means inside our **Item** component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, props} from 'cerebral/tags'\n\nexport default connect((props) => ({\n  item: state`app.items.${props`itemKey`}`\n}),\n  function Item(props) {\n    return (\n      <div>\n        {props.item.title}\n      </div>\n    )\n  }\n)\n```\n\nThis component is now optimized, it is more explicit about where it gets its state from and you also got the other benefits mentioned above.\n\n## Computing lists\nTypically you would put a computed in between the component and the items, for sorting and filtering reasons, only returning the keys. For example, returning the keys in sorted order by *datetime*:\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default compute(\n  state`app.items`\n  (items) => {\n  return Object.keys(items)\n    .sort((itemAKey, itemBKey) => {\n      const itemA = items[itemAKey]\n      const itemB = items[itemBKey]\n\n      if (itemA.datetime > itemB.datetime) {\n        return 1\n      } else if (itemA.datetime < itemB.datetime) {\n        return -1\n      }\n\n      return 0\n    })\n  }\n)\n```\n\nNow in the component you just do:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport itemsKeys from '../computed/itemsKeys'\n\nexport default connect({\n  itemsKeys\n},\n  function List(props) {\n    return (\n      <ul>\n        {props.itemsKeys.map((itemKey) => {\n          <Item key={itemKey} itemKey={itemKey} />\n        })}\n      </ul>\n    )\n  }\n)\n```\n\n## Identifying current item\nSometimes you want to highlight the current item in a list. You might be tempted to add this logic in the **Item** components:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, props} from 'cerebral/tags'\n\nexport default connect((props) => ({\n  item: state`app.items.${props`itemKey`}`,\n  currentItemKey: state`app.currentItemKey`\n}),\n  function Item(props) {\n    return (\n      <div className={`item ${props.itemKey === props.currentItemKey} ? 'selected' : ''`}>\n        {props.item.title}\n      </div>\n    )\n  }\n)\n```\n\nBut this will make every item in the list render again when **app.currentItemKey** changes. A better approach is to rather make the parent component handling the list check this:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport itemsKeys from '../computed/itemsKeys'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  itemsKeys,\n  currentItemKey state`app.currentItemKey`\n},\n  function List(props) {\n    return (\n      <ul>\n        {props.itemsKeys.map((itemKey) => {\n          <Item\n            key={itemKey}\n            itemKey={itemKey}\n            selected={itemKey === props.currentItemKey}\n          />\n        })}\n      </ul>\n    )\n  }\n)\n```\n\nNow only the component that actually changes its **selected** prop will do a new render.\n\nLists are the UI output that affects performance the most. Usually it is no problem with over-rendering, cause there are no changes to the DOM anyways, but on big lists React/Inferno can get into problems if it is not optimized. Luckily Cerebral does this for you when you follow this convention.\n","title":"Lists"},"modals":{"raw":"# Modals\n\nModals are one of those things that are more complex than you might think. So lets start with a simple modal using a module:\n\n*src/modules/app/index.js*\n```js\nexport default {\n  state: {\n    title: 'My modal demo',\n    showMyModal: false\n  }\n}\n```\n\nEither we want to show the modal or we do not. To actually trigger the modal we can create a signal that will toggle the state. To simplify the example we define the chain inside the same file:\n\n```js\nimport {toggle} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default {\n  state: {\n    title: 'My modal demo',\n    showMyModal: false\n  },\n  signals: {\n    myModalToggled: [\n      toggle(state`app.showMyModal`)\n    ]\n  }\n}\n```\n\nSo in our view we just render the Modal:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\n\nimport MyModal from './MyModal'\n\nexport default connect({\n  title: state`app.title`\n  myModalToggled: signal`app.myModalToggled`\n},\n  function App(props) {\n    return (\n      <div onClick={() => props.myModalToggled()}>\n        <h1>{props.title}</h1>\n        <MyModal />\n      </div>\n    )\n  }\n)\n```\n\nSo what to take note of here is that we have created a specific modal component for our modal. That means if we want multiple modals in our application each of them will have their own **modal** state and component. That does not mean you have to create the backdrop and modal container for each modal, that is just UI, but you create a specific component for each modal and connect what state it wants directly. Lets look at the modal we just created using React as an example:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nimport ModalContainer from './ModalContainer'\n\nexport default connect({\n  show: state`app.showMyModal`\n  myModalToggled: signal`app.myModalToggled`\n},\n  function MyModal(props) {\n    if (!props.show) {\n      return null\n    }\n\n    return (\n      <ModalContainer onClose={props.myModalToggled}>\n        Hello modal!\n      </ModalContainer>\n    )\n  }\n)\n```\n\nWe control the modal from within the component. Either it does not show anything or it will render a **fixed** modal container which allows us to pass in a signal to run when the modal should close.\n\n## Increasing complexity\nSo let us increase complexity here. What if our modal was a modal to show a user based on a userId? An approach to this is adding a **currentUserId** to state. And instead of having a **modalToggled** kind of signal we have one signal for opening the modal, where we set the passed in *userId*, and an other for closing it:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, input} from 'cerebral/tags'\n\nexport default {\n  state: {\n    title: 'My modal demo',\n    showUserModal: false,\n    currentUserKey: null,\n    users: {}\n  },\n  signals: {\n    userModalOpened: [\n      set(state`app.showUserModal`, true),\n      set(state`app.currentUserKey`, input`userKey`)\n    ],\n    userModalClosed: [\n      set(state`app.showUserModal`, false)\n    ]\n  }\n}\n```\n\nNow our modal component can grab the user and update separately from the list:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, signal, props} from 'cerebral/tags'\n\nimport ModalContainer from './ModalContainer'\n\nexport default connect({\n  show: state`app.showMyModal`,\n  user: state`app.users.${state`currentUserKey`}`,\n  userModalClosed: signal`app.userModalClosed`\n},\n  function UserModal(props) {\n    if (!props.show) {\n      return null\n    }\n\n    return (\n      <ModalContainer onClose={props.userModalClosed}>\n        Hello {props.user.name}!\n      </ModalContainer>\n    )\n  }\n)\n```\n\nWhat is good about this approach is that you can very easily handle grabbing more information about the user if needed. Lets say we needed to download the user projects when opening the modal:\n\n```js\nimport {when, set} from 'cerebral/operators'\nimport {state, input, string} from 'cerebral/tags'\nimport {httpGet} from 'cerebral-provider-http'\n\nexport default {\n  state: {\n    title: 'My modal demo',\n    showUserModal: false,\n    currentUserKey: null,\n    users: {},\n    isLoadingProjects: false\n  },\n  signals: {\n    userModalOpened: [\n      set(state`app.showUserModal`, true),\n      set(state`app.currentUserKey`, input`userKey`),\n      set(state`app.isLoadingProjects`, true),\n      set(input`userId`, state`app.users.${input`userKey`}.id`),\n      httpGet(string`/users/${input`userId`}/projects`), {\n        success: [\n          set(state`app.users.${input`userKey`}.projects`, input`result`)\n        ],\n        error: []\n      },\n      set(state`app.isLoadingProjects`, false)\n    ],\n    userModalClosed: [\n      set(state`app.showUserModal`, false)\n    ]\n  }\n}\n```\n\nThis is not Cerebral complexity, this is application complexity and it has to be defined somewhere. We could hide it in an abstraction or we can describe it exactly as it happens so everybody understands, including the debugger!\n\n## Editing the user\nSo what if we display the user to edit it? Well, we have to take into account that we probably do not want to edit the user directly, we rather want a copy of the data that will later be merged in with the user if we submit it. So instead of pointing to the user, we will copy over the details of the user for edit in our modal. When the modal close, we update the server:\n\n```js\nimport {when, set} from 'cerebral/operators'\nimport {state, input, string} from 'cerebral/tags'\nimport {httpPatch} from 'cerebral-provider-http'\n\nexport default {\n  state: {\n    title: 'My modal demo',\n    userModal: {\n      show: false,\n      fields: {\n        firstName: '',\n        lastName: ''\n      }\n    },\n    users: {},\n    isSavingUser: false\n  },\n  signals: {\n    userModalOpened: [\n      set(state`app.userModal.show`, true),\n      set(state`app.userModal.fields.firstName`, state`users.${input`userKey`}.firstName`),\n      set(state`app.userModal.fields.lastName`, state`users.${input`userKey`}.lastName`)\n    ],\n    userModalClosed: [\n      set(input`userId`, state`app.users.${input`userKey`}.id`),\n      set(state`isSavingUser`, true),\n      httpPatch(string`/users/${input`userId`}`, state`userModal.fields`), {\n        success: [\n          set(state`isSavingUser`, false),\n          set(state`app.userModal.show`, false)\n        ],\n        error: []\n      }\n    ]\n  }\n}\n```\n\nWe brought a lot of complexity into this, but that is important as typically this is what you want to do in applications. Modals can also be handled other ways, for example maybe you want an array of named modals which is mounted by a \"modal controller component\". This pretty much works like you would handle pages with the router, though you rather render multiple modals on top of each other. The important thing here is to see that everything is the same. It does not matter the complexity and customization you want to do, you are completely free to do it however you want.\n","title":"Modals"},"feedback_messages":{"raw":"# Feedback messages\n\nFeedback messages, snackbars, toasts etc. There are many names and approaches to how you give users feedback about what they are doing in your application, and maybe more importantly if something goes wrong. These feedback messages can actually be surprisingly complex. The reason is that you do not know when the next message will appear. Maybe showing the first one is not done yet... what should happen? Should it overwrite the current message, but what about the timing? Should it extend the timing of showing that message? Or maybe you want to display the messages in a list?\n\nWe are going to explore how we can solve these scenarios using Cerebral.\n\n## A simple feedback message\nLet us add a state for showing the message first in our **App** module:\n\n```js\nexport default {\n  state: {\n    feedbackMessage: null\n  }\n}\n```\n\nNow let us create a chain factory we can compose into any other chain to display this message.\n\n```js\nimport {set, wait} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nfunction showMessage (message) {\n  return [\n    set(state`app.feedbackMessage`, message),\n    wait(5000),\n    set(state`app.feedbackMessage`, null)\n  ]\n}\n\nexport default showMessage\n```\n\nWe can now compose this chain into another chain, for example doing a request:\n\n```js\nimport getSomething from '../actions/getSomething'\nimport setSomething from '../actions/setSomething'\nimport feedbackMessage from '../factories/feedbackMessage'\n\nexport default [\n  getSomething, {\n    success: [\n      setSomething,\n      ...feedbackMessage('Fetched something!')\n    ],\n    error: [\n      ...feedbackMessage('Failed fetching something :(')\n    ]\n  }  \n]\n```\nBut we have an issue here. What if two message appear within 5 seconds? What if another one is triggered after 4 seconds? It will change the text, but after 1 second it will close... instead of waiting a new 5 seconds. And after another 4 seconds it will try to close it again, without needing to.\n\nLet us see how we can make this better.\n\n## Debouncing\nWe can use debouncing instead.\n\n```js\nimport {set, debounce} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\n// We first create a shared debounce. The benefit\n// of this is that any use of this showMessage factory\n// in any signal will then cancel out existing debounces\nconst showMessageDebounce = debounce.shared()\n\nfunction showMessage (message) {\n  return [\n    set(state`app.feedbackMessage`, message),\n    showMessageDebounce(5000), {\n      continue: [\n        set(state`app.feedbackMessage`, null),\n      ],\n      discard: []\n    }\n  ]\n}\n\nexport default showMessage\n```\n\nNow we have essentially fixed the problem. If again a new message triggers after 4 seconds, the debounce will discard the first one. If no new messages trigger during 5 seconds it will close the message, or if a new one appears it will again replace the text, discard the previous and wait 5 seconds to close.\n\n## Multiple messages\nWhat if we wanted to stack messages in a list if there were messages there already?\n\nFirst let us change our state to handle multiple messages:\n\n```js\nexport default {\n  state: {\n    feedbackMessages: []\n  }\n}\n```\n\nAnd now let us rather unshift a new message to the array, then remove all messages when 5 seconds has passed.\n\n```js\nimport {set, unshift, debounce} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nconst showMessageDebounce = debounce.shared()\n\nfunction showMessage (message) {\n  return [\n    unshift(state`app.feedbackMessages`, message),\n    showMessageDebounce(5000), {\n      continue: [\n        set(state`app.feedbackMessages`, [])\n      ],\n      discard: []\n    }\n  ]\n}\n\nexport default showMessage\n```\n\nSo now as long as we are showing messages we will stack them on top of each other. When 5 seconds has passed without any new messages it will close and clear out all messages.\n","title":"Feedback messages"},"popups":{"raw":"# Popups\n\nPopups are different than modals. They are more in the realm of dropdowns, popup menus and even tooltips. What they share in behavior is that if you open one of them, the others should close. There are two approaches to this. You can create a stateful component handler for it, or you can use Cerebral and make it very explicit. There is no right answer, it depends on your application. But let us look at the Cerebral approach.\n\n## Closing everything\nFirst we need to close all these popup when we click our application. Let us create a chain that closes them:\n\n```js\nimport {set} from 'cerebral/operators';\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`app.showSomePopover`, false)\n]\n```\n\nNow we register this chain to a signal on our **app** module:\n\n```js\nimport closePopovers from './chains/closePopovers'\n\nexport default {\n  state: {\n    showSomePopover: false\n  },\n  signals: {\n    clicked: closePopovers\n  }\n}\n```\n\nAnd then in our root component we trigger the signal whenever we click our application:\n\n```js\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({}, {\n  clicked: state`app.clicked`\n},\n  function App (props) {\n    return (\n      <div onClick={() => props.clicked()}>\n        ...\n      </div>\n    )\n  }\n)\n```\n\nWhenever we now click our application all our popups will close and we can see that behavior in the debugger as well.\n\n## Prevent closing\nSo when we now click a button to show a popover we have to ensure that our application does not trigger the click event on the root component, because then they will just close again. Let us imagine we have a signal that changes the *showSomePopover* state to *true* (showSomePopoverClicked).\n\n```js\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  showSomePopover: state`app.showSomePopover`,\n  showSomePopoverClicked: signal`app.showSomePopoverClicked`\n},\n  function MyPopover(props) {\n    return (\n      <div onClick={(event) => {\n        event.stopPropagation()\n        props.showSomePopoverClicked()\n      }}>\n        <div>\n          Show popover\n        </div>\n        {\n          props.showSomePopoverClicked ?\n            <div>Some popover</div>\n          :\n            null\n        }\n      </div>\n    )\n  }\n)\n```\n\nUsing **event.stopPropagation()** we prevent any clicks on the button and the popover itself to propagate up to the application root component. So when our chain handling the popover click runs:\n\n```js\nimport {set} from 'cerebral/operators';\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`app.showSomePopover`, true)\n]\n```\n\nWe will show the popover. Clicking outside it will hide it. Now, you might want to close all the other popovers when you open a new one. Just compose it in:\n\n```js\nimport closePopovers from '../chains/closePopovers'\nimport {set} from 'cerebral/operators';\nimport {state} from 'cerebral/tags'\n\nexport default [\n  ...closePopovers,\n  set(state`app.somePopover`, true)\n]\n```\n\nSo this gives you complete control of handling popups and you can make any kind of custom behavior to any of them.\n\n## Dynamic popups\nSometimes you have a list where each item in the list should show a popup. In this case we want to dynamically open a popup. It is basically the same approach, but we use a state property that takes a reference to the current item instead:\n\n```js\nimport openItemPopover from './chains/openItemPopover'\n\nexport default {\n  state: {\n    currentItemPopover: null,\n    items: {\n      '123': {\n        title: 'Some item'\n      },\n      '456': {\n        title: 'Some other item'\n      }\n    }\n  },\n  signals: {\n    itemPopoverClicked: openItemPopover\n  }\n}\n```\n\nSo now let us imagine that we are dynamically building a list of items which contains a popover. For each item we create a new component:\n\n```js\nimport {connect} from 'cerebral/react'\nimport {state, signal, props} from 'cerebral/tags'\n\nexport default connect({\n  item: state`app.items.${props`itemKey`}`\n  currentItemPopover: state`app.currentItemPopover`\n  itemPopoverClicked: signal`app.itemPopoverClicked`\n},\n  function Item(props) {\n    return (\n      <div>\n        <div>{props.item.title}</div>\n        <div onClick={(event) => {\n          event.stopPropagation()\n          props.itemPopoverClicked({\n            itemKey: props.itemKey\n          })\n        }}>\n          <div>\n            Show popover\n          </div>\n          {\n            props.currentItemPopover === props.itemKey ?\n              <div>Some popover</div>\n            :\n              null\n          }\n        </div>\n      </div>\n    )\n  }\n)\n```\n\nWhat we do here is rather check if the current item popover matches the key of the item itself. So our **openItemPopover** chain would look something like:\n\n```js\nimport {input, set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`app.currentItemPopover`, input`itemKey`)\n]\n```\n\nNow you can again change this behavior. You might use an array instead to allow opening multiple popovers. But this is pretty much how you go about.\n\n## What if Cerebral is inside other app?\nIf your root component does not cover the whole browser you can rather listen to clicks on the window, using react as example:\n\n```js\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  someState: state`app.someState`,\n  clicked: signal`app.clicked`\n},\n  class App extends React.Component {\n    componentDidMount() {\n      window.addEventListener('click', () => this.props.clicked())\n    }\n    render() {\n      return (\n        <div>\n          ...\n        </div>\n      )\n    }\n  }\n)\n```\n\nBut now we are outside of React own event system. So when you click something you have to make sure that you stop propagating the native event, not React event.\n\n```js\nimport {connect} from 'cerebral/react'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  showPopover: state`app.showPopover`,\n  showPopoverClicked: signal`app.showPopoverClicked`\n},\n  function MyPopover(props) {\n    return (\n      <div onClick={(event) => {\n        event.nativeEvent.stopPropagation()\n        props.showPopoverClicked()\n      }}>\n        <div>\n          Show popover\n        </div>\n        {\n          props.showPopover ?\n            <div>Some popover</div>\n          :\n            null\n        }\n      </div>\n    )\n  }\n)\n```\n","title":"Popups"},"long_running_side_effects":{"raw":"# Long running side effects\n\nMost *signals* in your application are triggered by users interacting with the UI-- typing in an input, submitting a form, or closing a modal window. But, many times your application needs to respond to events from the \"outside\" world. These could be websocket messages from services like Firebase, chat messages from your backend, or even simple HTTP long polling for data.\n\nIn Cerebral, these processes can be encapsulated in a provider.\n\n## An HTTP Polling Provider\n\nLets imagine you have a navbar component which should the current count of messages. Let us first implement the provider and then see how it can be used:\n\n```js\nfunction HttpPoller (options = {}) {\n  let cachedProvider = null\n\n  function createProvider ({http, controller}) {\n    return {\n      start (url, frequencyMs, signalPath) {\n        http.get(url)\n          .then((result) => {\n            controller.getSignal(signalPath)(result)\n            setTimeout(this.start.bind(this, url, frequencyMs, signalPath), frequencyMs)\n          })\n      }\n    }\n  }\n\n  return (context) => {\n    context.httpPoller = cachedProvider = cachedProvider || createProvider(context)\n\n    if (context.debugger) {\n      context.debugger.wrapProvider('httpPoller')\n    }\n\n    return context\n  }\n}\n```\n\nThis is a very simple implementation that shows you how to trigger signals from within a provider. The poller should also have the possibility to stop polls of course.\n\n### Defining the Action\n\nLets use the **httpPoller** service in our action:\n\n```js\nfunction pollMessageCounts({state, httpPoller}) {\n  const id = state.get('currentUser.id');\n\n  httpPoller.start(`/api/message_counts/${id}`, 'navbar.messageCountsFetched')\n}\n```\n\n### With signals now\n\nNow we can implement our signals and their corresponding action chains in our **navbar** module and define our component:\n\n*src/modules/navbar/index.js*\n```js\nimport {input, set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\nimport pollMessageCounts from './actions/pollMessageCounts'\n\nexport default {\n  state: {\n    messageCounts: 0\n  },\n  signals: {\n    mounted: [\n      pollMessageCounts\n    ],\n    messageCountsFetched: [\n      set(state`navbar.messageCounts`, input`result`)\n    ]\n  }\n}\n```\n","title":"Long running side effects"},"server_side":{"raw":"# Server side\n\n\"Can I use Cerebral on the server?\". Yes, technically you can, but you actually should not. Cerebral is a framework for building applications with user interfaces. Running code related to talking to a server on the server does not really make sense. What does make sense though is pre-rendering and handle complex flows on server side logic.\n\n## Pre-rendering\nBoth [react](https://facebook.github.io/react/) and [inferno](https://github.com/trueadm/inferno) supports rendering your application on the server. But that does not mean your application runs on the server. The only thing you need to pre-render your application is state. The **StateContainer** allows you to render your application by just passing an object as the state of your app:\n\n```js\nimport {StateContainer} from 'cerebral/react'\nimport {renderToString} from 'react-dom/server'\n\nconst html = renderToString(\n  <StateContainer state={someServerCreatedState}>\n    <App />\n  </StateContainer>\n)\n```\n\nInstead of passing the Cerebral controller to the container, you just pass it the state of the application. This will render your application in the correct state. How you produce this state is up to you though. Applications are very different related to producing state on the server so there is not \"one answer\" here.\n\nIt might be a good idea to define the state of your application in one file, instead of using modules:\n\n```js\nexport default {\n  app: {},\n  posts: {}\n}\n```\n\nThis way you can import the same state file on your client and on the server. On the server you just populate the missing state.\n\n## Business logic\nYou might also be tempted to use Cerebral to handle server side business logic. But Cerebral is actually a small wrapper around [function-tree](https://github.com/cerebral/function-tree). Function-tree has its own debugger and gives you more flexibility in handling complexities on the server as well.\n","title":"Server side"}},"migration":{"index":{"raw":"# From 1.x to 2.x\n\nWhen migrating from 1.x to 2.x you need to take the following under consideration.\n\n- There are no models left to choose from. Cerebral now comes with one model.\n- Services have been removed in favor of function-tree/providers.\n\n## Controller\nInstead of choosing your model and connecting to the *Controller* as in 1.x as shown below\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nconst controller = Controller(Model({\n  // You can add some initial state here if you want\n}))\n\nexport default controller\n```\n\nYou would simply do the following in 2.x\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {\n    // You can add some initial state here if you want\n  }\n})\n\nexport default controller\n```\n\n**controller.getSignals()** is removed from 2.x so favor **controller.getSignal('some.signal')** instead.\n\n## Modules\nIn 1.x you would have done something like this\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  home: Home,\n  admin: Admin\n})\n\nexport default controller\n```\n\nIn 2.x the modules are defined along with the controller\n\n```js\nimport {Controller} from 'cerebral'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller({\n  modules: {\n    home: Home(),\n    admin: Admin()\n  }\n})\n\nexport default controller\n```\n\nSub-modules can be defined by each module in the same way (see below).\n\nIn 1.x you would create your own module like this\n\n```js\n// 1.x\nexport default module => {\n  module.addState({\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  })\n\n  module.addSignals({\n    newItemTitleSubmitted: submitNewItemTitle\n  })\n}\n```\n\naddState, addSignals have been removed, so in 2.x you simply return an object\n\n```js\n// 2.x\nexport default {\n  state: {\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  },\n  modules: {\n    subModule: SubModule()\n  },\n  signals: {\n    newItemTitleSubmitted: submitNewItemTitle\n  }\n}\n```\n\n## Operators\nThe biggest change to Cerebral 2.x is the operators. You can read more about them in the Operators docs. They have become very powerful and you can create your own operators. Operators in Cerebral 2.x has been moved into core Cerebral. You can still use the old operators if you want by installing them via npm.\n\n```js\nnpm install cerebral-operators --save\n```\n\nThe new operators now use tagged template literals and you can reduce number of actions and instead use the new operators. Here is a quick sample. As you can see you import them from 'cerebral/operators'\n\n```js\nimport {\n  set // other operators include: wait, when, equals, debounce, push, pop, shift, toggle, unset, splice\n} from 'cerebral/operators'\nimport {\n  state,\n  input\n} from 'cerebral/tags'\n\nexport default [\n  set(state`foo.bar`, input`bar`)\n]\n```\n\n## Signals\nYou handle signals mostly the same way as in 1.x. You can describe signals in a module or in the controller directly.\n\n### 1.x\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral-model-immutable'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller(Model({}))\n\ncontroller.addSignals({\n  buttonClicked: doSomething,\n  fieldChanged: { immediate: true, chain: updateField }\n})\n```\n### 2.x\n```js\nimport {Controller} from 'cerebral'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller({\n  signals: {\n    buttonClicked: doSomething,\n    fieldChanged: updateField\n  }\n})\n```\n\nOne note when using signals is that the **immediate** option is gone. This keeps the api cleaner.\n\n## Actions\nSince cerebral 2.x is using **function-tree** under the hood we have other, more powerful options than before. The input, state is the same but output is gone. You can just return an object from the action that will be available in the input for the next action. You can also return a **path** that is a new concept in Cerebral 2.x and outdates output. **path** is used to determine the execution path for your chain. You do no longer have services as an argument in the context, use providers instead.\n\n### 1.x\n```js\nfunction myAction({input, state, output, services}) {\n\n}\n```\n\nIn 2.x you have the following. Instead of services you hook up providers that supersedes services.\n\n```js\nfunction myAction({input, state, path /*, myProvider, otherProvider */ }) {\n\n}\n```\n\nWhen you wanted to output to paths in 1.x you would do something like this\n```js\nfunction myAction({state, output}) {\n  if (state.get('app.isAwesome')) {\n    output.awesome()\n  } else {\n    output.notSoAwesome()\n  }\n}\nmyAction.outputs = ['awesome', 'notSoAwesome']\n```\n\nWith the new **path** concept this is simpler. In 2.x you would just do what is stated below. Please note the **return path...**. The same is true with promises. They need to be returned.\n\n```js\nfunction myAction({state, path}) {\n  if (state.get('app.isAwesome')) {\n    return path.awesome()\n  } else {\n    return path.notSoAwesome()\n  }\n}\n```\n\nIf you don't want to take another path in the execution tree you could return a new object that would be available in the input object.\n\n```js\nfunction myAction({state, path}) {\n  return {\n    someData: 'Some new data available at output.someData'\n  }\n}\n```\n\nWhen doing async operations you would do something like this in 1.x\n\n```js\nfunction myAction({output}) {\n  setTimeout(() => {\n    output({ /* optional output */ }) // or output.pathName({ /* optional output */ })\n  }, 1000)\n}\n\nmyAction.async = true\n```\n\nIn Cerebral 2 you you must resolve or reject a returned promise.\n\n```js\nfunction myAction({path}) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({ /* optional output */ }) // or resolve(path.pathName({ /* optional output */ }))\n    }, 1000)\n  })\n}\n```\n\nIn 1.x you could set a path that wasn't defined yet in the state tree. Let's say your state looked like this.\n\n```js\n{\n  app: {\n    nodes: {}\n  }\n}\n```\n\nYou could do this in an action.\n\n```js\nfunction myAction({state}) {\n  state.set('app.nodes.some.state.more', {updated: true})\n}\n```\n\nWith 2.x this is no longer possible. It's easy to mistype paths and therefore this option is no longer available. Your paths need to be in place before setting values to them.\n\nWhen using computed data in an action you could call **state.computed(myComputed())** in the action. This has changed in 2.x in favor of\n**state.compute(myComputed)**. You can also pass props to the compute function.\n\n```js\nfunction myAction({state}) {\n  state.compute(someComputed)\n  state.compute(someComputed.props({foo: 'bar'}))\n}\n```\n\nThis works the same in context for 2.x\n\n```js\nconnect({\n  foo: someComputed,\n  foo2: someComputed.props({foo: 'bar'})\n})\n```\n\n## Providers (outdates services)\n\nIn 1.x you could add services that would be available to you in the actions. Typically, you would do something like this in 1.x\n\n```js\nimport someExternalApi from 'some-external-api'\n\nexport default (options = {}) => module => {\n\n  if (!options.apiKey) {\n    throw new Error('This service needs an apiKey')\n  }\n\n  module.addServices({\n    connect() {\n      return someExternalApi.connect({\n        apiKey: options.apiKey\n      })\n    }\n  })\n\n}\n```\n\nIn 2.x you would use providers instead.\n\n```js\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  providers: [\n    ContextProvider({\n      axios\n    })\n  ]\n})\n```\n\nor manually\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  provider(context) {\n    context.myProvider = {\n      doSomething() {}\n    }\n    return context\n  }\n})\n```\n\nNow instead of having services in the context object in an action you would have the **axios** object.\n\n```js\nfunction myAction({axios}) {\n\n}\n```\n\n## Views\nHow you import view specific packages has changed. In 1.x you would import Container like this.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral-view-react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x you would not import the Container from another package.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nThe same is true when connecting Cerebral to your component. In 1.x you would import it like this.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral-view-react'\n\nexport default connect({\n  isLoading: 'app.isLoading'\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 2.x you would have to use a different import.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 1.x you would first connect state, then signals as separate arguments in connect. In Cerebral 2.x these are combined, tags are used to differentiate between state, signals and props.\n\n```js\n// 2.x\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {props, state, signal} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`,\n  item: state`items.${props`itemId`}`,\n  someSignal: signal`app.someSignal`\n}.\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIf you really want all signals in props as in 1.x you can set this as an option in the controller.\n\n```js\n// 2.x\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  options: {\n     signalsProp: true\n   }\n})\n```\n\n\n##  Model\nThe following functions have been removed from Cerebral 2.x when using state inside an action\n\n- logModel\n- export\n- findWhere\n- keys\n- import\n- toJs\n- toJson\n\n## Strict render mode\nTo setup strict render mode in 1.x for React was specified as follows.\n\n```js\nrender(\n  <Container controller={controller} strict>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x this is the only mode\n\n## Devtools\nThe devtools has changed as well. Go to chrome store and install cerebral2 debugger. The setup has slightly changed from 1.x to 2.x as well as the import.\n\n### 1.x\n```js\nimport Controller from 'cerebral'\nimport Model from 'cerebral/model/immutable'\nimport Devtools from 'cerebral-module-devtools'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools()\n})\n\nexport default controller\n```\n\n### 2.x\n```js\nimport Controller from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools(),\n  modules: {\n    ...\n  }\n})\n\nexport default controller\n```\n","title":"From 1.x to 2.x"}},"api":{"index":{"raw":"# Controller\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  // Defines the top level state\n  state: {},\n\n  // Defines the top level signals\n  signals: {},\n\n  // Defines the top level modules\n  modules: {}\n})\n```\n","title":"Controller"},"state":{"raw":"# State\nState can be defined at the top level in the controller and/or in each module. State is defined as plain JavaScript value types. Objects, arrays, strings, numbers and booleans. This means that the state is serializable. There are no classes or other abstractions around state. This is an important choice in Cerebral that makes it possible to track changes to update the UI, store state on server/local storage and passing state information to the debugger.\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar',\n    items: [{\n      name: 'foo'\n    }, {\n      name: 'bar'\n    }]\n  }\n})\n```\n## Special values support\nWhen building an application you often need to keep things like files and blobs in your state for further processing. Cerebral supports these kinds of values because they will never change, or changing them can be used with existing state API. This is the list of supported types:\n\n- **File**\n- **FilesList**\n- **Blob**\n\nIf you want to force Cerebral to support other types as well, you can do that with a devtools option. This is perfectly okay, but remember all state changes has to be done though the state API.\n\n## Get state\nThe only way to get state in your application is by connecting it to a component or grabbing it in an action.\n\n```js\nfunction someAction({state}) {\n  // Get all state\n  const allState = state.get()\n  // Get by path\n  const stateAtSomePath = state.get('some.path')\n  // Get computed state by passing in a computed\n  const computedState = state.compute(someComputed)\n}\n```\n\n\n## Updating state\nThe only way to update the state of your application is in an action. Here is a list of all possible state mutations you can do:\n\n```js\nfunction someAction({state}) {\n  // Set or replace a value\n  state.set('some.path', 'someValue')\n  // Unset a key and its value\n  state.unset('some.path')\n  // Merge the keys and their values into existing object. Handled as a\n  // change on all paths merged in\n  state.merge('some.path', {\n    some: 'value'\n  })\n  // Pushes a value to the end of the array\n  state.push('some.path', 'someValue')\n  // Puts the value at the beginning of the array\n  state.unshift('some.path', 'someValue')\n  // Removes last item in array\n  state.pop('some.path')\n  // Removes first item in array\n  state.shift('some.path')\n  // Concats passed array to existing array\n  state.concat('some.path', ['someValueA', 'someValueB'])\n  // Splices arrays\n  state.splice('some.path', 2, 1)\n}\n```\n","title":"State"},"signals":{"raw":"# Signals\n\n```js\nimport {Controller} from 'cerebral'\nimport updateData from './chains/updateData'\n\nconst controller = Controller({\n  state: {\n    data: null,\n    isLoading: false,\n    error: null\n  },\n  signals: {\n    mounted: updateData\n  }\n})\n```\n\nA convention is to attach chains to signals. These chains typically have their own folder:\n\n*src/chains/updateData.js*\n```js\nimport getData from '../actions/getData'\nimport {set} from 'cerebral/operators'\nimport {state, input} from 'cerebral/tags'\n\nexport default [\n  set(state`isLoading`, true),\n  getData, {\n    success: [\n      set(state`data`, input`result`)\n    ],\n    error: [\n      set(state`error`, input`error`)\n    ]\n  },\n  set(state`isLoading`, false)\n]\n```\n\nThe actions will also have their own folder.\n\n*src/actions/getData.js*\n```js\nfunction getData({axios, path}) {\n  return axios.get('/data')\n    .then(response => path.success({result: response.data}))\n    .catch(error => path.error({error: error.response.data}))\n}\n\nexport default getData\n```\n","title":"Signals"},"tags":{"raw":"# Tags\nTags allows you to target things in Cerebral. They are based on [template literal tags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals). They can be used by **operators**, **connect** and **compute**. Some of them can also be used with other Cerebral modules. The great thing about tags is their composability. For example:\n\n```js\nstate`items.${state`currentItemKey`}`\n\nstate`items.${input`itemKey`}`\n```\n\nThis allows you to express signals and component dependencies a lot more effectively. There are 5 tags in Cerebral.\n\n- **state** - Used in signals and connect to target state\n- **input** - Used in signals to target input\n- **props** - Used in connect to target component props\n- **signal** - Used in signals and connect to target a signal\n- **string** - Used in signals to evaluate a composed string\n","title":"Tags"},"connect":{"raw":"# Connect\n\n## Choosing a view type\nCerebral technically can use any view layer. Currently it officially supports [React](https://facebook.github.io/react/) and [Inferno](http://infernojs.org/). From a Cerebral perspective they have the exact same API, you just have to choose to import from **cerebral/react** or **cerebral/inferno**. For specific API differences of the two view libraries please check their documentation.\n\nChoose React if you want a huge ecosystem of shared components and documentation. Inferno is faster than React and is recommended to be used when you do not depend heavily on 3rd party components.\n\n## Connecting the controller\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Controller} from 'cerebral'\nimport {Container} from 'cerebral/react'\nimport App from './components/App'\n\nconst controller = Controller()\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n## Exposing state\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`\n},\n  function App(props) {\n    props.isLoading\n  }\n)\n```\n\nExpose state based on props passed to component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state, props} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`${props`module`}.isLoading`\n},\n  function App(props) {\n    props.isLoading\n  }\n)\n```\n\n## Exposing signals\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {signal} from 'cerebral/tags'\n\nexport default connect({\n  clicked: signal`app.somethingClicked`\n},\n  function App(props) {\n    props.clicked\n  }\n)\n```\n\nExpose signals based on props passed to component:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {signal, props} from 'cerebral/tags'\n\nexport default connect({\n  clicked: signal`${props.module}.somethingClicked`\n},\n  function App(props) {\n    props.clicked\n  }\n)\n```\n\n## Strict rendering\nDue to Cerebrals \"render on path change\" it is possible to optimize component rendering.\n\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Controller} from 'cerebral'\nimport {Container} from 'cerebral/react'\nimport App from './components/App'\n\nconst controller = Controller({\n  options: {strictRender: true}\n})\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\nNow your components will only render when the exact state path defined changes:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`\n},\n  function App(props) {\n    props.isLoading\n  }\n)\n```\n\nThis component will only render when exactly **app.isLoading** changes. It will not change if there is a change to path: **app** or **app.isLoading.foo**.\n\nWith **strict mode** Cerebral automatically adds interest in child paths on objects and arrays. So for example a component showing a list renders when some nested path has a change:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  list: state`app.list`\n  // Is actually: list: state`app.list.**`\n},\n  function App(props) {\n    props.list\n  }\n)\n```\n\nSometimes you want to optimize as the list is only interested in changes to the keys of an object or items in the array. For example when you have a list of users, you only want to rerender the list itself when keys are added/removed from the map:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  users: state`app.users.*`\n},\n  function App(props) {\n    Object.keys(props.users)\n  }\n)\n```\n\nThere is one **gotchas** with strict mode though:\n\nLets say you point to path **app.isLoading** in a component. If you change out **app** path, the component will not render. This throws an error and tell you to not replace the **app** path or change the component dependency to be **app** instead\n","title":"Connect"},"modules":{"raw":"# Modules\n\nA module is basically an object. Modules helps you structure your state and signals. You can think of them as namespaces for state and signals.\n\n```js\nexport default {\n  // Define module state, namespaced by module path\n  state: {},\n  // Define module signals, namespaced by module path\n  signals: {},\n  // Define submodules, namespaced by module path\n  modules: {}\n}\n```\n\nIt is also possible to define a module using a function.\n\n```js\nexport default (module) => {\n  module.name // Name of module\n  module.path // Full path to module\n  module.controller // The controller the module is attached to\n\n  return {\n    state: {},\n    signals: {},\n    modules: {}\n  }\n}\n```\n\nYou attach a module simply by referencing it:\n\n```js\nimport {Controller} from 'cerebral'\nimport FeedModule from './modules/Feed'\n\nconst controller = Controller({\n  modules: {\n    feed: FeedModule\n  }\n})\n```\n","title":"Modules"},"operators":{"raw":"# Operators\nYou can call operators to create actions for you. These actions will help you change state and control the flow of execution.\n\n## State operators\n\nThe methods for changing state within actions is also available as operators. All state operators support using both **state** and **input** tags as values.\n\nAll operators are imported as members of the 'cerebral/operators' module. For example, this imports **state** and **set**:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n```\n\n### concat\n\nConcatenate a value to an array\n\n```js\nconcat(state`some.list`, ['foo', 'bar'])\n```\n\n### merge\n\nMerge objects into existing value. If no value exists, an empty object will be created. Merge supports using operator tags on key values:\n\n```js\nmerge(state`clients.$draft`, input`newDraft`, {\n  foo: 'bar',\n  bar: input`baz`\n})\n```\n\n### pop\n\nPop a value off an array (removes last element from array).\n\n```js\npop(state`some.list`)\n```\n\n### push\n\nPush value into an array (adds the element at the end of the array).\n\n```js\npush(state`some.list`, 'foo')\n```\n\n### set\n\nSet a target value in the state or input.\n\n```js\nset(state`foo.bar`, true),\nset(input`foo`, true)\n```\n\n### shift\n\nShift a value off an array (removes first element in array).\n\n```js\nshift(state`some.list`),\n```\n\n### splice\n\nSplice an array in place.\n\n```js\nsplice(state`some.list`, 0, 2)\n```\n\n### toggle\n\nToggle a boolean value.\n\n```js\ntoggle(state`user.$toolbar`)\n```\n\n### unset\n\nUnset key from object.\n\n```js\nunset(state`clients.all.${input`key`}`)\n```\n\n### unshift\n\nUnshift a value into an array (adds the element at the start of the array).\n\n```js\nunshift(state`some.list`, 'foo')\n```\n\n## Flow control operators\n\nThese operators help control the execution flow.\n\n### equals\n\nThis operator chooses a specific path based on the provided value.\n\n```js\nimport {equals} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  equals(state`user.role`), {\n    admin: [],\n    user: [],\n    otherwise: [] // When no match\n  }\n],\n```\n\n### debounce\n\nHold action until the given amount of time in milliseconds has passed. If the\nsignal triggers again within this time frame, the previous signal goes down the\n\"discard\" path while the new signal holds for the given time. This is\ntypically used for typeahead functionality. For a debounce that is shared\nacross different signals, you can use `debounce.shared()` (see example below).\n\nPlease note that the `discard` path has to be present even if it is most often\nempty because debounce is a flow operator that routes the flow depending on\ntime and action trigger.\n\n```js\nimport {debounce} 'cerebral/operators'\n\nexport default [\n  debounce(200), {\n    continue: [runThisAction],\n    discard: []\n  },\n]\n```\n\n`debounce.shared()` is typically used with factories, for example to show\nnotifications where a previous notification should be cancelled by a new one.\n\n```js\nimport {debounce, set, unset} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nconst sharedDebounce = debounce.share()\nfunction showNotificationFactory(message, ms) {\n  return [\n    set(state`notification`, message),\n    sharedDebounce(ms), {\n      continue: [unset(state`notification`)],\n      discard: []\n    }\n  ]\n}\n```\n\nNow when this notification factory is used in different signals, the call to\n`debounceShared` will share the same debounce execution state:\n\n```js\nimport showNotification from './showNotification'\n\nexport default [\n  // ... user log in, etc\n  ...showNotification('User logged in', 5000)\n]\n```\n\n### wait\n\nWait for the given time in milliseconds and then continue chain.\n\n```js\nimport {wait} from 'cerebral/operators'\n\nexport default [\n  wait(200),\n  doSomethingAfterWaiting\n]\n```\n\nIf you need to wait while executing in parallel, you should use a `continue`\npath to isolate the actions to be run:\n\n```js\nimport {wait} from 'cerebral/operators'\n\nexport default [\n  [ // this runs in parallel\n    wait(200), {\n      continue: [doSomethingAfterWaiting]\n    },\n    otherActionInParallel\n  ]\n]\n```\n\n### when\n\nRun signal path depending on a truth value or function evaluation.\n\n```js\nimport {when} from 'cerebral/operators'\n\nexport default [\n  when(state`foo.isAwesome`), {\n    true: [],\n    false: []\n  },\n  // You can also pass your own function\n  when(state`foo.isAwesome`, (value) => value.length === 3 ), {\n    true: [],\n    false: []\n  }\n]\n```\n\nWhen used with a truth function, the `when` operator supports more then a single\n\"value\" argument. The truth function must come last.\n\n```js\nimport {when} from 'cerebral/operators'\nimport {input, state} from 'cerebral/tags'\n\nexport default [\n  when(state`clients.$draft.key`, input`key`,\n    (draftKey, updatedKey) => draftKey === updatedKey\n  ), {\n    true: [\n      // Another person edited client, reset form to new value\n      set(state`clients.$draft`, input`value`)\n    ],\n    false: []\n  }\n]\n```\n","title":"Operators"},"providers":{"raw":"# Providers\n\nProviders are functions that runs before any action in any signal. Their purpose is to define and sometimes manipulate the context passed into every action. The providers run before every action, meaning that each action has a unique context object.\n\n## Context provider\nThe context provider allows you to attach any third party library to the context of all actions. Typically:\n\n\n```js\nimport {Controller} from 'cerebral'\nimport {ContextProvider} from 'cerebral/providers'\nimport axios from 'axios'\n\nconst controller = Controller({\n  providers: [\n    ContextProvider({\n      axios\n    })\n  ]\n})\n```\n\nNow axios will be available on the context of any action. The context provider also wraps any methods and sends information to the debugger about their use.\n\nLook at the **community tools** for other providers that can be used, or create your own.\n\n## Creating a provider\n\nAn example of a provider is the built in **InputProvider** of function-tree.\n\nIt looks something like this:\n\n```js\nfunction InputProvider(context, functionDetails, payload) {\n  context.input = payload\n\n  return context\n}\n```\n\nThe providers are called by **function-tree** with some arguments.\n\n- **context** is the current context object that will be passed into the function (action)\n- **functionDetails** gives information about the function (action) that will run\n- **payload** the current payload of the execution (signal)\n\nYou can create a standalone provider simply by defining a function like the **InputProvider** in the first example. But you can also define a provider on a module. This allows you to combine providers and signals.\n\n```js\nexport default (module) => {\n  const MODULE_PATH = module.path.join('.')\n\n  return {\n    state: {\n      foo: true\n    },\n    signals: {\n      somethingHappened: [\n        toggle(state`${MODULE_PATH}.foo`)\n      ]\n    },\n    provider(context) {\n      context.myProvider = {\n        doSomeSideEffect() {\n          someSideEffect().then(() => {\n            module.controller.getSignal(`${MODULE_PATH}.somethingHappened`)()\n          })\n        }\n      }\n\n      return context\n    }\n  }\n}\n```\n\nNow any action can:\n\n```js\nfunction someAction({myProvider}) {\n  myProvider.doSomeSideEffect()\n}\n```\n\nYou should think twice when considering a provider though. Always favor signal composition and actions as those will always end up more readable and better visualized in the debugger. Providers are typically used for general enhancements, not application specific.\n\n## Already on the context\nThere are some things already available on the context.\n\n```js\nfunction MyProvider(context) {\n  context.execution // Information on the function tree execution\n  context.controller // The Cerebral controller\n  context.debugger // If devtools is added, you can send messages to the debugger\n  context.input // Current payload\n  context.path // If any paths are defined after the action to be executed\n\n  return context\n}\n```\n","title":"Providers"},"compute":{"raw":"# Compute\nNormally you use state directly from the state tree, but sometimes you need to compute values. Typically filtering lists, grabbing the projects of a user or other derived state.\n\nCerebral allows you to compute state that can be used in multiple contexts. Let us look at the signature:\n\n```js\nimport {compute} from 'cerebral'\n\nexport default compute(() => {\n  return 'foo'\n})\n```\n\nYou can now use this with **connect**:\n\n```js\nimport computedFoo from '../computedFoo'\n\nconnect({\n  foo: computedFoo\n})\n```\n\nYou can use it with operators in a signal:\n\n```js\nimport computedFoo from '../computedFoo'\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, computedFoo)\n]\n```\n\nOr you can resolve it inside an action if you need to:\n\n```js\nimport computedFoo from '../computedFoo'\n\nfunction myAction ({resolve}) {\n  const foo = resolve.value(computedFoo)\n}\n```\n\nYou can even compose it into a Tag:\n\n```js\nimport computedFoo from '../computedFoo'\nimport {state} from 'cerebral/tags'\n\nstate`${computedFoo}.bar`\n```\n\n## Getting data\nCompute can manually grab data related to where it is run. For example in **connect** you have access to both state and properties of the component. In a signal you would have access to state and the input to the signal. You do this by combining the **get** argument with a related tag:\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default compute((get) => {\n  return get(state`foo`) + get(props`bar`)\n})\n```\n\nCerebral now knows what paths this computed is interested in and can optimize its need to run again to produce a changed value.\n\n## Composing\nWhat makes compute very powerful is its ability to compose tags and other compute. Any tags you pass as arguments will be passed in as a value to the next function in line. The last argument of the function is always the **get** function.\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nconst computedItemUsers = compute(\n  state`items.${props`itemKey`}`),\n  (item, get) => {\n    return item.userIds.map((userId) => get(state`users.${userId}`))\n  }\n)\n\n// In connect\nconnect({\n  users: computedItemUsers\n})\n```\n\nIt uses the *itemKey* property from the component to grab the actual item. Then it grab each user based on the userIds of the item. You can also compose multiple compute together.\n\n```js\nconnect({\n  item: compute(filteredList, onlyAwesome)\n})\n```\n\nHere *filteredList* returns a list of filtered items, where *onlyAwesome* expects to receive a list and filters it again.\n\n```js\ncompute((list) => {\n  return list.filter((item) => item.isAwesome)\n})\n```\n\nIt is possible to combine tags and functions as many times as you would like:\n\n```js\ncompute(\n  state`currentItemKey`,\n  (currentItemKey, get) => {\n    return get(state`item.${currentItemKey}`)\n  },\n  state`isAwesome`,\n  (item, isAwesome) => {\n    return item.isAwesome === isAwesome\n  }\n)\n```\n\nTypically you get away with most things using Tags, but compute will help you with any other scenario where more \"umph\" is needed.\n","title":"Compute"},"router":{"raw":"# Router\n\n## Install\n`npm install cerebral-router@next --save`\n\n## Instantiate\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst controller = Controller({\n  router: Router({\n    routes: {}, // Route definitions\n    query: false, // Query support\n    onlyHash: false, // Use hash urls\n    baseUrl: '/' // Only handle url changes on nested path\n  })\n})\n```\n\n## Define routes\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst controller = Controller({\n  router: Router({\n    routes: {\n      '/': 'home.routed',\n      '/posts': 'posts.routed'\n    }\n  })\n})\n```\n\n## Dynamic routes\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst controller = Controller({\n  router: Router({\n    routes: {\n      '/': 'home.routed',\n      '/posts': 'posts.routed',\n      '/posts/:id': 'posts.post.routed'\n    }\n  })\n})\n```\n\n## Nested routes\n```js\nimport {Controller} from 'cerebral'\nimport Router from 'cerebral-router'\n\nconst controller = Controller({\n  router: Router({\n    routes: {\n      '/': 'home.routed',\n      '/posts': {\n        '/': 'posts.routed',\n        '/:id': 'posts.post.routed'\n      }\n    }\n  })\n})\n```\n","title":"Router"}}}