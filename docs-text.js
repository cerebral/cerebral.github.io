{"introduction":{"index":{"raw":"# The architecture\n\n## Vision\nThe architecture of Cerebral is driven by the goal to give you insight. The single state tree and the way state is connected to the components all support this vision. Creating a Cerebral application allows you and your team members to never question what actually happens when a page loads, a specific button is clicked, etc. Decoupling of state, components and state updates also makes it an overall better experience when scaling up an application as the components will be just a dumb layer that transforms a given state to a user interface.\n\nThe Cerebral debugger is what gives you this insight and answers your questions on what state changes and side effects has been run in any given situation. It is a powerful tool that makes it easier to reason about the application and increases productivity in planning out logic and implementation.\n\nCerebral is based on the simple concept of three things your application does in order to function. **Store state**, **render state** and **update state**.\n\n## Store state\nWhere to store the state of an application is a highly debated subject. Should we allow the components to store state? Should we have multiple models? Stores? Reducers? Services? There are many concepts that can store state. In Cerebral you store all your state in \"a single state tree\". That means you do not create classes or other abstractions around state, it is all basically one big object of plain JavaScript types. Objects, arrays, strings, numbers and booleans:\n\n```js\n{\n  auth: {\n    isLoggedIn: false,\n    user: {\n      prefs: {\n        style: 'light'\n      },\n      friends: [],\n      info: {\n        email: '',\n        name: ''\n      }\n    }\n  },\n  posts: {\n    list: [],\n    selectedPostIndex: 0\n  }\n}\n```\n\nWith this approach we get some benefits not possible with other approaches.\n\n1. **Simple and consistent API** - Typically a state update changes a value, pushes an item in a list or merges an object into another. With a single state tree we can create an API that does exactly that:\n```js\nstate.set('auth.user.prefs.style', 'dark')\nstate.push('auth.user.friends', 'Joe')\nstate.merge('auth.user.info', {\n    email: 'cheetah@jungle.com',\n    name: 'Cheetah'\n})\n```\nWith a single state tree we can point to parts of the state using paths (the first argument). We use dot notation to point to nested paths, like **auth.user.name**.\n\n2. **Optimized rendering** - Cerebral does not look at the updates in your application as \"value updates\", but as \"path updates\". This allows Cerebral to make optimizations not possible in other frameworks:\n\n  1. There is no need for immutability in Cerebral because a change to a path means that any component depending on that path should render (no value comparison). In applications with large data structures immutability has a high cost. There is no need to hack objects and arrays to observe changes to them either. There is nothing special about the state you put into Cerebrals state tree\n\n  2. Since there is no value comparison in Cerebral it uses what we call **strict render**. This allows us to do render optimizations not possible with other solutions. For example you can say that a component depending on a list is only interested in added/removed items of the list or if the list itself is being replaced\n\n3. **Visualize the entire app state** - When the state of the application is a single object we can use an object inspector to visualize the whole state of your application. With the Cerebral debugger it is easy to build a mental image of application state. You can even make changes directly to state to see how it affects the view layer.\n\n\n## Render state\nSince Cerebral stores all the state of the application in a single state tree we need a way to expose that state to the components. In some frameworks this is done by passing the whole model or collection of models/stores from the top of the application and down from one component to the next. This can become very tedious and fragile as all nested components completely depend on their parent. In Cerebral the state of the application is directly connected to each component, here shown with **React**:\n\n```js\nconnect({\n  userName: state`auth.user.info.name`\n},\n  function User(props) {\n    props.userName // \"some name\" (value stored in 'app.user.name')\n  }\n)\n```\n\n**connect** tells Cerebral that the component is interested in a path where the user name happens to be. When that path changes the component will render. The component is now completely independent of other components. You can move it wherever you want in the component tree and it will still work.\n\n## Update state\nThis is where Cerebral differs most from other approaches to application development. Updating the state of an application can be anything from:\n\n- flipping a **true** to a **false**\n- setting some value, like a filter\n- reading (and storing) something in local storage\n- requesting data from the server and, depending on the status code of the response, do something with that response which might lead to new requests and/or setting up a listener for data on the server\n- etc...\n\nThe point is, updating state can be a very complex flow of operations. This is often where spaghetti code comes from and we use abstractions to hide it. The problem with abstractions hiding too much logic is that it becomes rigid, making it difficult to reuse logic and compose existing logic together in new ways.\n\nTo handle everything from a simple toggle to very complex operations, Cerebral has the concept of **signals**. Signals allows you to compose functions together into a flow. You can define different execution paths based on whatever you want (a status code, an error, some state, etc). This allows you to write decoupled code, while still bringing everything together in the form of a higher abstraction which helps understanding how things relate to one another (in what order they will run, when they will run, etc). Under the hood, signals are based on [function-tree](https://github.com/cerebral/cerebral/tree/master/packages/node_modules/function-tree), a project that came out of the initial experimentations in the first version of Cerebral.\n","title":"The architecture"},"install":{"raw":"# Install\nTo install Cerebral you need to use the Node Package Manager. NPM is part of [Node](https://nodejs.org/en/), so please install that on your computer first. You should install Node version 5 or later.\n\nInstall from command line:\n\n`npm install cerebral`\n\n## Boilerplate\n\nYou can download or just play around with any of the following boilerplates from [Webpackbin](https://www.webpackbin.com). The boilerplate is built on [Webpack](https://webpack.js.org/). Read more about how the different view layers work in [API - components](/docs/api/components).\n\n- [React](https://www.webpackbin.com/bins/-KpZ2QJ22vGMpreMX75e)\n- [Inferno](https://www.webpackbin.com/bins/-KpaFIS9qaVx8AaM4QnR)\n- [Preact](https://www.webpackbin.com/bins/-KpaITQjPX6lRCbXA-cz)\n- [Angularjs](https://www.webpackbin.com/bins/-KpaJEt3kH9B-p5g56hB)\n- [Vue](https://www.webpackbin.com/bins/-KpeDRif_7aNlOXrxSK4)\n","title":"Install"},"debugger":{"raw":"# Debugger\n\nCerebral has a powerful development tool. It knows about all the state in your application, all the state updates, side effects run, state paths currently active in your components and when they render. All the things Cerebral helps you with, it visualizes in the debugger.\n\nBecause Cerebral can run on different environments and you might want to manage multiple apps, the debugger is a standalone application. This also opens up for further helpful tools beyond just debugging. It is an [Electron](https://electron.atom.io/) application that connects to your application through websockets. You can add multiple apps to it and if you are using function-tree on the server you can even merge execution data on client and the server.\n\n## Install\n[Download the Debugger](https://github.com/cerebral/cerebral-debugger/releases) for your target OS: Mac, Windows or Linux. The debugger will automatically notify you and self-update.\n\n## Signals\nThe signals tab in the debugger gives you a chronological list of signals triggered. Every signal tells you what actions were run, what mutations were run related to the action and what other side effects like HTTP and Firebase was triggered. You will also see how your signals are composed together in different action groups, parallel execution.\n\n![signals](/images/signals.png)\n\n## Mutations\nThe mutations tab gives you a chronological list of mutations performed. Since signals can be asynchronous, mutations might happen cross signals. In this list you can double click a mutation to time travel to that point in time.\n\n![mutations](/images/mutations.png)\n\n## Components\nThe components tab gives you a list of all currently connected components in your app and what state dependencies they have. You also have a list of latest renders. This list contains what paths changed and what components was affected by the change.\n\n![components](/images/components.png)\n\n## State tree\nThe state tree tab gives you complete overview of the state of your application. You can explore it and make changes to the state directly to see how it affects your application.\n\n![state tree](/images/state_tree.png)\n\n## Initialize\nYou initialize the devtools by adding it to the controller.\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\n// You do not want to load or run the devtools in production as it\n// requires a bit of processing and memory to send data from\n// your application\nconst Devtools = (\n  process.env.NODE_ENV === 'production' ?\n    null\n  :\n    require('cerebral/devtools').default\n)\n\nconst controller = Controller({\n  devtools: Devtools && Devtools({\n    // If running standalone debugger. Some environments\n    // might require 127.0.0.1 or computer IP address\n    host: 'localhost:8585',\n\n    // By default the devtools tries to reconnect\n    // to debugger when it can not be reached, but\n    // you can turn it off\n    reconnect: true\n  })\n})\n\nexport default controller\n```\n","title":"Debugger"},"state":{"raw":"# State\n\nCerebral uses a single state tree to store all the state of your application. It is just a single object:\n\n```js\n{}\n```\n\nThat's it.\n\nYou will normally store other objects, arrays, strings, booleans and numbers in it. Forcing you to think of your state in this simple form gives us benefits.\n\n1. The state of the application is exposed as simple values. There are no classes or other abstractions hiding the state of your application\n2. The state can be stored on the server, local storage and passed to the debugger. It is what we call **serializable** state\n3. All the state of your application can be inspected through one object\n4. All state is related to a path. There is no need to import and/or pass around model instances into other model instances to access state\n\nTo define the initial state of any application all we need to do is to add it to our **Controller** in *controller.js*\n\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {\n    title: 'Cerebral Tutorial'\n  }\n})\n\nexport default controller\n```\n\nLater you will learn about **modules** which allows you to encapsulate state with other logic.\n\nIf you want to see this in action, install the debugger and [load this BIN on Webpackbin](https://www.webpackbin.com/bins/-KpZ7xmFJK6WD44uAoUx).\n","title":"State"},"signals":{"raw":"# Signals\n\nYou trigger a signal when something happens in your application. For example a button is clicked, but also if a websocket connection receives a message. The signal runs the business logic of your application. You compose together state changes, side effects and other logic in one coherent flow.\n\nThis is an example of a signal added to the root of the controller:\n\n```js\nimport {Controller} from 'controller'\nimport someAction from './actions/someAction'\n\nconst controller = Controller({\n  signals: {\n    somethingHappened: [\n      someAction\n    ]\n  }\n})\n\n// Typically you do not extract signals directly like\n// this, but it shows you that a signal is just a function\n// you call\nconst signal = controller.getSignal('somethingHappened')\nsignal()\n```\n\nYou will learn later how you can use **modules** to encapsulate signals with state.\n\nCerebral uses the [function-tree](https://github.com/cerebral/function-tree) project to implement its signals. A function-tree allows you to define a tree of functions to be executed. In Cerebral world we call the functions in this tree **actions**.\n\n## Operators\n\nAlthough you will need to create actions in your application, most of your logic can be expressed using what we call operators. Instead of referencing a function to run, you rather call a function that returns a function. This is what we generally in programming call function factories and you will use them a lot. The included function factories in Cerebral are called **operators**. They typically make state changes, but can also control execution flow and even time.\n\nThe most common operators you will use changes the state of your application.\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, 'bar')\n]\n```\n\nWith the help of [tagged template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals) we are able to express that we want to set the state path **foo** to have the value **\"bar\"**.\n\nAnd this is how you go about using operators:\n\n```js\nimport {merge, push, pop} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  merge(state`some.object`, {foo: 'bar'}),\n  push(state`some.list`, 'foo'),\n  pop(state`some.otherList`)\n]\n```\n\n[Open this BIN](https://www.webpackbin.com/bins/-KpZAMSt49LlQHNhguls) to play around with some operators. Please feel free to use the same bin to test out the concepts reading on.\n\n## Paths\nIt is possible to diverge execution down specific paths. For example some included operators requires you to define paths:\n\n```js\nimport {when, equals} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  when(state`app.isAwesome`), {\n    true: [],\n    false: []\n  },\n  equals(state`user.role`), {\n    admin: [],\n    user: [],\n    otherwise: []\n  }\n]\n```\n\nWhen you build custom actions you can also define your own paths of execution.\n\n## Props\n\nWhen a signal is executed props can be passed into it. That means every action in the defined signal has access to these props. For example we trigger a signal:\n\n```js\nsomeSignal({\n  foo: 'bar'\n})\n```\n\nNow the whole flow of execution has access to **props.foo**. With operators and also inside your custom actions you have access to these props.\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, props`foo`)\n]\n```\n\n## Actions\n\nAn action is just a function. What makes an action different from a normal function though is that it receives only one argument, created by Cerebral. It is called the **context**. Actions are \"low level\" and imperative. There is no declarative code without some imperative code behind it. In Cerebral most of the imperative action code is already written for you, but sometimes you need to write custom logic. That is when you write your own action.\n\n```js\nfunction iAmAnAction (context) {\n\n}\n```\n\nWhatever side effect you need to run, even a state change, you do it from the context. It means you do not need any API to define an action or import any other modules to define business logic. This makes actions highly testable and easy to write.\n\nHere is an example of an action changing the state of the application:\n\n```js\nfunction iAmAnAction ({state}) {\n  state.set('foo', 'bar')\n}\n```\n\nOr using props:\n\n```js\nfunction iAmAnAction ({state, props}) {\n  state.set('foo', props.foo)\n}\n```\n\n### Update props\nYou update the props on the signal by returning an object from the action. This object will be merged with existing props.\n\n```js\nfunction iAmAnAction () {\n  return {\n    newProp: 'someValue'\n  }\n}\n```\n\n### Async\nWhen actions return a promise the signal will hold execution until it is resolved. any resolved values will be merged in with props.\n\n```js\nfunction iAmAnAction () {\n  return new Promise((resolve) => {\n    resolve({\n      newProp: 'someValue'\n    })\n  })\n}\n```\n\n### Paths\nIf an action is defined with paths in a signal, these paths will be available in the action.\n\n```js\n[\n  isAwesome, {\n    true: [],\n    false: []\n  }\n]\n```\n\nSince this action is followed by a paths definition, you have access to these paths inside the **isAwesome** action.\n\n```js\nfunction isAwesome ({state, path}) {\n  if (state.get('isAwesome')) {\n    return path.true()\n  }\n\n  return path.false()\n}\n```\n\nYou now call the path as defined, and you can optionally pass it an object which will be merged with the current props. Make sure you **return** the path from the action!\n\n## Parallel execution\nYou can run actions in parallel. You do that by using the **parallel** function:\n\n```js\nimport {parallel} from 'cerebral'\n\nfunction actionA () {...}\nfunction actionB () {...}\nfunction actionC () {...}\n\nexport default [\n  parallel([\n    actionA,\n    actionB\n  ]),\n  actionC\n]\n```\n\nIf *actionA* returns a promise *actionB* will still be run instantly, meaning that they run in parallel. When both *actionA* and *actionB* is done, *actionC* is run.\n\n## Composing\nActions and a sequence of actions can be composed into other sequences of actions. This is a powerful concept that allows you to decouple a lot of your logic and compose it together wherever it is needed:\n\n```js\nimport otherActions from './otherActions'\n\nfunction actionA () {}\nfunction actionB () {}\n\nexport default [\n  actionA,\n  otherActions, // [actionC, actionD, actionE]\n  actionB\n]\n```\n\nCerebral will now run this as one signal, first running *actionA*, then whatever is expressed in *otherActions* and then run *actionB* last. The debugger will even show otherActions as its own sequence of actions, meaning that composition is visualized in the debugger. If you want you could even name this otherActions sequence, giving even more debugging information.\n\n*otherActions.js*\n```js\nimport {sequence} from 'cerebral'\n\nfunction actionC () {}\nfunction actionD () {}\nfunction actionE () {}\n\nexport default sequence('otherActions', [\n  actionC,\n  actionD,\n  actionE\n])\n```\n","title":"Signals"},"providers":{"raw":"# Providers\n\nProviders are added to the context of every action executed by a signal. Providers can be everything from a tool you are already using, to something Cerebral specific. **The point of providers is to separate side effects from execution**. That means you can create all the logic you want in actions without creating any dependencies to other tools. This makes them highly testable and generally gives you more flexibility.\n\n## The default providers\nCerebral has a set of default providers:\n\n- **props** - The data passed into execution and/or returned from actions\n- **state** - The API that changes the state of your application\n- **controller** - Access to the controller instance inside an action\n- **resolve** - Ability to resolve tags and computed inside actions\n\nAll these can be accessed inside an action:\n\n```js\nfunction someAction ({props, state, controller, resolve}) {}\n```\n\nThe [devtools](/introduction/devtools) also adds its own provider called **debugger**.\n\n## Adding a provider\nIf you are using libraries where you want access to everything they provide you can simply add them as a provider using an object:\n\n```js\nimport {Controller, provide} from 'cerebral'\nimport axios from 'axios'\nimport uuid from 'uuid'\n\nconst controller = Controller({\n  providers: [\n    provide('http', axios),\n    provide('id', uuid.v4)\n  ]\n})\n```\n\nNote that some tools has a very complex API that is difficult for Cerebral to analyze. With these kinds of tools it is a better idea to create your own provider, exposing APIs that you actually use from the original tool.\n\n## Creating a provider\nYou can use providers for pretty much anything, though typically it is to handle some kind of side effect. Examples of providers is [@cerebral/storage](https://github.com/cerebral/cerebral/tree/master/packages/storage), [@cerebral/firebase](https://github.com/cerebral/cerebral/tree/master/packages/firebase) and [@cerebral/http](https://github.com/cerebral/cerebral/tree/master/packages/http).\n\nTo use a provider with Cerebral you put it in the providers array:\n\n```js\nconst controller = Controller({\n  providers: [\n    StorageProvider(),\n    HttpProvider(),\n    FirebaseProvider()\n  ]\n})\n```\n\nThe **provide** factory helps you add your own providers in a simple way:\n\n```js\nimport {Controller, provide} from 'cerebral'\n\nconst controller = Controller({\n  providers: [\n    provide('someProvider', {\n      returnFoo() {\n        return 'foo'\n      }\n    })\n  ]\n})\n```\n\nWhen using the **provide** factory the provider will automatically be wrapped by the Cerebral devtools, to track its usage in the debugger.\n\nNow this provider is available to any action:\n\n```js\nfunction myAction ({someProvider}) {\n  someProvider.returnFoo() // \"foo\"\n}\n```\n\nPlay around with creating a provider on [this BIN](https://www.webpackbin.com/bins/-KpZNE-A-_O7hjIGqVnL).\n\nAs mentioned above we use providers to separate side effects from execution, allowing us to provide our own custom API to our application. The **provide** factory simplifies adding a provider, but you can get more control by defining your own provider function. [Look at the API docs for more information](/docs/api/providers).\n","title":"Providers"},"modules":{"raw":"# Modules\n\nAs your application grows it is a good idea to organize the logic, not just in files, but also in code. The Cerebral modules can be looked at as namespaces for logic. While they do encapsulate, they do not isolate. That means any module can change the state of any other module.\n\nA module is just an object where you will mostly use the **state** and **signals** property.\n\n```js\nimport somethingHappened from './signals/somethingHappened'\n\nexport default {\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    somethingHappened\n  }\n}\n```\n\nTo actually use the module you attach it to the controller:\n\n```js\nimport {Controller} from 'cerebral'\nimport app from './modules/app'\n\nconst controller = Controller({\n  modules: { app }\n})\n```\n\nThere is really nothing more to it. Now the state is namespaced by **app.foo**, the same goes for the signal **app.somethingHappened**.\n\nYou can also define your module as a function, returning a module definition. This function will receive the **name** of the module, the **path** to it and also the **controller** instance.\n\n```js\nexport default ({name, path, controller}) => {\n  return {\n    state: {},\n    signals: {}\n  }\n}\n```\n\nThis information can be useful in more complex setups where your module wants to listen for the *initialized* event of the controller for example.\n\n## Submodules\nA module can also use a **modules** property to attach nested modules.\n\n```js\nimport foo from './modules/foo'\n\nexport default {\n  state: {},\n  signals: {},\n  modules: {\n    foo\n  }\n}\n```\n\n## Provider\nA module can attach a provider to the controller by using the **provider** property.\n\n```js\nimport {provide} from 'cerebral'\n\nexport default {\n  state: {},\n  signals: {},\n  providers: provide('whatevah', {\n    foo() {},\n    bar() {}\n  })\n}\n```\n\nTo play around with modules [have a look at this BIN](https://www.webpackbin.com/bins/-Kp_1KYmZOBjswsaTUAC).\n","title":"Modules"},"errors":{"raw":"# Errors\n\nHandling complex asynchronous flows is a challenging task for error handling. If things are not done correctly errors can be swallowed and you will have a hard time figuring out why your application does not work.\n\nError handling in Cerebral signals are done for you. Wherever you throw an error, it will be caught correctly and thrown to the console unless you have explicitly said you want to handle it. And even when you do explicitly handle it Cerebral will still show the error in the debugger as a **caught** error, meaning you can never go wrong. The action in question is highlighted red, you will see the error message, the code related and even what executed related to you catching the error.\n\n![debugger error](/images/debugger_error.png)\n\n## Catching errors\nTo catch an error from a signal you can define it with the signal definition:\n\n*someModule.js*\n```js\nexport default {\n  state: {},\n  signals: {\n    // Define the signal as an object\n    somethingHappened: {\n      signal: someSequence,\n      catch: new Map([\n        [FirebaseProviderError, someErrorHandlingSequence]\n      ])\n    }\n  }\n}\n```\n\nIf you are not familiar with the **Map** JavaScript API, [you can read more here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map). We basically tell the signal that we are interested in any errors thrown by the Firebase Provider. Then we point to the sequence of actions we want to handle it. An error will be passed in to the sequence of actions handling the error:\n\n```js\n{\n  foo: 'bar', // already on payload\n  error: {\n    name: 'FirebaseProviderError',\n    message: 'Could not connect',\n    stack: '...'\n  }\n}\n```\n\n## Catching globally\nIn most applications error handling can be handled at a global level. That means you define your signals as normal and you rather define catch handlers on the controller itself:\n\n```js\nimport {Controller} from 'cerebral'\nimport {\n  FirebaseProviderAuthenticationError,\n  FirebaseProviderError\n} from '@cerebral/firebase'\nimport {\n  HttpProviderError\n} from '@cerebral/http'\n\nconst controller = Controller({\n  modules: {},\n  catch: new Map([\n    [FirebaseProviderAuthenticationError, someErrorSequence]\n    [FirebaseProviderError, someErrorSequence],\n    [HttpProviderError, someErrorSequence]\n  ])\n})\n```\n\n## Creating an error type\nJavaScript has a base error class of **Error**. When you create your own error types it makes sense to extend **Error**. This is only recently supported in browsers, but you can use [es6-error](https://www.npmjs.com/package/es6-error) to make sure extending errors works correctly.\n\n```js\nimport ES6Error from 'es6-error'\n\nclass AppError extends ES6Error {\n  constructor(message) {\n    super(message)\n    this.name = 'AppError'\n  }\n}\n```\n\nThis allows you to create more specific errors by subclassing:\n\n```js\nclass AuthError extends AppError {\n  constructor(message, code) {\n    super(message)\n\n    this.name = 'AuthError'\n    this.code = code\n  }\n  // By adding a custom \"toJSON\" method you decide\n  // how the error will be shown when passed to the\n  // debugger and your catch handler\n  toJSON () {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      stack: this.stack\n    }\n  }\n}\n```\n\nTo play around with modules [have a look at this BIN](https://www.webpackbin.com/bins/-Kp_358GlWxIbpMRTWm1).\n","title":"Errors"},"components":{"raw":"# Components\n\nIn Cerebral you connect state to components where you need it. This give some benefits:\n\n1. Cerebral will optimize the component\n2. The debugger will know about this component and visualize its state dependencies and when it renders\n3. Increased readability as every component explicitly tells you what state and signals it needs and where it gets it from\n4. You can safely move the component wherever you want without breaking chain of props passing\n\nCerebral supports numerous view layers. They conceptually work the same way, but has different implementation details. Choose the view layer that makes sense to you and your team. We will move on using **React**, but have a look at the API section to find more out about **Inferno**, **AngularJS**, **Preact** and **Vue**.\n\nWhen you render your application you use the **Container** component to expose the controller to the rest of your components...\n\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from '@cerebral/react'\nimport controller from './controller'\nimport App from './App'\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\nWhen you connect a component like this...\n\n```js\nimport React from 'react'\nimport {connect} from '@cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  title: state`title`\n},\n  function MyComponent ({title}) {\n    return (\n      <div>\n        <h1>{title}</h1>\n      </div>\n    )\n  }\n)\n```\n\n...the component will be registered to Cerebral. Cerebral actually has a register of all *connected* components in your application. This information is passed to the debugger and whenever Cerebral flushes out changes made to different state paths, it will know what components should render.\n\nAll connected components are automatically optimized, meaning that they will only render if a parent component passes a changed prop or Cerebral explicitly tells it to render.\n\nTo get more in-depth information about **connect**, please visit the [API chapter](http://cerebraljs.com/docs/api/components.html).\n","title":"Components"},"compute":{"raw":"# Compute\nNormally you use state directly from the state tree, but sometimes you need to compute values. Typically filtering lists, grabbing the projects of a user, or other derived state. It is a good idea not to put this kind of logic inside your view layer, cause by creating a computed you can reuse the logic anywhere.\n\nCerebral allows you to compute state that can be used in multiple contexts. Let us look at the signature:\n\n```js\nimport {compute} from 'cerebral'\n\nexport default compute(() => {\n  return 'foo'\n})\n```\n\nYou can now use this with **connect**:\n\n```js\nimport computedFoo from '../computedFoo'\n\nconnect({\n  foo: computedFoo\n})\n```\n\nYou can use it with operators in a signal:\n\n```js\nimport computedFoo from '../computedFoo'\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  set(state`foo`, computedFoo)\n]\n```\n\nOr you can resolve it inside an action if you need to:\n\n```js\nimport computedFoo from '../computedFoo'\n\nfunction myAction ({resolve}) {\n  const foo = resolve.value(computedFoo)\n}\n```\n\nYou can even compose it into a Tag:\n\n```js\nimport computedFoo from '../computedFoo'\nimport {state} from 'cerebral/tags'\nimport {set} from 'cerebral/operators'\n\nexport default [\n  set(state`${computedFoo}.bar`, 'baz')\n]\n```\n\nThe compute signature is very flexible. It allows you to put in any number of arguments which will be evaluated. For example here we go an grab some state and props, before using their values to produce a new value.\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default compute(state`foo`, props`bar`, (foo, bar) => {\n  return foo + bar\n})\n```\n\nWe can even keep adding arguments and produce yet another value:\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default compute(\n  state`foo`,\n  props`bar`,\n  (foo, bar) => {\n    return foo + bar\n  },\n  state`baz`,\n  (computedFooBar, baz) => {\n    return computedFooBar + baz\n  }\n)\n```\n\nThat means you can compose computeds, lets try by splitting them up into two:\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nconst fooBar = compute(\n  state`foo`,\n  props`bar`,\n  (foo, bar) => {\n    return foo + bar\n  }\n)\n\nconst fooBarBaz = compute(\n  state`baz`,\n  (computedFooBar, baz) => {\n    return computedFooBar + baz\n  }\n)\n\nexport default compute(fooBar, fooBarBaz)\n```\n\nThere is one last thing to computeds and that is the **get** argument, which is always the last argument passed into the callback of a computed. This argument can be used to manually extract state and props, very useful to optimize computed lists.\n\nFor example we have items with an array of user ids. We create a computed taking in **itemKey** as a prop, extracts the item and then iterates the userIds to grab the actual users.\n\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nconst computedItemUsers = compute(\n  state`items.${props`itemKey`}`,\n  (item, get) => {\n    return item.userIds.map((userId) => get(state`users.${userId}`))\n  }\n)\n\n// In connect\nconnect({\n  users: computedItemUsers\n})\n```\n\nIt uses the *itemKey* property from the component to grab the actual item. It then grabs each user based on the userIds of the item. Then we could add additional computed to only get certain users.\n\n```js\nconnect({\n  item: compute(filteredList, onlyAwesome)\n})\n```\n\nTypically you can get away with most things using Tags, but compute will help you with any other scenarios where more \"umph\" is needed.\n","title":"Compute"},"test":{"raw":"# Test\n\nCerebral makes it easy to test your application components and business logic.\n\n## CerebralTest\n\nThe `CerebralTest` factory returns runSignal, setState and getState functions that can be called many times without resetting the controller in between.\n\n```js\nconst test = CerebralTest(fixture, options)\ntest.setState(path, value)\ntest.runSignal(signal, props).then((result) => {})\nconst value = test.getState(path)\n```\n\n```js\nimport {CerebralTest} from 'cerebral/test'\n\nit('should accumulate a count', () => {\n  const test = CerebralTest({\n    modules: {\n      math: math()\n    }\n  })\n  test.setState('math.count', 0)\n\n  return test.runSignal('math.plusOne')\n    .then(({state}) => assert.equal(state.math.count, 1))\n    .then(() => test.runSignal('math.plusTwo'))\n    .then(({state}) => assert.equal(state.math.count, 3))\n  })\n})\n```\n\n## Signals\n\nThe `runSignal` test helper accepts the `signal` (chain of actions or signal name) and `fixture` arguments and returns a promise. `runSignal` is designed to be called one time.\n\n```js\nrunSignal(signal, fixture, options).then((result) => {})\n```\n\nThe optional `fixture` argument should be an object that contains any of the following:\n\n```js\n{\n  state: {}, // test state\n  props: {}, // props passed to the signal\n  // any other options that can be passed to the\n  // cerebral controller, including signals, modules, router, providers...\n}\n```\n\n```js\nimport {runSignal} from 'cerebral/test'\n\n// the buttonClicked signal has two actions: validateForm and updateIsValid\nimport buttonClicked from './buttonClick'\n\nit('should handle button clicks', () => {\n  const fixture = {\n    state: { isValid: false },\n    props: { buttonName: 'submit' }\n  }\n  return runSignal(buttonClicked, fixture, {recordActions: 'byName'})\n    .then(({validateForm, updateIsValid, state}) => {\n      assert.equal(validateForm.props.buttonName, 'submit')\n      assert.equal(updateIsValid.props.isValid, true)\n      assert.equal(state.isValid, true)\n    })\n})\n```\n\nIf the first argument is passed as a string, then the signal must be defined within the fixtures.\n\nThe optional `options` argument contain the the following options:\n\n`recordActions: true|false|'byName'`\n\nWhen `recordActions: true` is specified each action will record its props/output against its index within the signal action chain. When `recordActions: 'byName'` is specified each action will record its output against an named property in the result.\n\nThe `result` object passed when the promise resolves contains `state`, `controller` and an object for each named action in the signal chain with the same name as the actions with `props` and `output` properties.\n\n```js\n{\n  state,\n  controller,\n  '2': {\n    props: {\n      // props data\n    },\n    output: {\n      // action output data\n    }\n  },\n  '1': {\n    props: {\n      // props data\n    },\n    output: {\n      // action output data\n    }\n  }\n}\n```\n\n\n## Actions\n\nThe `runAction` test helper accepts the `action` and `fixture` arguments and returns a promise.\n\n```js\nrunAction(action, fixture).then((result) => {})\n```\n\nThe optional `fixture` argument should be an object that contains any of the following:\n\n```js\n{\n  state: {}, // test state\n  props: {}, // props passed to the action\n  // any other options that can be passed to the\n  // cerebral controller, including router, providers etc.\n}\n```\n\n```js\nimport {state} from 'cerebral/tags'\nimport {runAction} from 'cerebral/test'\n\nimport Increment from './Increment'\n\nit('should increment numbers in state', () => {\n  const increment = Increment(state`number`)\n\n  return runAction(increment, { state: { number: 1 } })\n    .then(({state}) => assert.equal(state.number, 2))\n})\n```\n\nThe `result` object passed when the promise resolves contains `state`, `controller`, `props` and `output` properties.\n\n```js\n{\n  state,\n  controller,\n  props: {\n    // props data received by action\n  },\n  output: {\n    // action output data\n  }\n}\n```\n\n## Computed\n\nThe `runCompute` test helper accepts the `compute` and `fixtures` arguments and returns the compute output.\n\n```js\nvar result = runCompute(compute, state)\n```\n\nThe optional `fixture` argument should be an object that contains any of the following:\n\n```js\n{\n  state: {}, // test state\n  props: {}  // props passed to the computed\n}\n```\n\n```js\nimport {props, state} from 'cerebral/tags'\nimport {runCompute} from 'cerebral/test'\n\nimport Multiply from './Multiply'\n\nit('should multiply by the specified number', () => {\n  const multiply = Multiply(state`number`, props`number`)\n  const result = runCompute(multiply, {\n    state: { number: 5 },\n    props: { number: 2 }\n  })\n  assert.equal(result, 10)\n})\n```\n\n## Components\nThe **Container** you use to expose Cerebral to your components can also be used when testing, but you can also use the **StateContainer** which allows you to pass state down to your components as if it was extracted from the Cerebral controller.\n\n```js\nimport React from 'react'\nimport {mount} from 'enzyme'\nimport {StateContainer} from 'cerebral/react'\n\nimport Foo from './Foo'\n\ndescribe('<Foo />', () => {\n  it('allows us to set props', () => {\n    const state = {\n      foo: 'bar'\n    }\n    const wrapper = mount(\n      <StateContainer state={state}>\n        <Foo />\n      </StateContainer>\n    )\n    expect(wrapper.find('.foo')).to.have.length(1)\n  })\n})\n```\n","title":"Test"}},"api":{"index":{"raw":"# Action\n\nWhen actions run they are passed a context. This context is created by Cerebral for every action run.\n\n```js\nfunction iAmAnAction (context) {}\n```\n\nThe context is populated by Cerebral and you can configure this by creating **providers**. By default Cerebral adds the following providers on the context.\n\n## Props\n\nWhen you trigger a signal you can pass it a payload. This payload is the starting point of the props to the signal. Given the signal:\n\n```js\n[\n  actionA,\n  actionB\n]\n```\n\n```js\nsomeSignal({\n  foo: 'bar'\n})\n```\n\nThe first action will receive the payload passed into the signal.\n\n```js\nfunction actionA ({props}) {\n  props // {foo: \"bar\"}\n\n  return {\n    bar: 'baz'\n  }\n}\n```\n\nBy returning a new object the next action will see an extended payload:\n\n```js\nfunction actionB ({props}) {\n  props // {foo: \"bar\", bar: \"baz\"}\n}\n```\n\nSo returning an object from actions, either directly or from a promise, extends the payload for later actions to handle.\n\n## State\nTo change the state of your application you use the state API. It is available to every action.\n\n```js\nfunction setSomething ({state}) {\n  state.set('some.path.foo', 'bar')\n}\n```\n\nAll common state operations are available as a method. Instead of first pointing to a value and then operate, you operate first and give the path to the value.\n\n```js\n// Traditional approach\nsomeArray.push('newItem')\n// With Cerebral\nstate.push('path.to.array', 'newItem')\n```\n\nThis is the one core concept of Cerebral that gives all its power. This simple approach allows for a few important things:\n\n1. Track mutations in the application so that it can be passed to the debugger\n2. Track mutations so that it can inform components depending on the changes\n3. Only allow mutations through the API, and nowhere else in the application (using freezing during development)\n\n## Path\nThe path on the context is only available if there is actually expressed a path after the action in question:\n\n```js\nimport actionA from '../actions/actionA'\nimport actionB from '../actions/actionB'\nimport actionC from '../actions/actionC'\n\nexport default [\n  actionA,\n  actionB, {\n    foo: [actionC]\n  }\n]\n```\n\nIn this scenario only *actionB* has the path on its context. As explained in **Chains and paths**, the path allows you to diverge execution of the signal.\n\n## Resolve\nWhen you ramp up your game with Cerebral you will most certainly take more advantage of **tags** and **computed** in your actions, typically related to action factories. To resolve an argument passed to a factory you can use resolve:\n\n```js\nfunction someActionFactory(someArgument) {\n  function someAction ({resolve}) {\n    // The argument can be anything, even plain values\n    const value = resolve.value(someArgument)\n  }\n\n  return someAction\n}\n```\n\nYou can also use resolve to check the value type and extract for example the path of tags:\n\n```js\nfunction someActionFactory(someArgument) {\n  function someAction ({resolve}) {\n    if (resolve.isTag(someArgument)) {\n      const path = resolve.path(someArgument)\n    }\n  }\n\n  return someAction\n}\n```\n\n\n## Controller\nYou have access to the controller instance on the context:\n\n```js\nfunction someAction ({controller}) {}\n```\n\n## Execution\nYou have access to function tree execution as well. This holds information about the current execution, mostly used by the devtools to inform the debugger.\n\n```js\nfunction someAction ({execution}) {}\n```\n","title":"Action"},"compute":{"raw":"# Compute\nComputes calculate and cache derived state values. Using computes helps to keep logic out of the application view components, can improve performance and make applications easier to test.\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\n\nexport default compute(\n  state`user.name`,\n  (name) => {\n    return `Hi ${name}`\n  }\n)\n```\n\nA compute takes any number and type of arguments, where each argument is passed to the next function argument (**compute function**). Tag and compute arguments will be resolved to a value when the compute executes, all other arguments are forwarded. The **compute functions** are called whenever the compute is executed, all preceding values (resolved or forwarded) will be passed with an additional **get** argument.\n\n```js\nimport {compute} from 'cerebral'\nimport {state} from 'cerebral/tags'\nimport someOtherComputed from './someOtherComputed'\n\nexport default compute(\n  state`user.name`,\n  'foo',\n  (name, foo) => {\n    return `Hi ${name}`\n  },\n  someOtherComputed,\n  (computedHello, someOtherComputedValue) => {\n    return `${computedHello} - ${someOtherComputedValue}`\n  }\n)\n```\n\nThat last argument of each function is **get**, it allows you to manually extract state and props.\n\n```js\nimport {compute} from 'cerebral'\nimport {state, props} from 'cerebral/tags'\n\nexport default compute(\n  state`user.id`,\n  (userId, get) => {\n    return get(state`projects.${userId}`).length > get(props`limit`)\n  }  \n)\n```\n","title":"Compute"},"controller":{"raw":"# Controller\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  // Defines the top level state\n  state: {},\n\n  // Defines the top level signals\n  signals: {},\n\n  // Defines the top level modules\n  modules: {}\n})\n\nexport default controller\n```\n\n## Errors\n\n\n```js\nimport {Controller} from 'cerebral'\nimport {HttpProviderError} from '@cerebral/http'\n\nconst controller = Controller({\n  catch: new Map([\n    [HttpProviderError, someCustomCatchHandlerSequence],\n    [Error, someCatchHandlerSequence]\n  ])\n})\n\nexport default controller\n```\n\nYou can also define a global error handler. This error handler will be called no matter if an error is caught or not. Useful for tracking failures in production.\n\n```js\ncontroller.on('error', (error) => {})\n```\n\n## Methods\n\n### getState\nReturns state from the state tree\n\n```js\nconst someState = controller.getState('some.state')\n```\n\n### getSignal\nReturns signal from Cerebral\n\n```js\nconst someSignal = controller.getSignal('some.signal')\n// Run signal\nsomeSignal({foo: 'bar'})\n```\n\n### getModel\nReturns the model (state tree) of Cerebral\n\n```js\nconst model = controller.getModel()\n```\n\n### flush\nFlushes out changes to UI based on recent state changes, can be forced\n\n```js\ncontroller.flush()\n```\n\n### runSignal\nAllows you to run an arbitrary function tree definition\n\n```js\ncontroller.runSignal('someSignal', [actionA, actionB], {foo: 'bar'})\n```\n\n### addModule\nAllows you to add modules to the controller after instantiation (lazy)\n\n```js\ncontroller.addModule('someModule', module)\n```\n\n### removeModule\nAllows you to remove modules from the controller\n\n```js\ncontroller.removeModule('someModule')\n```\n\n## Events\n\n### initialized\nTriggers when Cerebral controller has initialized.\n\n```js\ncontroller.on('initialized', () => {})\n```\n\n### flush\nTriggered whenever Cerebral flushes out changes to the UI. Passes a map of changes.\n\n```js\ncontroller.on('flush', (changes) => {})\n```\n\n### start\nTriggered whenever Cerebral starts a signal execution.\n\n```js\ncontroller.on('start', (execution, payload) => {})\n```\n\n### end\nTriggered whenever Cerebral ends a signal execution.\n\n```js\ncontroller.on('end', (execution, payload) => {})\n```\n\n### pathStart\nTriggered whenever Cerebral starts execution a path in a signal\n\n```js\ncontroller.on('pathStart', (execution, payload) => {})\n```\n\n### pathEnd\nTriggered whenever Cerebral ends execution a path in a signal\n\n```js\ncontroller.on('pathEnd', (execution, payload) => {})\n```\n\n### functionStart\nTriggered whenever Cerebral starts executing an action.\n\n```js\ncontroller.on('functionStart', (execution, functionDetails, payload) => {})\n```\n\n### functionEnd\nTriggered whenever Cerebral ends executing an action.\n\n```js\ncontroller.on('functionEnd', (execution, functionDetails, payload) => {})\n```\n\n### asyncFunction\nTriggered whenever Cerebral executed an async action.\n\n```js\ncontroller.on('asyncFunction', (execution, functionDetails, payload) => {})\n```\n\n### parallelStart\nTriggered whenever Cerebral executes actions in parallel.\n\n```js\ncontroller.on('parallelStart', (execution, payload, functionsToResolveCount) => {})\n```\n\n### parallelProgress\nTriggered whenever Cerebral executes actions in parallel.\n\n```js\ncontroller.on('parallelProgress', (execution, payload, functionsStillResolvingCount) => {})\n```\n\n### parallelEnd\nTriggered whenever Cerebral ends executing actions in parallel.\n\n```js\ncontroller.on('parallelEnd', (execution, payload, functionsExecutedCount) => {})\n```\n\n### remember\nTriggered whenever Cerebral travels back in time. Passes the timestamp it travelled to.\n\n```js\ncontroller.on('remember', (datetime) => {})\n```\n","title":"Controller"},"devtools":{"raw":"# Devtools\nYou can pass some options to the devtools to balance the processing and memory footprint:\n\n```js\nimport {Controller} from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: process.env.NODE_ENV === 'production' ? null : Devtools({\n    // Connect to Electron debugger (external debugger). It will\n    // fall back to chrome extension if unable to connect\n    host: 'localhost:8585',\n\n    // By default the devtools tries to reconnect\n    // to debugger when it can not be reached, but\n    // you can turn it off\n    reconnect: true,\n\n    // Time travel\n    storeMutations: true,\n\n    // Shows a warning when you have components with number of\n    // state dependencies or signals above the set number  \n    bigComponentsWarning: 5,\n\n    // Warnings when passing objects and arrays as props to child\n    // components. They should rather be connected directly\n    warnStateProps: true,\n\n    // In addition to these basic JavaScript types: Object, Array, String, Number\n    // and Boolean, types of File, FileList, Blob, ImageData and RegExp is allowed to be stored in state\n    // tree. You can add additional types if you know what you are doing :)\n    allowedTypes: [\n     Blob\n    ]\n  })\n})\n```\n\nTurning these options to false will free up memory and CPU. Typically this is not an issue at all, but if you work with data heavy applications it might make a difference.\n","title":"Devtools"},"module":{"raw":"# Module\n\nModules help you structure your state and signals into logical units. You can think of them as namespaces for state and signals.\n\n# Module object\n\n```js\nexport default {\n  // Define module state, namespaced by module path\n  state: {},\n  // Define module signals, namespaced by module path\n  signals: {},\n  // Define submodules, namespaced by module path\n  modules: {},\n  // Add a global provider when module instantiates\n  provider(context, functionDetails, payload) {}\n}\n```\n\nYou attach a module simply by referencing it:\n\n```js\nimport {Controller} from 'cerebral'\nimport FeedModule from './modules/Feed'\n\nconst controller = Controller({\n  modules: {\n    feed: FeedModule\n  }\n})\n```\n\n# Module function\nIt is also possible to define a module using a function.\n\n```js\nexport default (module) => {\n  module.name // Name of module\n  module.path // Full path to module\n  module.controller // The controller the module is attached to\n\n  return {\n    state: {},\n    signals: {},\n    modules: {},\n    provider(context, functionDetails, payload) {}\n  }\n}\n```\n\n\n# Module factory\nWith the use of a factory it is possible to make reusable modules.\n\n```js\nexport default (options) =>  {\n  return {\n    state: {\n      location: options.of\n    }\n  }\n}\n```\n\nYou then configure the module when you attach it:\n\n```js\nimport {Controller} from 'cerebral'\nimport Location from './modules/Location'\n\nconst controller = Controller({\n  modules: {\n    location1: Location({of: 'Europe'}),\n    location2: Location({of: 'Africa'})\n  }\n})\n```\n","title":"Module"},"operators":{"raw":"# Operators\nYou can call operators to create actions for you. These actions will help you change state and control the flow of execution.\n\nRead more about operators in the [Cerebral in depth - Operators](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_operators) article.\n\n## State operators\n\nThe methods for changing state within actions is also available as operators. All state operators support using both **state** and **props** tags as values.\n\nAll operators are imported as members of the 'cerebral/operators' module. For example, this imports **state** and **set**:\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n```\n\n### concat\n\nConcatenate a value to an array\n\n```js\nconcat(state`some.list`, ['foo', 'bar'])\n```\n\n### increment\n\nIncrement an integer value by another integer value into an array. The default increment is 1, and a negative value effectively does a decrement.\n\n```js\nincrement(state`some.integer`)\nincrement(state`some.integer`, -5)\nincrement(state`some.integer`, state`some.otherInteger`)\nincrement(state`some.integer`, props`some.otherInteger`)\n```\n\n### merge\n\nMerge objects into existing value. If no value exists, an empty object will be created. Merge supports using operator tags on key values:\n\n```js\nmerge(state`clients.$draft`, props`newDraft`, {\n  foo: 'bar',\n  bar: props`baz`\n})\n```\n\n### pop\n\nPop a value off an array (removes last element from array).\n\n```js\npop(state`some.list`)\n```\n\n### push\n\nPush value into an array (adds the element at the end of the array).\n\n```js\npush(state`some.list`, 'foo')\n```\n\n### set\n\nSet a target value in the state or props.\n\n```js\nset(state`foo.bar`, true),\nset(props`foo`, true)\n```\n\n### shift\n\nShift a value off an array (removes first element in array).\n\n```js\nshift(state`some.list`),\n```\n\n### splice\n\nSplice an array in place.\n\n```js\nsplice(state`some.list`, 0, 2)\n```\n\n### toggle\n\nToggle a boolean value.\n\n```js\ntoggle(state`user.$toolbar`)\n```\n\n### unset\n\nUnset key from object.\n\n```js\nunset(state`clients.all.${props`key`}`)\n```\n\n### unshift\n\nUnshift a value into an array (adds the element at the start of the array).\n\n```js\nunshift(state`some.list`, 'foo')\n```\n\n## Flow control operators\n\nThese operators help control the execution flow.\n\n### debounce\n\nHold action until the given amount of time in milliseconds has passed. If the\nsignal triggers again within this time frame, the previous signal goes down the\n\"discard\" path while the new signal holds for the given time. This is\ntypically used for typeahead functionality. For a debounce that is shared\nacross different signals, you can use `debounce.shared()` (see example below).\n\nPlease note that the `discard` path has to be present even if it is most often\nempty because debounce is a flow operator that routes the flow depending on\ntime and action trigger.\n\n```js\nimport {debounce} 'cerebral/operators'\n\nexport default [\n  debounce(200), {\n    continue: [runThisAction],\n    discard: []\n  },\n]\n```\n\n`debounce.shared()` is typically used with factories, for example to show\nnotifications where a previous notification should be cancelled by a new one.\n\n```js\nimport {debounce, set, unset} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nconst sharedDebounce = debounce.share()\nfunction showNotificationFactory(message, ms) {\n  return [\n    set(state`notification`, message),\n    sharedDebounce(ms), {\n      continue: [unset(state`notification`)],\n      discard: []\n    }\n  ]\n}\n```\n\nNow when this notification factory is used in different signals, the call to\n`debounceShared` will share the same debounce execution state:\n\n```js\nimport showNotification from './showNotification'\n\nexport default [\n  // ... user log in, etc\n  ...showNotification('User logged in', 5000)\n]\n```\n\n### equals\n\nThis operator chooses a specific path based on the provided value.\n\n```js\nimport {equals} from 'cerebral/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  equals(state`user.role`), {\n    admin: [],\n    user: [],\n    otherwise: [] // When no match\n  }\n],\n```\n\n### wait\n\nWait for the given time in milliseconds and then continue chain.\n\n```js\nimport {wait} from 'cerebral/operators'\n\nexport default [\n  wait(200),\n  doSomethingAfterWaiting\n]\n```\n\nIf you need to wait while executing in parallel, you should use a `continue`\npath to isolate the actions to be run:\n\n```js\nimport {wait} from 'cerebral/operators'\nimport {parallel} from 'cerebral'\n\nexport default\n  someAction,\n  parallel('my parallel with wait', [\n    wait(200), {\n      continue: [doSomethingAfterWaiting]\n    },\n    otherActionInParallel\n  ])\n]\n```\n\n### when\n\nRun signal path depending on a truth value or function evaluation.\n\n```js\nimport {when} from 'cerebral/operators'\n\nexport default [\n  when(state`foo.isAwesome`), {\n    true: [],\n    false: []\n  },\n  // You can also pass your own function\n  when(state`foo.isAwesome`, (value) => value.length === 3 ), {\n    true: [],\n    false: []\n  }\n]\n```\n\nWhen used with a truth function, the `when` operator supports more then a single\n\"value\" argument. The truth function must come last.\n\n```js\nimport {when} from 'cerebral/operators'\nimport {props, state} from 'cerebral/tags'\n\nexport default [\n  when(state`clients.$draft.key`, props`key`,\n    (draftKey, updatedKey) => draftKey === updatedKey\n  ), {\n    true: [\n      // Another person edited client, reset form to new value\n      set(state`clients.$draft`, props`value`)\n    ],\n    false: []\n  }\n]\n```\n","title":"Operators"},"providers":{"raw":"# Providers\n\nProviders are functions that runs before any action in any signal. Their purpose is to define and sometimes manipulate the context passed into every action. The providers run before every action, meaning that each action has a unique context object.\n\nProviders are created with a function:\n\n```js\nfunction MyProvider (context, functionDetails, payload, prevPayload) {\n  // The current context object, which can be mutated\n  context\n\n  // The details of the action running, like name, index (id) etc.\n  functionDetails\n\n  // The current payload passed to the action\n  payload\n\n  // The previous payload\n  prevPayload\n\n  // You have to return the context after it has bee mutated\n  return context\n}\n```\n\nThis function needs to be listed in the **providers** property of the controller to be registered:\n\n```js\nController({\n  providers: [MyProvider]\n})\n```\n\nAbility to add a single provider is also available in modules:\n\n```js\n{\n  state: {},\n  signals: {},\n  provider: MyProvider\n}\n```\n\nThere are a few things already available on the context when your provider runs:\n\n```js\nfunction MyProvider (context) {\n  context.execution // Information on the function tree execution\n  context.controller // The Cerebral controller\n  context.debugger // If devtools is added, you can send messages to the debugger\n  context.props // Current payload\n  context.path // If any paths are defined after the action to be executed\n  context.state // The state API\n  context.resolve // Resolve values and tag paths\n\n  return context\n}\n```\n\n## Example provider\n\n```js\n// We create a factory, allowing you to pass in options to it\nfunction GreetProviderFactory (options = {}) {\n  // We use a variable to cache the created provider\n  let cachedProvider = null\n\n  // Just some custom code to handle an option\n  let exclamationMarks = ''\n\n  for (let x = 0; x < options.numberOfExclamationMarks || 0; x++) {\n    exclamationMarks += '!'\n  }\n\n  // This is the function that creates the provider,\n  // typically just an object with some methods\n  function createProvider (context) {\n    return {\n      hello (name) {\n        return `Hello, ${name}${exclamationMarks}`\n      }\n    }\n  }\n\n  // The function that is run by Cerebral, providing the context\n  // for you to attach your provider to\n  function GreetProvider (context) {\n    context.greet = cachedProvider = (cachedProvider || createProvider(context))\n\n    // You can wrap the provider with the debugger\n    // to show information about its usage in the debugger\n    if (context.debugger) {\n      context.debugger.wrapProvider('greet')\n    }\n\n    // Always return the context after mutating it\n    return context\n  }\n\n  return GreetProvider\n}\n\nexport default GreetProviderFactory\n```\n","title":"Providers"},"signal":{"raw":"# Signal\n\nSignals are just arrays:\n\n```js\nexport default []\n```\n\nYou populate these arrays with actions:\n\n```js\nexport default [\n  someAction,\n  set(state`foo`, 'bar')\n]\n```\n\nYou can attach signals at the controller level:\n\n```js\nimport {Controller} from 'cerebral'\nimport somethingHappened from './signals/somethingHappened'\n\nconst Controller({\n  signals: {\n    somethingHappened\n  }\n})\n```\n\nOr you can attach them to modules:\n\n```js\nimport somethingHappened from './signals/somethingHappened'\n\nexport default {\n  signals: {\n    somethingHappened\n  }\n}\n```\n\n```js\nimport {Controller} from 'cerebral'\nimport app from './modules/app'\n\nconst Controller({\n  modules: {\n    app\n  }\n})\n```\n\n## Async\nBy default signals run completely synchronous, but an action might run asynchronously thus making the signal async. When an action returns a promise it means it runs async.\n\n```js\nfunction myAction () {\n  return Promise.resolve()\n}\n```\n\nYou could also use an **async** function:\n\n```js\nasync function myAction () {\n  return {foo: 'bar'}\n}\n```\n\n## Sequence\nSimple format of a sequence is to use an array literal, as explained above. Actions are run one after the other. If the action returns a promise Cerebral will wait until it resolves before moving to the next action:\n\n```js\nimport someAction from '../actions/someAction'\n\nexport default [\n  someAction\n]\n```\n\nThe array is converted to a sequence, but you can also be explicit about it:\n```js\nimport {sequence} from 'cerebral'\nimport someAction from '../actions/someAction'\n\nexport default sequence([\n  someAction\n])\n```\n\nYou can name a sequence, which will be displayed in debugger:\n```js\nimport {sequence} from 'cerebral'\nimport someAction from '../actions/someAction'\n\nexport default sequence('my sequence', [\n  someAction\n])\n```\n\nYou can compose a sequence into existing sequence. The debugger will show this composition:\n```js\nimport someAction from '../actions/someAction'\nimport someOtherSequence from './someOtherSequence'\n\nexport default [\n  someAction,\n  someOtherSequence\n]\n```\n\n## Parallel\nCerebral can not truly run actions in parallel (JavaScript is single threaded), but it can trigger multiple asynchronous actions at the same time, just like **Promise.all**. That means when Cerebral triggers actions defined within a parallel, it will not wait if a promise is returned, it will just move on to the next action. When all actions within a parallel is resolved it will move to the action after the parallel definition, if any:\n\n```js\nimport {parallel} from 'cerebral'\nimport someAsyncAction from '../actions/someAsyncAction'\nimport someOtherAsyncAction from '../actions/someOtherAsyncAction'\n\nexport default parallel([\n  someAsyncAction,\n  someOtherAsyncAction\n])\n```\n\nYou can name a parallel, which will be displayed in debugger:\n```js\nimport {parallel} from 'cerebral'\nimport someAsyncAction from '../actions/someAsyncAction'\nimport someOtherAsyncAction from '../actions/someOtherAsyncAction'\n\nexport default parallel('my parallel', [\n  someAsyncAction,\n  someOtherAsyncAction\n])\n```\n\nYou can compose parallel into any existing sequence:\n```js\nimport {parallel} from 'cerebral'\nimport someAction from '../actions/someAction'\nimport someAsyncAction from '../actions/someAsyncAction'\nimport someOtherAsyncAction from '../actions/someOtherAsyncAction'\n\nexport default [\n  someAction,\n  parallel('my parallel', [\n    someAsyncAction,\n    someOtherAsyncAction\n  ])\n]\n```\n\n## Paths\nYou can diverge execution by defining paths in your signal.\n\n```js\nexport default [\n  httpGet('/items'), {\n    success: [],\n    error: []\n  }\n]\n```\n\nThe action returned by **httpGet** will now have access to a success and an error path and can call those based on the result of the http request.\n\nYou can define any path to execute:\n\n```js\nexport default [\n  myAction, {\n    foo: [],\n    bar: [],\n    bananas: [],\n    apples: []\n  }\n]\n```\n\nWhen these paths are defined you will have access to corresponding paths in the action preceding the paths:\n\n```js\nfunction myAction ({path}) {\n  path.foo\n  path.bar\n  path.bananas\n  path.apples\n}\n```\n\nTo actually diverge down the path you have to call it and return it from the action:\n\n```js\nfunction myAction ({path}) {\n  return path.foo()\n}\n```\n\nOptionally pass a payload:\n\n```js\nfunction myAction ({path}) {\n  return path.bananas({foo: 'bar'})\n}\n```\n\nWith promises you just return it the same way:\n\n```js\nfunction myAction ({someProvider, path}) {\n  return someProvider.doAsync()\n    .then((result) => path.bananas({data: result.data}))\n}\n```\n\n## Errors\nYou can catch specific errors on a signal.\n\n```js\nimport {Controller} from 'cerebral'\nimport somethingHappened from './signals/somethingHappened'\nimport httpFailed from './signals/httpFailed'\nimport {HttpProviderError} from 'cerebral-provider-http'\n\nconst Controller({\n  signals: {\n    somethingHappened: {\n      signal: somethingHappened,\n      catch: new Map([\n        [HttpProviderError, httpFailed]\n      ])\n    }\n  }\n})\n```\n","title":"Signal"},"state":{"raw":"# State\n\n## Get state\nThe only way to get state in your application is by connecting it to a component or grabbing it in an action.\n\n```js\nfunction someAction({state}) {\n  // Get all state\n  const allState = state.get()\n  // Get by path\n  const stateAtSomePath = state.get('some.path')\n}\n```\n\n\n## Updating state\nThe only way to update the state of your application is in an action. Here is a list of all possible state mutations you can do:\n\n```js\nfunction someAction({state}) {\n  // Concats passed array to existing array\n  state.concat('some.path', ['someValueA', 'someValueB'])\n  // Increment value at given path (default increment is 1)\n  state.increment('some.path', 1)\n  // Merge the keys and their values into existing object. Handled as a\n  // change on all paths merged in\n  state.merge('some.path', {\n    some: 'value'\n  })\n  // Removes last item in array\n  state.pop('some.path')\n  // Pushes a value to the end of the array\n  state.push('some.path', 'someValue')\n  // Set or replace a value\n  state.set('some.path', 'someValue')\n  // Removes first item in array\n  state.shift('some.path')\n  // Splices arrays\n  state.splice('some.path', 2, 1)\n  // Toggle a boolean value\n  state.toggle('some.path')\n  // Unset a key and its value\n  state.unset('some.path')\n  // Puts the value at the beginning of the array\n  state.unshift('some.path', 'someValue')\n}\n```\n\n**NOTE!** You should not change state directly in your actions or components. This will not be tracked by Cerebral. That means a render will not be triggered and the debugger will not know about it. Treat your state as if it was immutable and only change it using the **state API**.\n\n## Special values support\nWhen building an application you often need to keep things like files and blobs in your state for further processing. Cerebral supports these kinds of values because they will never change, or changing them can be used with existing state API. This is the list of supported types:\n\n- **File**\n- **FilesList**\n- **Blob**\n- **ImageData**\n- **RegExp**\n\nIf you want to force Cerebral to support other types as well, you can do that with a devtools option. This is perfectly okay, but remember all state changes has to be done through the state API.\n","title":"State"},"tags":{"raw":"# Tags\nTags allow you to reference things in Cerebral. They are based on [template literal tags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals). They can be used by **operators**, **connect** and **compute**. Some of them can also be used with other Cerebral modules. The great thing about tags is their composability. For example:\n\n```js\nimport {state, props} from 'cerebral/tags'\n\nstate`items.${state`currentItemKey`}`\n\nstate`items.${props`itemKey`}`\n```\n\nThis allows you to express signals and component dependencies more effectively. There are 4 tags in Cerebral.\n\n- **state** - Used in signals and connect to target state\n- **props** - Used in signals to target payload and in connect to target component props\n- **signal** - Used in signals and connect to target a signal\n- **string** - Used in signals to evaluate a composed string\n","title":"Tags"},"universalcontroller":{"raw":"# Universal Controller\nThe Universal Controller allows you to put your application in its initial state on the server. In combination with your chosen view layer you can now render the application on the server and show it near instantly in the context of the current user. When the client side application loads it will piggyback on the existing DOM and effectively rehydrate the minimal state from the server to make it up to date, meaning that the pure HTML responded from your server and the loading of the actual application is transparent.\n\nRead more about server side rendering in the [Cerebral in depth - SSR](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_ssr) article.\n\n**Note** that when using JSX syntax it is wise to also transpile your server side code, which this example shows.\n\n```js\nimport {UniversalController} from 'cerebral'\nimport appModule from '../client/modules/app'\n\nconst controller = UniversalController({\n  // Same API as Controller\n  // Here loading the same modules as the\n  // client loads\n  modules: {\n    app: appModule\n  }\n})\n```\n\n## Methods\n### runSequence\nIf you need to update the state of the controller you can run a signal execution for doing so:\n\n```js\nimport {UniversalController} from 'cerebral'\nimport appModule from '../client/modules/app'\n\nconst controller = UniversalController({\n  modules: {\n    app: appModule\n  }\n})\n\ncontroller.runSequence([\n  function myAction ({state, props}) {\n    state.set('app.isAwesome', props.isAwesome)\n  }\n], {\n  isAwesome: true\n})\n  .then(() => {\n    // I am done running\n  })\n```\n\nYou can run a predefined signal, which is defined inside a controller module as well:\n```js\nconst controller = new UniversalController({\n  modules: {\n    app: {\n      ...,\n      signals: {\n        aSignal: [\n          function myAction ({state, props}) {\n            state.set('app.isAwesome', props.isAwesome)\n          }\n        ],\n      },\n    },\n  },\n})\n\ncontroller\n  .runSequence('app.aSignal', {isAwesome: true})\n  .then(() => {\n    // I am done running\n  })\n```\n\nYou can add any providers to the controller to do database fetching etc. inside this **runSequence** execution. Think of it as a signal the updates the state of the app before rendering it on the server.\n\n**NOTE!** You should instantiate the controller for each run you want to do.\n\n### setState\nFinally, you can (synchronously) set a value inside the state directly, using a path:\n\n```js\nimport {UniversalController} from 'cerebral'\nimport appModule from '../client/modules/app'\n\nconst controller = UniversalController({\n  modules: {\n    app: appModule\n  }\n})\n\ncontroller.setState('app.foo', 123)\n```\n\n### getScript\nWhen the client side application loads it will do its first render with the default state, meaning that if the server updated the state this is now out of sync. Using the **getScript** method you will get a script tag you can inject into the *HEAD* of the returned HTML. Cerebral will use this to bring your client side application state up to date with the server.\n\n```js\nimport {UniversalController} from 'cerebral'\nimport appModule from '../client/modules/app'\nimport fs from 'fs'\n\n/*\n  <!DOCTYPE html>\n  <html>\n    <head>\n      {{CEREBRAL_SCRIPT}}\n    </head>\n    <body>\n      <div id=\"app\">{{APP}}</div>\n    </body>\n  </html>\n*/\nconst indexTemplate = fs.readFileSync('index.template.html').toString()\n\nconst controller = UniversalController({\n  modules: {\n    app: appModule\n  }\n})\n\ncontroller.run([\n  function myAction ({state, props}) {\n    state.set('app.isAwesome', props.isAwesome)\n  }\n], {\n  isAwesome: true\n})\n  .then(() => {\n    const index = indexTemplate\n      .replace('{{CEREBRAL_SCRIPT}}', controller.getScript())\n  })\n```\n\n## Render\nDepending on the view layer of your choice you can bring all of this together:\n\n```js\nimport React from 'react'\nimport express from 'express'\nimport fs from 'fs'\nimport {renderToString} from 'react-dom/server'\nimport {UniversalController} from 'cerebral'\nimport {Container} from 'cerebral/react'\nimport appModule from '../client/modules/app'\nimport App from '../client/components/App'\nimport loadApp from './loadApp'\n\nconst server = express()\nconst indexTemplate = fs.readFileSync('index.template.html').toString()\n\nserver.get('/', (req, res) => {\n  const controller = UniversalController({\n    modules: {\n      app: appModule\n    }\n  })\n\n  controller.run(loadApp, {\n      query: req.query,\n      useragent: req.headers['user-agent']\n    })\n      .then(() => {\n        const index = indexTemplate\n          .replace('{{CEREBRAL_SCRIPT}}', controller.getScript())\n          .replace('{{APP}}', renderToString(\n            <Container controller={controller}><App /></Container>\n          ))\n\n        res.send(index)\n      })\n})\n\nserver.listen(3000)\n```\n\n## ES6 on server\nTake a look at the [demo application](https://github.com/cerebral/cerebral/tree/master/demos/universal) to see how you can run modern javascript, also with JSX, on the server. Demo does not include building for production, but you would typically use Webpack as normal for the client and just babel for the server. Or you can use Webpack there as well. If you are not using JSX you will probably get away with no transpiling on the server.\n","title":"Universal Controller"}},"views":{"index":{"raw":"# Angular 2/4 (BETA)\n\n[Angular](https://angular.io/) view for Cerebral.\n\n## Install\n\n`npm install @cerebral/angular @angular/core @angular/platform-browser babel-plugin-transform-decorators-legacy`\n\n## CerebralService\nThe Cerebral service exposes the Cerebral controller to your application.\n\n```ts\nimport { NgModule } from '@angular/core'\nimport { BrowserModule } from '@angular/platform-browser'\n\nimport { provide } from 'cerebral'\nimport { ControllerService } from '@cerebral/angular'\n\nimport { AppComponent }  from './app.component.ts'\nimport { SomeAngularService } from './SomeAngularService'\n\n// Create a factory to instantiate Cerebral. It can receive\n// dependencies which you can \"provide\" to Cerebral to be used\n// within signals\nexport function configureController(someAngularService : SomeAngularService) {\n  return new ControllerService({\n    // We use the \"provide\" function to an angular service to the signals\n    // of Cerebral\n    providers: [\n      provide('someAngularService', someAngularService)\n    ]\n  })\n})\n\n@NgModule({\n  imports:      [ BrowserModule ],\n  declarations: [ AppComponent ],\n  bootstrap:    [ AppComponent ],\n  providers: [\n     {\n      provide: ControllerService,\n      useFactory: configureController,\n      deps: [SomeAngularService]\n    },\n  ]\n})\nexport class AppModule {}\n```\n\n## connect decorator\nThe connect decorator connects state and signals to your components.\n\n```ts\nimport { Component, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core'\nimport { signal, state } from 'cerebral/tags'\nimport { connect, ControllerService, CerebralComponent } from '@cerebral/angular'\n\n@Component({\n  selector: 'app-component',\n  template: `\n    <div (click)=\"onClick()\">{{foo}}</div>\n  `,\n  // Change detection needs to be set to \"OnPush\"\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\n@connect({\n  // For AOT to work you will have to use the array version of template\n  // tags\n  myName: state(['foo']),\n  onClick: signal(['clicked'])\n})\nexport class AppComponent extends CerebralComponent {\n  // You have to inject \"ChangeDetectionRef\" and \"ControllerService\" and pass\n  // them to parent for connect to do its work\n  constructor(cdr: ChangeDetectorRef, controller: ControllerService) {\n    super(cdr, controller)\n    controller.getSignal('onClick')()\n  }\n}\n```\n","title":"Angular 2/4 (BETA)"},"angularjs":{"raw":"# @cerebral/angularjs\n\n[Angularjs](https://angularjs.org) view for Cerebral.\n\n## Install\n\n`npm install @cerebral/angularjs angular`\n\n## Config\n```js\nimport angular from 'angular'\nimport {addModule, connect} from '@cerebral/angularjs'\nimport {state, signal} from 'cerebral/tags'\n\naddModule(angular)\n\nangular.module('app', ['cerebral'])\n  .config(function (cerebralProvider) {\n    cerebralProvider.configure({\n      state: {\n        foo: 'bar'\n      },\n      signals: {\n        clicked: []\n      },\n\n      // Special controller property to expose core\n      // angular services to your signals\n      services: ['$http', '$timeout']\n    })\n  })\n  ...\n```\n\n## connect\n```js\nimport angular from 'angular'\nimport {addModule, connect} from '@cerebral/angularjs'\nimport {state, signal} from 'cerebral/tags'\n\nangular.module('app', ['cerebral'])\n  .config(...)\n  .component('myComponent', {\n    template: '<div ng-click=\"$ctrl.click()\">{{$ctrl.foo}}</div>',\n    controller: connect({\n      foo: state`foo`,\n      click: signal`clicked`\n    }, 'MyComponent', ['cerebral', function MyController (cerebral) {\n\n      // In some cases you might need access to cerebral's controller.\n      // You can inject the cerebral angular service and\n      // access it's controller property anywhere in your app\n      cerebral.controller.getSignal('mySignal')()\n\n      // Optionally add custom behaviour to controller\n    }])\n  })\n```\n\nSince angular doesn't expose the component name,\nyou will need to provide one to `connect` for the\ncomponent to be given a name in cerebral.\n\nYou can call connect in the following ways:\n```js\nconnect(dependencies)\nconnect(dependencies, name)\nconnect(dependencies, controller)\nconnect(dependencies, name, controller)\n```\n","title":"@cerebral/angularjs"},"inferno":{"raw":"# @cerebral/inferno\n\n[Inferno](http://infernojs.org) view for Cerebral.\n\n## Install\n\n`npm install @cerebral/inferno inferno inferno-component inferno-create-element babel-plugin-inferno`\n\n## Container\n```js\nimport Inferno from 'inferno'\nimport {Controller} from 'cerebral'\nimport {Container} from '@cerebral/inferno'\nimport App from './App'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\nInferno.render((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n## connect\n```js\nimport Inferno from 'inferno'\nimport Component from 'inferno-component'\nimport {connect} from '@cerebral/inferno'\nimport {state, signal} from 'cerebral/tags'\n\n// Stateless\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  function MyComponent ({foo, click}) {\n    return <div onClick={() => click()}>{foo}</div>\n  }\n)\n\n// Stateful\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  class MyComponent extends Component {\n    render () {\n      return <div onClick={() => this.props.click()}>{this.props.foo}</div>\n    }\n  }\n)\n```\n","title":"@cerebral/inferno"},"preact":{"raw":"# @cerebral/preact\n\n[Preact](https://github.com/developit/preact) view for Cerebral.\n\n## Install\n`npm install @cerebral/preact preact babel-preset-preact`\n\n## Container\n```js\nimport {h, render} from 'preact'\nimport {Controller} from 'cerebral'\nimport {Container} from '@cerebral/preact'\nimport App from './App'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n## connect\n```js\nimport {h, Component} from 'preact'\nimport {connect} from '@cerebral/preact'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  class MyComponent extends Component {\n    render ({foo, click}) {\n      return <div onClick={() => click()}>{foo}</div>\n    }\n  }\n)\n```\n","title":"@cerebral/preact"},"react":{"raw":"# @cerebral/react\n\n[React](https://facebook.github.io/react) view for Cerebral.\n\n## Install\n`npm install @cerebral/react react react-dom babel-preset-react`\n\n## Container\n```js\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Controller} from 'cerebral'\nimport {Container} from '@cerebral/react'\nimport App from './App'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\nrender((\n  <Container controller={controller}>\n    <App />\n  </Container>\n), document.querySelector('#app'))\n```\n\n## connect\nTypically you add a stateless component:\n\n```js\nimport React from 'react'\nimport {state, signal} from 'cerebral/tags'\nimport {connect} from '@cerebral/react'\n\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  function MyComponent ({foo, click}) {\n    return <div onClick={() => click()}>{foo}</div>\n  }\n)\n```\n\nBut you can also use stateful components:\n```js\nimport React from 'react'\nimport {state, signal} from 'cerebral/tags'\nimport {connect} from '@cerebral/react'\n\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  class MyComponent extends React.Component {\n    render () {\n      return <div onClick={() => this.props.click()}>{this.props.foo}</div>\n    }\n  }\n)\n```\n\nYou can add an additional function to connect that gives you full control of properties of the component and dependencies. The returned object from this function will be the exact props passed into the component.\n\n```js\nimport React from 'react'\nimport {signal, state} from 'cerebral/tags'\nimport {connect} from '@cerebral/react'\n\nexport default connect({\n  foo: state`app.foo`,\n  clicked: signal`app.somethingClicked`\n}, (dependencyProps, ownProps, resolve) => {\n  // we can resolve values or path here. Note: it's not tracked as dependency\n  const path = resolve.path(state`entities.foo.{ownProps}`)\n\n  return {\n    // values from state could be transformed here\n    foo: `Label: ${foo}`,                       \n    // signals calls could be bound here, so component uses it as general callback            \n    onClick: (e) => clicked({ id: ownProps.id })\n  }\n},\n  function App({foo, onClick}) {\n    return <div onClick={onClick}>{foo}</div>\n  }\n)\n```\n\n- **dependencyProps** are the props you connected.\n\n- **props** are the props passed into the component by the parent.\n\n- **resolve** allows you to resolve computed etc., just like resolve in actions.\n\n## TypeScript\n\nIf you use TypeScript, you can type your component props with connect:\n\n```ts\nimport React from 'react'\nimport {state, signal} from 'cerebral/tags'\nimport {connect} from '@cerebral/react'\n\n// connected props\ninterface Props {\n  click (): void\n  foo: string\n}\n\n// component props such as <MyComponent name='foobar' />\ninterface EProps {\n  name: string\n}\n\n// Stateless\nexport default connect<Props, EProps>({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  // TypeScript now knows about foo and click props\n  function MyComponent ({foo, click}) {\n    return <div onClick={() => click()}>{foo}</div>\n  }\n)\n\n// Stateful\nexport default connect<Props, EProps>({\n  foo: state`foo`,\n  click: signal`clicked`\n},\n  class MyComponent extends React.Component<Props, EProps> {\n    render () {\n      return <div onClick={() => this.props.click()}>{this.props.foo}</div>\n    }\n  }\n)\n```\n","title":"@cerebral/react"},"vue":{"raw":"# @cerebral/vue\n\n[Vue.js](https://vuejs.org) view for Cerebral.\n\n## Install\n`npm install @cerebral/vue vue`\n\n## Container\n```js\nimport Vue from 'vue/dist/vue'\nimport {Controller} from 'cerebral'\nimport {Container, connect} from '@cerebral/vue'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\n var app = new Vue({\n  el: '#app',\n  components: {\n    container: Container(controller)\n  }\n})\n```\n\n**Note!** The HTML of the root element must use the *container*:\n\n```html\n<div id=\"app\">\n  <container>\n    <my-component></my-component>\n  </container>\n</div>\n```\n\n## connect\n*MyComponent.js*\n```js\nimport {connect} from '@cerebral/vue'\nimport {state, signal} from 'cerebral/tags'\n\nexport default connect({\n  foo: state`foo`,\n  click: signal`clicked`\n}, {\n  template: '<div v-on:click=\"click()\">{{foo}}</div>'\n})\n```\n\n*main.js*\n```js\nimport Vue from 'vue/dist/vue'\nimport {Controller} from 'cerebral'\nimport {Container, connect} from '@cerebral/vue'\nimport MyComponent from './MyComponent'\n\nconst controller = Controller({\n  state: {\n    foo: 'bar'\n  },\n  signals: {\n    clicked: []\n  }\n})\n\n var app = new Vue({\n  el: '#app',\n  components: {\n    container: Container(controller),\n    'my-component': MyComponent\n  }\n})\n```\n","title":"@cerebral/vue"}},"addons":{"index":{"raw":"# function-tree\n\n## Install\n**NPM**\n\n`npm install function-tree`\n\n## Description\nFunction-tree is the what Cerebral extends to create its signal implementation. You can use this library on the server, or standalone in the client as a replacement for Cerebral. Basically a function-tree allows you to execute a tree of functions. You can use the Cerebral debugger to debug function tree execution in any JS environment.\n\nFunction-tree is somewhat in the same family as Rxjs and Promises. The main difference is that Rxjs and Promises  are based on value transformation. That means only the value returned from the previous function is available in the next. This works when you indeed want to transform values, but events in your application are rarely about value transformation, they are about running side effects and going through one of multiple execution paths. Function tree embraces the fact that most of what we do in application development is running side effects.\n\nRxjs and Promises are also about execution control, but neither of them have declarative conditional execution paths, you have to write an *IF* or *SWITCH* statement or decouple streams. With function tree you are able to diverge the execution down paths just as declaratively as functions. This helps readability.\n\n## Instantiate\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nconst ft = new FunctionTree({\n  // add side effect libraries to context\n})\n\nft.run([\n// returns a promise\n  function someFunc (context) {},\n  function someOtherFunc (context) {}\n], {\n  foo: 'bar' // optional payload\n})\n.catch((error) => {\n  // Current payload with execution details,\n  // can be passed in to a new execution (will be indicated in debugger)\n  error.payload\n\n  // A serialized version of the error. Name, message and stack, or custom error serialization\n  error.payload.error\n})\n```\n\nYou can also add multiple custom context providers by using an array:\n\n```js\nconst ft = new FunctionTree([{\n    // add side effect libraries to context\n  },\n  SomeCustomProvider()\n])\n```\n\n## errors\n\n### FunctionTreeError (base)\n```js\nimport {FunctionTreeError} from 'function-tree'\n// Node:\n// const FunctionTreeError = require('function-tree').FunctionTreeError\n\n// Error structure\n{\n  name: 'FunctionTreeError',\n  message: 'Some function-tree error'\n  stack: '...'  \n}\n```\n\n### FunctionTreeExecutionError\n```js\nimport {FunctionTreeExecutionError} from 'function-tree'\n// Node:\n// const FunctionTreeExecutionError = require('function-tree').FunctionTreeExecutionError\n\n// Error structure\n{\n  name: 'FunctionTreeExecutionError',\n  message: 'Some execution error'\n  execution: {name: 'someName'},\n  funcDetails: {name: 'someFunction', functionIndex: 5},\n  payload: {foo: 'bar'},\n  stack: '...'  \n}\n```\n\n### devtools\nDownload the function tree standalone debugger for [Mac](https://drive.google.com/file/d/0B1pYKovu9Upyb1Bkdm5IbkdBN3c/view?usp=sharing), [Windows](https://drive.google.com/file/d/0B1pYKovu9UpyMGRRbG45dWR6R1k/view?usp=sharing) or [Linux](https://drive.google.com/file/d/0B1pYKovu9UpyMFQ5dEdnSy1aN0E/view?usp=sharing).\n\n```js\nimport FunctionTree from 'function-tree'\nimport Devtools from 'function-tree/devtools'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n// const Devtools = require('function-tree/devtools').Devtools\n\nconst devtools = new Devtools({\n  // Set url of remote debugger\n  host: 'localhost:8585',\n\n  // By default debugger tries to reconnect when it is not active\n  reconnect: true\n})\nconst ft = new FunctionTree([])\n\n// Add your function tree to the debugger\ndevtools.add(ft)\n\n// If you are not going to use it anymore, remove it\ndevtools.remove(ft)\n\n// Remove all function trees from debugger\ndevtools.destroy()\n```\n\nYou can use it when creating providers to easily wrap their usage:\n\n```js\nfunction MyProvider (options = {}) {\n  let cachedProvider = null\n\n  function createProvider (context) {\n    return {\n      doSomething() {},\n      doSomethingElse() {}\n    }\n  }\n\n  return (context) => {\n    context.myProvider = cachedProvider = (cachedProvider || createProvider(context))\n\n    if (context.debugger) {\n      context.debugger.wrapProvider('myProvider')\n    }\n\n    return context\n  }\n}\n```\n\n### sequence\nYou can use an array literal to define a sequence of functions.\n\n```js\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = [\n  someFunction,\n  someOtherFunction\n]\n```\n\nOr you can be explicit by using the **sequence** function:\n\n```js\nimport {sequence} from 'function-tree'\n// Node:\n// const sequence = require('function-tree').sequence\n\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = sequence([\n  someFunction,\n  someOtherFunction\n])\n```\n\nThe first argument to **sequence** can be a string, which names the sequence. This will be shown in the debugger. If it is the root sequence it will be used as the name of the execution itself.\n\n```js\nimport {sequence} from 'function-tree'\n// Node:\n// const sequence = require('function-tree').sequence\n\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = sequence('My awesome sequence', [\n  someFunction,\n  someOtherFunction\n])\n```\n\n### parallel\n```js\nimport {parallel} from 'function-tree'\n// Node:\n// const sequence = require('function-tree').parallel\n\nfunction someFunction (context) {}\nfunction someOtherFunction (context) {}\n\nmodule.exports = parallel([\n  someFunction,\n  someOtherFunction\n])\n```\n\nEven though **someFunction** returns a Promise, **someOtherFunction** will be run immediately.\n\n### context\n\n#### props\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nfunction funcA (context) {\n  context.props.foo // \"bar\"\n}\n\nconst ft = new FunctionTree()\nconst tree = [\n  funcA\n]\n\nft.run(tree, {foo: 'bar'})\n```\n\n#### path\nThe path is only available on the context when the function can diverge the execution down a path.\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nfunction funcA (context) {\n  context.props.foo // \"bar\"\n\n  return context.path.pathA({foo2: 'bar2'})\n}\n\nfunction funcB (context) {\n  context.props.foo // \"bar\"\n  context.props.foo2 // \"bar2\"\n\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({foo3: 'bar3'})\n    }, 100)\n  })\n}\n\nfunction funcC(context) {\n  context.props.foo // \"bar\"\n  context.props.foo2 // \"bar2\"\n  context.props.foo3 // \"bar3\"\n}\n\nconst ft = new FunctionTree([])\nconst tree = [\n  funcA, {\n    pathA: [\n      funcB,\n      funcC\n    ],\n    pathB: []\n  }\n]\n\nft.run(tree, {foo: 'bar'})\n```\n\n### error\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\nconst ft = new FunctionTree([])\n\n// As an event (async)\nft.on('error', function (error, execution, payload) {})\n\n// As callback for single execution\n// Triggers sync/async depending on where error occurs\nft.run(tree, (error) => {})\n\n// As callback (sync)\nft.run(tree, (error, execution, payload) => {\n  if (error) {\n    // There is an error\n  }\n})\n```\n\n### provider\nA provider gives you access to the current context and other information about the execution. It is required that you return the context or a mutated version of it.\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nfunction MyProvider(context, functionDetails, payload) {\n  context // Current context\n  context.props // Input created by the PropsProvider (default)\n\n  payload // The current payload (Used by PropsProvider)\n\n  functionDetails.name // Name of the function\n  functionDetails.functionIndex // The index of the function in the tree, like an ID\n  functionDetails.function // A reference to the running function\n  functionDetails.isParallel // If the function is running in parallel with others\n\n  context.execution.name // Function tree id\n  context.execution.id // Current execution id\n  context.execution.staticTree // The static representation of the tree\n  context.execution.datetime // Time of execution\n  context.execution.functionTree // The function tree instance\n\n  return context // Always return the changed context\n}\n\nconst ft = new FunctionTree([\n  MyProvider\n])\n```\n\nProviders lets us do some pretty amazing things. The debugger for **function-tree** is actually just a provider that sends information to the debugger about execution and exposes an API for other providers to send their own data to the debugger.\n\n#### StopExecutionProvider\nBy using a condition you can tell the function tree to stop executions.\n\n```js\nimport {StopExecutionProvider} from 'function-tree'\n// Node:\n// const StopExecutionProvider = require('function-tree').StopExecutionProvider\n\nconst ft = new FunctionTree([\n  StopExecutionProvider({\n    nameOfExecution (context) {\n      return context.props.stop\n    }\n  })\n])\n```\n\nIf the condition returns true the execution will throw an error and stop.\n\n### events\nThe execute function is also an event emitter.\n\n```js\nimport FunctionTree from 'function-tree'\n// Node:\n// const FunctionTree = require('function-tree').FunctionTree\n\nconst ft = new FunctionTree([])\nconst tree = [\n  funcA\n]\n\n// When an error is thrown, also catches promise errors\nft.on('error', (error, execution, payload) => {})\n\n// When a function tree is executed\nft.on('start', (execution, payload) => {})\n\n// When a function tree execution has ended\nft.on('end', (execution, payload) => {})\n\n// When a function tree goes down a path\nft.on('pathStart', (execution, payload) => {})\n\n// When a function tree ends execution of a path\nft.on('pathEnd', (execution, payload) => {})\n\n// When a function in a function tree starts executing\nft.on('functionStart', (execution, functionDetails, payload) => {})\n\n// When a function in a function tree stops executing\nft.on('functionEnd', (execution, functionDetails, payload) => {})\n\n// Triggers when an async function has been run\nft.on('asyncFunction', (execution, functionDetails, payload) => {})\n\n// When a parallel execution is about to happen (array in array)\nft.on('parallelStart', (execution, payload, functionsToResolveCount) => {})\n\n// When a function in parallel execution is done executing\nft.on('parallelProgress', (execution, payload, functionsStillResolvingCount) => {})\n\n// When a parallel execution is done\nft.on('parallelEnd', (execution, payload, functionsExecutedCount) => {})\n\nft.run(tree)\n```\n","title":"function-tree"},"firebase":{"raw":"# @cerebral/firebase\n\n## Install\n**NPM**\n\n`npm install @cerebral/firebase`\n\n## Description\nThe Firebase provider is a Cerebral friendly wrapper around the Firebase client. By default the Firebase client is heavily event based, even just getting some value, handling authentication etc. This is useful in some types of apps, but Cerebral has a very straight forward way of thinking about side effects. You will find that a lot of the API exposed by the Firebase client is simplified!\n\n\n## Instantiate\n\n```javascript\nimport {Controller} from 'cerebral'\nimport FirebaseProvider from '@cerebral/firebase'\n\nconst controller = Controller({\n  providers: [\n    FirebaseProvider({\n      config: {\n        apiKey: '{apiKey}',\n        authDomain: '{authDomain}',\n        databaseURL: '{databaseURL}',\n        storageBucket: '{storageBucket}'\n      },\n      // Tasks related options:\n      // Prefix the specs triggered. This is useful in\n      // development when multiple developers are working\n      // on the same instance.\n      specPrefix: 'CJ',\n      // Use a different queue path.\n      queuePath: 'myqueue' // default = 'queue'\n    })\n  ]\n})\n```\n\n**Important notes**\n\n- The Cerebral firebase provider uses **dot** notation to keep consistency with Cerebral itself\n\n- All factories supports template tags, allowing you to dynamically create paths and points to values\n\n## cancelOnDisconnect\nCancel setting a value when Firebase detects disconnect.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  firebase.cancelOnDisconnect()\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {cancelOnDisconnect} from '@cerebral/firebase/operators'\n\nexport default [\n  cancelOnDisconnect()\n]\n```\n\n## createUserWithEmailAndPassword\nRegister a new user with email and password.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  const email = state.get('register.email')\n  const password = state.get('register.password')\n\n  return firebase.createUserWithEmailAndPassword(email, password)\n    .then((response) => {\n      /*\n        user: { uid: 'someuid', ... }\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {createUserWithEmailAndPassword} from '@cerebral/firebase/operators'\n\nexport default [\n  createUserWithEmailAndPassword(state`newUser.email`, state`newUser.password`),\n  /*\n    PROPS: {\n      response: { user: {} }\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {createUserWithEmailAndPassword} from '@cerebral/firebase/operators'\n\nexport default [\n  createUserWithEmailAndPassword(state`newUser.email`, state`newUser.password`), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## deleteFile\n\nUse `deleteFile` to remove an uploaded file. Specify the containing folder and filename.\n\n### action\n```js\nfunction someAction({ firebase, props }) {\n  return firebase.deleteFile('folderName', props.fileName)\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```js\nimport {props, state, string} from 'cerebral/tags'\nimport {deleteFile} from '@cerebral/firebase/operators'\n\nexport default [\n  deleteFile(\n    string`posts.all.${props`postId`}`,\n    state`posts.all.${props`postId`}.imageName`\n  ),\n  // No output\n\n  // Alternatively with explicit paths\n  deleteFile(\n    string`posts.all.${props`postId`}`,\n    state`posts.all.${props`postId`}.imageName`\n  ), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### operator with paths\n```js\nimport {props, state, string} from 'cerebral/tags'\nimport {deleteFile} from '@cerebral/firebase/operators'\n\nexport default [\n  deleteFile(\n    string`posts.all.${props`postId`}`,\n    state`posts.all.${props`postId`}.imageName`\n  ), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## error\nThe Firebase errors are passed to signal and global catch handlers, or `.catch` handler in your actions.\n\n### FirebaseProviderError (base)\n```js\nimport {FirebaseProviderError} from '@cerebral/firebase'\n\n// Error structure\n{\n  name: 'HttpProviderError',\n  message: 'Some firebase error message'\n  stack: '...'  \n}\n```\n\n### FirebaseProviderAuthenticationError\n```js\nimport {FirebaseProviderAuthenticationError} from '@cerebral/firebase'\n\n// Error structure\n{\n  name: 'HttpProviderError',\n  message: 'Some firebase error message'\n  code: 10 // firebase auth error code\n  stack: '...'  \n}\n```\n\n## getUser\nWill resolve to `{user: {}}` if user exists. If user was redirected from Facebook/Google etc. as part of first sign in, this method will handle the confirmed registration of the user.\n\n### action\n```js\nfunction someAction({ firebase }) {\n  return firebase.getUser()\n    .then((response) => {\n      /*\n        user: {...},\n        isRedirected: false\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {getUser} from '@cerebral/firebase/operators'\n\nexport default [\n  getUser(),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {getUser} from '@cerebral/firebase/operators'\n\nexport default [\n  getUser(), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## linkWith{PROVIDER}\nLink an anonymous account with Facebook, Google or Github.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.linkWithFacebook({\n    redirect: false, // Use popup or redirect. Redirect typically for mobile\n    scopes: [] // Facebook scopes to access\n  })\n    .then((response) => {\n      /*\n        name: 'Bob',\n        ...\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {linkWithFacebook} from '@cerebral/firebase/operators'\n\nexport default [\n  linkWithFacebook({\n    redirect: state`useragent.media.small`\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {linkWithFacebook} from '@cerebral/firebase/operators'\n\nexport default [\n  linkWithFacebook({\n    redirect: state`useragent.media.small`\n  }), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\nSimilar you can sign in with Google or GitHub.\nJust use `linkWithGoogle` or `linkWithGithub` instead of `linkWithFacebook`.\n\n\n## off\n\n### action\n```js\nfunction someAction({ firebase }) {\n  // Turn off listener at specific path and\n  // specific event\n  firebase.off('posts', 'onChildChanged')\n\n  // Turn off all listeners at specific path\n  firebase.off('posts')\n\n  // Turn off all listeners of specific event at wildcard path\n  firebase.off('posts.*', 'onChildChanged')\n\n  // Turn off all listeners at wildcard path\n  firebase.off('posts.*')\n}\n```\n\n### operator\n```javascript\nimport {string} from 'cerebral/tags'\nimport {off} from '@cerebral/firebase/operators'\n\nexport default [\n  // Same API as in actions, also wildcard\n  off('posts', 'onChildChanged'),\n\n  // Compose using string tag\n  off(string`posts.${state`selectedPostKey`}`)\n]\n```\n\n## onChildAdded\n\n### action\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildAdded('posts', 'posts.postAdded', {\n    // Merged with the payload passed on new data\n    payload: {},\n    // Read Firebase docs for these options\n    endAt: 5,\n    equalTo: 5,\n    limitToFirst: 5,\n    limitToLast: 5,\n    orderByChild: 'count',\n    orderByKey: true,\n    orderByValue: true,\n    startAt: 5,\n  })\n  // posts.postAdded called with { key, value, ...payload }\n}\n```\n\nThis will immediately grab and trigger the signal `posts.postAdded` for every post grabbed. Note this is just registering a listener, not returning a value from the action. The signal is triggered with the payload: `{ key: 'someKey', value: {} }`.\n\nTo stop listening for updates to the posts:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildAdded');\n}\n```\n\n### operator\n```javascript\nimport {state, string, signal} from 'cerebral/tags'\nimport {onChildAdded} from '@cerebral/firebase/operators'\n\nexport default [\n  onChildAdded(string`foo.bar`, signal`some.signal`, {\n    orderByChild: 'count',\n    limitToFirst: state`config.limitToFirst`\n  })\n]\n```\n\n## onChildChanged\n\n### action\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildChanged('posts', 'posts.postChanged', {\n    // Same options as above\n  })\n  // posts.postChanged called with { key, value, ...payload }\n}\n```\nThis will trigger the signal `posts.postChanged` whenever a post is changed in the selection. The signal is triggered with the payload: `{ key: 'someKey', value: {} }`.\n\nTo stop listening:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildChanged');\n}\n```\n\n### operator\n```javascript\nimport {onChildChanged} from '@cerebral/firebase/operators'\nimport {string, signal} from 'cerebral/tags'\n\nexport default [\n  onChildChanged(string`foo.bar`, signal`some.signal`, {\n    // Same options as above\n  })\n]\n```\n\n## onChildRemoved\n\n### action\n```js\nfunction someAction({ firebase }) {\n  firebase.onChildRemoved('posts', 'posts.postRemoved', {\n    // Same options as above\n  })\n  // posts.postRemoved called with { key, ...payload }\n}\n```\nThis will trigger the signal `posts.postRemoved` whenever a post is removed from the selection. The signal is triggered with the payload: `{ key: 'someKey' }`.\n\nTo stop listening:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('posts', 'onChildRemoved');\n}\n```\n\n### operator\n```javascript\nimport {onChildRemoved} from '@cerebral/firebase/operators'\nimport {string, signal} from 'cerebral/tags'\n\nexport default [\n  onChildRemoved(string`foo.bar`, signal`some.signal`, {\n    // Same options as above\n  })\n]\n```\n\n## onValue\n\n### action\n```js\nfunction someAction({ firebase }) {\n  firebase.onValue('someKey.foo', 'someModule.fooUpdated',  {\n    payload: {}, // Merged with the payload passed on new data\n  })\n  // someModule.fooUpdate called with { value, ...payload }\n}\n```\n\nThis will **NOT** immediately grab the value and trigger the signal passed, the first event is discarded for more predictable behaviour. To grab existing value, just use `value`.\n\nTo stop listening for updates to the value:\n```js\nfunction someAction({ firebase }) {\n  firebase.off('someKey.foo', 'onValue');\n}\n```\n\n### operator\n```javascript\nimport {onValue} from '@cerebral/firebase/operators'\nimport {string, signal} from 'cerebral/tags'\n\nexport default [\n  onValue(string`foo.bar`, signal`some.signal`)\n]\n```\n\n## push\nGenerates a new child location using a unique key and returns its reference from the action. An example being `{key: \"-KWKImT_t3SLmkJ4s3-w\"}`.\n\n### action\n```javascript\nfunction someAction({firebase}) {\n  return firebase.push('users', {\n    name: 'Bob'\n  })\n    .then((response) => {\n      /*\n        {\n          key: 'someKey'\n        }\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {push} from '@cerebral/firebase/operators'\n\nexport default [\n  push('users', state`newUser`),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {push} from '@cerebral/firebase/operators'\n\nexport default [\n  push('users', state`newUser`), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n*output*\n```javascript\n{key: 'theAddedKey'}\n```\n\n## put\n\nUpload a new file at the given location. Please note that the file is **not** stored inside the realtime database but into Google Cloud Storage (please consult filrebase documentation). This means that you need to take care of storage security as well.\n\nNote that `put` expects a folder as first argument and will use the name of the provided file. If you want to control the filename, add this in the options. In this case, make sure to respect file type and extension...\n\n### action\n```js\nfunction someAction({ firebase, props }) {\n  return firebase.put('folderName', props.file, {\n    progress({progress, bytesTransferred, totalBytes, state}) {\n      /* do whatever */\n    },\n    // Override name, make sure you set same extension\n    filename: 'customName.png'\n    // optional payload added to progress callback\n    { type: 'avatar'\n    }\n  })\n    .then((response) => {\n      /*\n        {\n          url: 'urlToFile',\n          filename: 'nameOfFile'\n          ... payload\n        }\n      */\n    })\n}\n```\n\n### operator\n```js\nimport {props, signal, string, state} from 'cerebral/tags'\nimport {put} from '@cerebral/firebase/operators'\n\n// we expect props.file to contain a file provided by\n// a user in an <input type='file' />\nexport default [\n  put(string`posts.all.${props`postId`}`, props`file`, {\n    // Trigger a signal which receives payload\n    progress: signal`gallery.progress`\n    // Set progress on a state value\n    progress: state`gallery.progress`\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {props, signal, string, state} from 'cerebral/tags'\nimport {put} from '@cerebral/firebase/operators'\n\n// we expect props.file to contain a file provided by\n// a user in an <input type='file' />\nexport default [\n  put(string`posts.all.${props`postId`}`, props`file`, {\n    progress: signal`gallery.progress`\n    progress: state`gallery.progress`\n  }), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## remove\nRemove the data at this database location.\n\n### action\n```javascript\nfunction someAction({ firebase}) {\n  return firebase.remove('foo.bar')\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {props, string} from 'cerebral/tags'\nimport {remove} from '@cerebral/firebase/operators'\n\nexport default [\n  remove(string`users.${props`userKey`}`),\n  // No output\n]\n```\n\n### operator with paths\n```javascript\nimport {props, string} from 'cerebral/tags'\nimport {remove} from '@cerebral/firebase/operators'\n\nexport default [\n  remove(string`users.${props`userKey`}`), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## sendPasswordResetEmail\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.sendPasswordResetEmail(state.get('user.email'))\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {sendPasswordResetEmail} from '@cerebral/firebase/operators'\n\nexport default [\n  sendPasswordResetEmail(state`user.email`),\n  // No output\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {sendPasswordResetEmail} from '@cerebral/firebase/operators'\n\nexport default [\n  sendPasswordResetEmail(state`user.email`), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## set\nWrite data to this database location. This will overwrite any data at this location and all child locations. Passing **null** for the new value is equivalent to calling remove(); all data at this location or any child location will be deleted.\n\n### action\n```javascript\nfunction someAction({firebase}) {\n  return firebase.set('foo.bar', 'baz')\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {props} from 'cerebral/tags'\nimport {set} from '@cerebral/firebase/operators'\n\nexport default [\n  set('foo.bar', props`foo`),\n  // No output\n]\n```\n\n### operator with paths\n```javascript\nimport {props} from 'cerebral/tags'\nimport {set} from '@cerebral/firebase/operators'\n\nexport default [\n  set('foo.bar', props`foo`), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## setOnDisconnect\nSets a value when Firebase detects user has disconnected.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  firebase.setOnDisconnect(`activeUsers.${state.get('app.user.uid')}`, 'someValue')\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {setOnDisconnect} from '@cerebral/firebase/operators'\n\nexport default [\n  setOnDisconnect(string`activeUsers.${state`app.user.uid`}`, null)\n]\n```\n\n## signInAnonymously\nThis login will method will resolve to existing anonymous or create a new one for you.\n\n### action\n```js\nfunction someAction({ firebase }) {\n  return firebase.signInAnonymously()\n    .then((user) => {\n      /*\n        name: 'Bob',\n        ...\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {signInAnonymously} from '@cerebral/firebase/operators'\n\nexport default [\n  signInAnonymously(),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {signInAnonymously} from '@cerebral/firebase/operators'\n\nexport default [\n  signInAnonymously(), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## signInWithCustomToken\nSign in a custom token.\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.signInWithCustomToken(state.get('token'))\n}\n```\n\n*factory*\n```javascript\nimport {props, state} from 'cerebral/tags'\nimport {signInWithCustomToken} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithCustomToken(props`token`),\n\n  // Alternatively with explicit paths\n  signInWithCustomToken(state`token`), {\n    success: [],\n    error: []\n  }\n]\n```\n\n*output*\n```javascript\n{user: {}}\n```\n\n## signInWithEmailAndPassword\nSign in a user with email and password.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  const email = state.get('register.email')\n  const password = state.get('register.password')\n\n  return firebase.signInWithEmailAndPassword(email, password)\n    .then((response) => {\n      /*\n        name: 'Bob',\n        ...\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {props} from 'cerebral/tags'\nimport {signInWithEmailAndPassword} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithEmailAndPassword(props`email`, props`password`),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {props} from 'cerebral/tags'\nimport {signInWithEmailAndPassword} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithEmailAndPassword(props`email`, props`password`), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## signInWith{PROVIDER}\nSign in a user with Facebook, Google or Github.\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.signInWithFacebook({\n    redirect: false, // Use popup or redirect. Redirect typically for mobile\n    scopes: [] // Facebook scopes to access\n  })\n    .then((response) => {\n      /*\n        name: 'Bob',\n        ...\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {state} from 'cerebral/tags'\nimport {signInWithFacebook} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithFacebook({\n    redirect: state`useragent.media.small`\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {state} from 'cerebral/tags'\nimport {signInWithFacebook} from '@cerebral/firebase/operators'\n\nexport default [\n  signInWithFacebook({\n    redirect: state`useragent.media.small`\n  }), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\nSimilar you can sign in with Google or GitHub.\nJust use `signInWithGoogle` or `signInWithGithub` instead of `signInWithFacebook`.\n\n## signOut\nSign out user. **getUser** will now not resolve a user anymore.\n\n### action\n```js\nfunction someAction({ firebase }) {\n  return firebase.signOut()\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {signOut} from '@cerebral/firebase/operators'\n\nexport default [\n  signOut(),\n  // No output\n]\n```\n\n### operator with paths\n```javascript\nimport {signOut} from '@cerebral/firebase/operators'\n\nexport default [\n  signOut(), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## task\nIf you are using the [firebase-queue](https://github.com/firebase/firebase-queue) and need to create tasks, you can do that with:\n\n### action\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.task('create_post', {\n    uid: state.get('app.user.uid'),\n    text: state.get('posts.newPostText')\n  })\n    .then(() => {\n      // No output\n    })\n}\n```\n\nThis will add a task at `queue/tasks`. There is no output from a resolved task, it just resolves when the action has been processed.\n\n### operator\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {task} from '@cerebral/firebase/operators'\n\nexport default [\n  task('some_task', {\n    uid: state`user.uid`,\n    data: props`data`\n  }),\n  // No output\n\n  // Alternatively with explicit paths\n  task('some_task', {\n    uid: state`user.uid`,\n    data: props`data`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### operator with paths\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {task} from '@cerebral/firebase/operators'\n\nexport default [\n  task('some_task', {\n    uid: state`user.uid`,\n    data: props`data`\n  }), {\n    success: [\n      // No output\n    ],\n    error: [\n      // No output\n    ]\n  }\n]\n```\n\n## transaction\nAtomically modifies the data at the provided location.\n\nUnlike a normal set(), which just overwrites the data regardless of its previous value, transaction() is used to modify the existing value to a new value, ensuring there are no conflicts with other clients writing to the same location at the same time.\n\nTo accomplish this, you pass transaction() an update function which is used to transform the current value into a new value. If another client writes to the location before your new value is successfully written, your update function will be called again with the new current value, and the write will be retried. This will happen repeatedly until your write succeeds without conflict or you abort the transaction by not returning a value from your update function.\n\n### action\n```javascript\nfunction someAction({firebase}) {\n\n  function transactionFunction(currentData){\n    if (currentData === null) {\n      return { foo: 'bar' }\n    }\n\n    return // Abort the transaction.\n  }\n\n  return firebase.transaction('some.transaction.path', transactionFunction)\n    .then((result) => {\n      if(result.committed){\n        return {result: result.value}\n      } else {\n        throw new Error('Transaction failed')\n      }\n    })\n      .then((response) => {\n        /*\n          {\n            committed: true,\n            value: 'new value'\n          }\n        */\n      })\n}\n```\n\nThis will add a task at `queue/tasks`. There is no output from a resolved task, it just resolves when the action has been processed.\n\n### operator\n```javascript\nimport {transaction} from '@cerebral/firebase/operators'\n\nfunction transactionFunction() {...}\n\nexport default [\n  transaction('foo.bar', transactionFunction),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```javascript\nimport {transaction} from '@cerebral/firebase/operators'\n\nfunction transactionFunction() {...}\n\nexport default [\n  transaction('foo.bar', transactionFunction), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      // No output\n    ]\n  }\n]\n```\n\nNote: Modifying data with set() will cancel any pending transactions at that location, so extreme care should be taken if mixing set() and transaction() to update the same data.\n\nNote: When using transactions with Security and Firebase Rules in place, be aware that a client needs .read access in addition to .write access in order to perform a transaction. This is because the client-side nature of transactions requires the client to read the data in order to transactionally update it.\n\n## update\nAs opposed to the set() method, update() can be use to selectively update only the referenced properties at the current location (instead of replacing all the child properties at the current location).\n\n### action\n```javascript\nfunction someAction({firebase}) {\n  return firebase.update('some.path', {\n    'foo': 'bar',\n    'items.item1.isAwesome': true\n  })\n    .then(() => {\n      // No output\n    })\n}\n```\n\n### operator\n```javascript\nimport {props} from 'cerebral/tags'\nimport {update} from '@cerebral/firebase/operators'\n\nexport default [\n  update('some.path', {\n    'foo.bar': props`bar`,\n    'foo.baz': props`baz`\n  }),\n  // No output\n\n  // Alternatively with explicit paths\n  update('some.path', {\n    'foo.bar': props`bar`,\n    'foo.baz': props`baz`\n  }), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### operator with paths\n```javascript\nimport {props} from 'cerebral/tags'\nimport {update} from '@cerebral/firebase/operators'\n\nexport default [\n  update('some.path', {\n    'foo.bar': props`bar`,\n    'foo.baz': props`baz`\n  }), {\n    success: [\n      // No output\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n\n## value\n\n### action\n```js\nfunction someAction({ firebase }) {\n  return firebase.value('someKey.foo')\n    .then((response) => {\n      /*\n        {\n          key: 'foo',\n          value: 'some value'\n        }\n      */\n    })\n}\n```\n\n### operator\n```javascript\nimport {value} from '@cerebral/firebase/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  value('foo.bar'),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n  // Alternatively with explicit paths\n  value('foo.bar'), {\n    success: [],\n    error: []\n  }\n]\n```\n\n### operator with paths\n```javascript\nimport {value} from '@cerebral/firebase/operators'\n\nexport default [\n  value('foo.bar'), {\n    success: [\n      /* PROPS: { response: {...} } */\n    ],\n    error: [\n      /* PROPS: { error: {...} } */\n    ]\n  }\n]\n```\n","title":"@cerebral/firebase"},"firebase_admin":{"raw":"# @cerebral/firebase-admin\n\n## Install\n**NPM**\n\n`npm install @cerebral/firebase-admin`\n\n## Description\nThe firebase admin package for function-tree allows you to easily handle Firebase Queues. With the Cerebral debugger you will even be able to merge execution data cross client/server. This package helps you set up a **QueueHandler** which registers your specs with queues and lets you know when new tasks are ready to be run.\n\n## provider\nFirst you create a function tree with the Firebase provider. You will need to add the Devtools with the same port as the client to merge execution.\n\n```js\nconst FunctionTree = require('function-tree').FunctionTree\nconst Devtools = require('function-tree/devtools')\nconst FirebaseProvider = require('@cerebral/firebase-admin').Provider\n\nconst devtools = Devtools({\n  // Connect to same port as the client to merge execution\n  host: 'localhost:8787'\n})\n\nconst runTask = new FunctionTree([\n  devtools.Provider(),\n  FirebaseProvider({\n    serviceAccount: {} // your service account details\n    databaseURL: '', // Your database url\n  })\n  /* Your other providers */\n])\n\ndevtools.watchExecution(runTask)\n\nmodule.exports = runTask\n```\n\n\n### createKey\nCreate a new Firebase key at some path.\n```js\nfunction authenticate (context) {\n  const newKey = context.firebase.createKey('some/path')\n}\n```\n\n### deleteUser\nDelete a user from Firebase. Outputs nothing.\n```js\nfunction deleteProfile (context) {\n  return context.firebase.deleteUser(context.props.uid)\n}\n```\n\n### push\nPush new data. Outputs {key: 'keyAdded'}.\n```js\nfunction addItem (context) {\n  return context.firebase.push('items', context.props.data.item)\n}\n```\n\n### remove\nRemove key. Outputs nothing.\n```js\nfunction removeItem (context) {\n  return context.firebase.remove(`items/${context.props.itemKey}`)\n}\n```\n\n### set\nSet new data. Output nothing.\n```js\nfunction addItem (context) {\n  return context.firebase.set(`items/${context.props.data.itemKey}`, context.props.data.item)\n}\n```\n\n### transaction\nRun a transaction. Outputs nothing.\n```js\nfunction updateItems (context) {\n  return context.firebase.transaction('some/path', (maybeValue) => {\n    if (!maybeValue) {\n      return 'bar'\n    }\n\n    return context.props.data.foo\n  })\n}\n```\n\n### update\nUpdate multiple paths from top level or at specific path. Outputs nothing.\n```js\nfunction updateItems (context) {\n  return context.firebase.update({\n    'items/1': context.props.data.item1Data,\n    'items/2': context.props.data.item2Data\n  })\n}\n```\n\n```js\nfunction updateItems (context) {\n  return context.firebase.update('items', {\n    '1': context.props.data.item1Data,\n    '2': context.props.data.item2Data\n  })\n}\n```\n\n### value\nGet value. Outputs {key: 'theKey', value: 'theValue'}.\n```js\nfunction updateItems (context) {\n  return context.firebase.value('some/path')\n}\n```\n\n\n## queueHandler\nThe QueueHandler is responsible for registering Firebase Queues with your defined specs and what trees should run when new tasks arrive in Firebase. The QueueHandler also automatically authenticates the tasks using **verifyIdToken**.\n\n```js\nconst runTask = require('./runTask')\nconst firebase = require('firebase-admin')\nconst username = require('username')\nconst QueueHandler = require('@cerebral/firebase-admin').QueueHandler\n\nmodule.exports = new QueueHandler({\n  // If you are using a specPrefix on the client during development\n  // you will have to use it here as well, to pick up the correct\n  // queue tasks. It is automatically removed in production\n  specPrefix: username.sync(),\n\n  // You can specify if you want to authenticate or not.\n  // default is false\n  authenticate: true,\n\n  // An array of specs and corresponding trees to run\n  tasks: [{\n    specId: 'some_spec_name',\n    numWorkers: 100,\n    tree: [\n      /* Some tree to run */\n    ]\n  }],\n\n  // A reference in Firebase to your queue\n  queueRef: firebase.database().ref('queue')\n}, (specId, tree, payload) => {\n  runTask.run(specId, tree, payload)\n    .catch((error) => {\n      // Handle error. Payload has error property with details\n      runTask.run('ERROR', [/* A tree handling errors */], error.payload)\n    })\n});\n```\n\nWhen a task runs you have access to the following **props**:\n\n```js\nfunction someFunc (context) {\n  context.props.uid // Uid of user who made the task\n  context.props.data // Data passed from client\n  context.props.task.resolve // Resolve the task\n  context.props.task.reject // Reject the task\n}\n```\n\n## task\nIf you are using the [firebase-queue](https://github.com/firebase/firebase-queue) and need to create tasks, you can do that with:\n\n*action*\n```js\nfunction someAction({ firebase, state }) {\n  return firebase.task('create_post', {\n    uid: state.get('app.user.uid'),\n    text: state.get('posts.newPostText')\n  })\n}\n```\n\nThis will add a task at `queue/tasks`. There is no output from a resolved task, it just resolves when the action has been processed.\n\n## testTasks\nYou can easily test tasks. The TestTasks includes a local [firebase-server](https://github.com/urish/firebase-server) and allows you to define a state of your Firebase instance before running tasks and assert its state after the tasks are run.\n\n```js\nconst TestTasks = require('@cerebral/firebase-admin').TestTasks\n\nconst testTasks = new TestTasks([\n  /* Any mocked providers */\n])\n\nmodule.exports = testTasks\n```\n\nIn your test framework of choice:\n\n```js\nconst someTreeToRun = require('./someTreeToRun')\nconst test = require('./testTasks');\nconst assert = require('assert');\n\ndescribe('example', () => {\n  it('should test for foo', (done) => {\n    const runTest = test.create({\n      foo: 'bar'\n    }, {\n      // The tree to be run\n      task: someTreeToRun,\n\n      // Data to pass into tree execution\n      data: {\n        bip: 'bop'\n      }\n    }, (data) => {\n      assert.equal(data.foo, 'bar')\n    });\n\n    runTest(done)\n  })\n})\n```\n\nRun multiple tasks:\n\n```js\nconst someTreeToRun = require('./someTreeToRun')\nconst test = require('./testTasks');\nconst assert = require('assert');\n\ndescribe('example', () => {\n  it('should test for foo', (done) => {\n    const runTest = test.create({\n      foo: 'bar'\n    }, [{\n      task: someTreeToRun,\n      data: {\n        foo: 'bop'\n      },\n      // You can do assertions between running tasks\n      assert (data) {\n        assert.equal(data.foo, 'bop')\n      }\n    }, {\n      task: someTreeToRun,\n      data: {\n        foo: 'bap'\n      }\n    }], (data) => {\n      assert.equal(data.foo, 'bap')\n    });\n\n    runTest(done)\n  })\n})\n```\n","title":"@cerebral/firebase-admin"},"forms":{"raw":"# @cerebral/forms\n\n## Install\n**NPM**\n\n`npm install @cerebral/forms`\n\n## Description\nThe forms provider allows you to easily compute forms based on a number of rules. Easily add new rules, error messages and, if you want, add whatever you want to your fields for custom logic.\n\n## Instantiate\n\n```javascript\nimport {Controller} from 'cerebral'\nimport FormsProvider from '@cerebral/forms'\n\nconst controller = Controller({\n  providers: [\n    FormsProvider({\n      // Add additional rules\n      rules: {\n        myAddedRule (value, arg, get) {\n          // value of the field\n          value\n          // arg passed to the rule\n          arg\n          // The \"get\" argument from computed. Use it to grab\n          // state or props passed to component. The component\n          // will track use of these dependencies for rerender\n          get\n\n          return true\n        }\n      },\n\n      // errorMessage property added to field when invalid with the following rules\n      errorMessages: {\n        minLength (value, minLength) {\n          return `The length is ${value.length}, should be equal or more than ${minLength}`\n        }\n      }\n    })\n  ]\n})\n```\n\n## compute\nTo use a form you use the **form** computed, pointing to the form. Typically:\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {form} from '@cerebral/forms'\n\nexport default connect({\n  form: form(state`path.to.form`)\n},\n  function MyForm ({form}) {\n    // Value of some field\n    form.someField.value\n    // A true/false if field has a value\n    form.someField.hasValue\n    // A true/false if field has been changed\n    form.someField.isPristine\n    // A true/false if field is valid\n    form.someField.isValid\n    // The name of the rule that failed\n    form.someField.failedRule.name\n    // Any arg you passed to the failing rule\n    form.someField.failedRule.arg\n    // If you have defined global error messages and field is invalid\n    form.someField.errorMessage\n    // Get all invalid fields\n    form.getInvalidFields()\n    // Get all fields\n    form.getFields()\n  }\n)\n```\n\nYou can also use the **field** computed, pointing to the field. This will optimize rendering as only the field will render on change.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {field} from '@cerebral/forms'\n\nexport default connect({\n  field: field(state`path.to.form.name`)\n},\n  function MyField ({field}) {\n    // Value of some field\n    field.value\n    // A true/false if field has a value\n    field.hasValue\n    // A true/false if field has been changed\n    field.isPristine\n    // A true/false if field is valid\n    field.isValid\n  }\n)\n```\n\n## defaultValue\nYou can define a default value for your fields. When the form is **reset**, it will put back the default value:\n\n```js\n{\n  myForm: {\n    firstName: {\n      value: '',\n      defaultValue: 'Ben'\n    }\n  }\n}\n```\n\n## field\nA field is just an object with a `value` property:\n\n```js\n{\n  myForm: {\n    myField: {\n      value: ''\n    }\n  }\n}\n```\n\n## form\nA form is just an object in the state tree:\n\n```js\n{\n  myForm: {}\n}\n```\n\n## isRequired\nDefine field as required. This will make the field invalid if there is no value. By default forms identifies a value or not\nusing the **isValue** rule. You can change this rule if you want, look below.\n\n```js\n{\n  myForm: {\n    firstName: {\n      value: '',\n      isRequired: true\n    }\n  }\n}\n```\n\n## isValueRules\nYou can change what defines a field as having a value. For example if your value is an array, you can use the **minLength** rule to\ndefine a required minimum of 3 items in the array.\n\n```js\n{\n  myForm: {\n    interests: {\n      value: [],\n      isRequired: true,\n      isValueRules: ['minLength:3']\n    }\n  }\n}\n```\n\n## nesting\nYou can nest this however you want, even with array:\n\n```js\n{\n  myForm: {\n    firstName: {value: ''},\n    lastName: {value: ''},\n    address: [{\n      street: {value: ''},\n      zipCode: {value: ''}\n    }],\n    interests: {\n      books: {value: false},\n      films: {value: false}\n    }\n  }\n}\n```\n\n## operators\n\n### isValidForm\nDiverge execution based on validity of a form.\n\n```js\nimport {state} from 'cerebral/tags'\nimport {isValidForm} from '@cerebral/forms/operators'\n\nexport default [\n  isValidForm(state`my.form`) {\n    true: [],\n    false: []\n  }\n]\n```\n\n### resetForm\nReset a form.\n\n```js\nimport {state} from 'cerebral/tags'\nimport {resetForm} from '@cerebral/forms/operators'\n\nexport default [\n  resetForm(state`my.form`)\n]\n```\n\n### setField\nWhen you change the value of a field you will need to use this operator. Note that you point to the field, not the field value.\n\n```js\nimport {state, props} from 'cerebral/tags'\nimport {setField} from '@cerebral/forms/operators'\n\nexport default [\n  setField(state`my.form.field`, props`value`)\n]\n```\n\n## provider\nYou can also access your forms in actions.\n\n```js\nfunction myAction ({forms}) {\n  const form = forms.get('path.to.form')\n}\n```\n\n### reset\nReset the form to its default values (or empty string by default).\n\n```js\nfunction myAction ({forms}) {\n  forms.reset('path.to.form')\n}\n```\n\n### toJSON\nTypically you want to convert your forms to a plain value structure.\n\n```js\nfunction myAction ({forms}) {\n  const form = forms.toJSON('path.to.form')\n}\n```\n\nThis form will now have the structure of:\n\n```js\n{\n  myField: 'theValue',\n  address: {\n    street: 'street value',\n    zipCode: 'zip code value'\n  }\n}\n```\n\n### updateErrorMessages\nDynamically update global error messages:\n\n```js\nfunction myAction ({forms}) {\n  forms.updateErrorMessages({\n    someRule () {}\n  })\n}\n```\n\n### updateRules\nDynamically update available rules:\n\n```js\nfunction myAction ({forms}) {\n  forms.updateRules({\n    someNewRule () {}\n  })\n}\n```\n\n## validationRules\nYou add validation rules on the field:\n\n```js\n{\n  myForm: {\n    firstName: {\n      value: '',\n      validationRules: ['minLength:3']\n    }\n  }\n}\n```\n\n### equals:Value\n```js\n{\n  field1: {\n    value: 123, // valid\n    validationRules: ['equals:123']\n  },\n  field2: {\n    value: '123', // valid\n    validationRules: ['equals:\"123\"']\n  },\n  field3: {\n    value: [], // not valid\n    validationRules: ['equals:[]']\n  }\n}\n```\n\n### equalsField:Field\n```js\n{\n  field1: {\n    value: 'foo', // valid\n    validationRules: ['equalsField:full.path.to.form.field2']\n  },\n  field2: {\n    value: 'foo', // valid\n    validationRules: ['equalsField:full.path.to.form.field1']\n  },\n  field3: {\n    value: 'bar', // not valid\n    validationRules: ['equalsField:full.path.to.form.field2']\n  }\n}\n```\n\n### isAlpha\n```js\n{\n  field1: {\n    value: 'abc', // valid\n    validationRules: ['isAlpha']\n  },\n  field2: {\n    value: 'AbC', // valid\n    validationRules: ['isAlpha']\n  },\n  field3: {\n    value: '123abc', // not valid\n    validationRules: ['isAlpha']\n  }\n}\n```\n\n### isAlphanumeric\n```js\n{\n  field1: {\n    value: '123abc', // valid\n    validationRules: ['isAlphanumeric']\n  },\n  field2: {\n    value: '123', // valid\n    validationRules: ['isAlphanumeric']\n  },\n  field3: {\n    value: '123+abc', // not valid\n    validationRules: ['isAlphanumeric']\n  }\n}\n```\n\n### isEmail\n```js\n{\n  field1: {\n    value: 'ho@hep.co', // valid\n    validationRules: ['isEmail']\n  },\n  field2: {\n    value: 'hello@', // not valid\n    validationRules: ['isEmail']\n  },\n  field3: {\n    value: 'hel.co', // not valid\n    validationRules: ['isEmail']\n  }\n}\n```\n\n### isEmpty\n```js\n{\n  field1: {\n    value: '', // valid\n    validationRules: ['isEmpty']\n  },\n  field2: {\n    value: 'hello', // not valid\n    validationRules: ['isEmpty']\n  },\n  field3: {\n    value: 123, // not valid\n    validationRules: ['isEmpty']\n  }\n}\n```\n\n### isExisty\n```js\n{\n  field1: {\n    value: 0, // valid\n    validationRules: ['isExisty']\n  },\n  field2: {\n    value: [], // valid\n    validationRules: ['isExisty']\n  },\n  field3: {\n    value: null, // not valid\n    validationRules: ['isExisty']\n  }\n}\n```\n\n### isFalse\n```js\n{\n  field1: {\n    value: false, // valid\n    validationRules: ['isFalse']\n  },\n  field2: {\n    value: 'false', // not valid\n    validationRules: ['isFalse']\n  },\n  field3: {\n    value: true, // not valid\n    validationRules: ['isFalse']\n  }\n}\n```\n\n### isFloat\n```js\n{\n  field1: {\n    value: '22.5', // valid\n    validationRules: ['isFloat']\n  },\n  field2: {\n    value: 22.5, // valid\n    validationRules: ['isFloat']\n  },\n  field3: {\n    value: '22', // not valid\n    validationRules: ['isFloat']\n  }\n}\n```\n\n\n### isInt\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['isInt']\n  },\n  field2: {\n    value: 123, // valid\n    validationRules: ['isInt']\n  },\n  field3: {\n    value: '22.5', // not valid\n    validationRules: ['isInt']\n  }\n}\n```\n\n### isLength:Number\n```js\n{\n  field1: {\n    value: 'hey', // valid\n    validationRules: ['isLength:3']\n  },\n  field2: {\n    value: ['foo', 'bar'], // valid\n    validationRules: ['isLength:2']\n  },\n  field3: {\n    value: 'hm 123', // not valid\n    validationRules: ['isLength:3']\n  }\n}\n```\n\n\n### isNumeric\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['isNumeric']\n  },\n  field2: {\n    value: 123, // valid\n    validationRules: ['isNumeric']\n  },\n  field3: {\n    value: '123abc', // not valid\n    validationRules: ['isNumeric']\n  }\n}\n```\n\n### isSpecialWords\n```js\n{\n  field1: {\n    value: 'hey there', // valid\n    validationRules: ['isSpecialWords']\n  },\n  field2: {\n    value: 'some  åäö', // valid\n    validationRules: ['isSpecialWords']\n  },\n  field3: {\n    value: 'hm 123', // not valid\n    validationRules: ['isSpecialWords']\n  }\n}\n```\n\n### isTrue\n```js\n{\n  field1: {\n    value: true, // valid\n    validationRules: ['isTrue']\n  },\n  field2: {\n    value: 'true', // not valid\n    validationRules: ['isTrue']\n  },\n  field3: {\n    value: false, // not valid\n    validationRules: ['isTrue']\n  }\n}\n```\n\n### isUndefined\n```js\n{\n  field1: {\n    value: undefined, // valid\n    validationRules: ['isUndefined']\n  },\n  field2: {\n    value: 'hello', // not valid\n    validationRules: ['isUndefined']\n  },\n  field3: {\n    value: 123, // not valid\n    validationRules: ['isUndefined']\n  }\n}\n```\n\n### isUrl\n```js\n{\n  field1: {\n    value: 'http://www.test.com', // valid\n    validationRules: ['isUrl']\n  },\n  field2: {\n    value: 'http://www', // not valid\n    validationRules: ['isUrl']\n  },\n  field3: {\n    value: 'http//www', // not valid\n    validationRules: ['isUrl']\n  }\n}\n```\n\n### isWords\n```js\n{\n  field1: {\n    value: 'hey there', // valid\n    validationRules: ['isWords']\n  },\n  field2: {\n    value: 'wut åäö', // not valid\n    validationRules: ['isWords']\n  },\n  field3: {\n    value: 'hm 123', // not valid\n    validationRules: ['isWords']\n  }\n}\n```\n\n### isValue\n```js\n{\n  field1: {\n    value: 'test', // valid\n    validationRules: ['isValue']\n  },\n  field2: {\n    value: [], // not valid\n    validationRules: ['isValue']\n  },\n  field3: {\n    value: null, // not valid\n    validationRules: ['isValue']\n  },\n  field3: {\n    value: false, // not valid\n    validationRules: ['isValue']\n  }\n}\n```\n\n### maxLength:Number\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['maxLength:3']\n  },\n  field2: {\n    value: 'fo', // valid\n    validationRules: ['maxLength:3']\n  },\n  field3: {\n    value: ['foo', 'bar', 'baz', 'mip'], // not valid\n    validationRules: ['maxLength:3']\n  }\n}\n```\n\n### minLength:Number\n```js\n{\n  field1: {\n    value: '123', // valid\n    validationRules: ['minLength:3']\n  },\n  field2: {\n    value: 'fo', // not valid\n    validationRules: ['minLength:3']\n  },\n  field3: {\n    value: ['foo', 'bar', 'baz', 'mip'], // valid\n    validationRules: ['minLength:3']\n  }\n}\n```\n\n### regexp\n```js\n{\n  field1: {\n    value: 'foo', // valid\n    validationRules: [/foo/]\n  },\n  field2: {\n    value: 'bar', // not valid\n    validationRules: [/foo/]\n  }\n}\n```\n","title":"@cerebral/forms"},"http":{"raw":"# @cerebral/http\n\n## Install\n**NPM**\n\n`npm install @cerebral/http`\n\n## Description\nThe HTTP provider exposes the ability to do HTTP requests both in actions and directly in signals. It supports **cors** and file upload, with progress handling. It default to **json**, but you can configure it to whatever you want.\n\nRead more about http in the [Cerebral in depth - Http](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_http) article.\n\n```js\nimport {set} from 'cerebral/operators'\nimport {httpGet} from '@cerebral/http/operators'\nimport {state, props, string} from 'cerebral/tags'\n\nexport default [\n  httpGet(string`/items/${props`itemKey`}`),\n  set(state`app.currentItem`, props`result`)\n]\n```\n\nAll factories of HTTP provider supports template tags.\n\n## Instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport HttpProvider from '@cerebral/http'\n\nconst controller = Controller({\n  providers: [\n    HttpProvider({\n      // Prefix all requests with this url\n      baseUrl: 'https://api.github.com',\n\n      // Any default headers to pass on requests\n      headers: {\n        'Content-Type': 'application/json; charset=UTF-8',\n        'Accept': 'application/json'\n      },\n\n      // When talking to cross origin (cors), pass cookies\n      // if set to true\n      withCredentials: false\n    })\n  ]\n})\n```\n\nYou can update these default options in an action:\n\n```js\nfunction updateDefaultHttpOptions({http}) {\n  http.updateOptions({\n    // Updated options\n  })\n}\n```\n\n## abort\nYou can abort any running request, causing the request to resolve as status code **0** and set an **isAborted** property on the response object.\n\n```js\nfunction searchItems({input, state, path, http}) {\n  http.abort('/items*') // regexp string\n  return http.get(`/items?query=${input.query}`)\n    .then(path.success)\n    .catch((error) => {\n      if (error.isAborted) {\n        return path.abort()\n      }\n\n      return path.error({error})\n    })\n}\n\nexport default [\n  searchItems, {\n    success: [],\n    error: [],\n    abort: []\n  }\n]\n```\n\n## cors\nCors has been turned into a \"black box\" by jQuery. Cors is actually a very simple concept, but due to a lot of confusion of \"Request not allowed\", **cors** has been an option to help out. In HttpProvider we try to give you the insight to understand how cors actually works.\n\nCors has nothing to do with the client. The only client configuration related to cors is the **withCredentials** option, which makes sure cookies are passed to the cross origin server. The only requirement for cors to work is that you pass the correct **Content-Type**. Now, this depends on the server in question. Some servers allows any content-type, others require a specific one. These are the typical ones:\n\n- text/plain\n- application/x-www-form-urlencoded\n- application/json; charset=UTF-8\n\nNote that this is only related to the **request**. If you want to define what you want as response, you set the **Accept** header, which is *application/json* by default.\n\n## errors\n\n### HttpProviderError\n\n```js\nimport {HttpProviderError} from '@cerebral/http'\n\n// Error structure\n{\n  name: 'HttpProviderError',\n  message: 'Some error message or responseText',\n  response: {\n    result: {}, // Parsed responseText\n    headers: {},\n    status: 200,\n    isAborted: false\n  },\n  stack: '...'\n}\n```\n\nThis error is available in the following scenarios:\n\n- Inside an action\n\n```js\nfunction someAction ({http}) {\n  return http.get('/something').catch(error => ...)\n}\n```\n\n- Going down an error path\n\n```js\n[\n  httpGet('/something'), {\n    success: [],\n    error: [\n      // {error: ...}\n    ]\n  }\n]\n```\n\n- To signal/global catch handlers\n\n```js\nconst errorCatched = [\n  // {error: ...}\n  displayError\n]\n\nController({\n  catch: new Map([\n    [HttpProviderError, errorCatched]\n  ])\n})\n```\n\n## delete\n\n### action\n```js\nfunction someDeleteAction ({http}) {\n  const query = {}\n  const options = {}\n\n  return http.delete('/items/1', query, options)\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpPost} from '@cerebral/http/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  httpDelete(string`/items/${state`currentItemId`}`),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {httpPost} from '@cerebral/http/operators'\nimport {state} from 'cerebral/tags'\n\nexport default [\n  httpDelete(string`/items/${state`currentItemId`}`), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## get\n\n### action\n```js\nfunction someGetAction ({http}) {\n  const query = {}\n  const options = {}\n\n  return http.get('/items', query, options)\n    .then((response) => {\n      return {someResponse: response}\n    })\n    .catch((error) => {\n      return {someError: error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpGet} from '@cerebral/http/operators'\n\nexport default [\n  httpGet('/items'),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\nOn error this will throw to the signal or global catch handler.\n\n### operator with paths\n```js\nimport {httpGet} from '@cerebral/http/operators'\n\nexport default [\n  httpGet('/items'), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## patch\n\n### action\n```js\nfunction somePatchAction ({http}) {\n  const data = {}\n  const options = {}\n\n  return http.patch('/items/1', data, options)\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpPatch} from '@cerebral/http/operators'\nimport {state, props, string} from 'cerebral/tags'\n\nexport default [\n  httpPatch(string`/items/${props`itemId`}`, state`patchData`),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {httpPatch} from '@cerebral/http/operators'\nimport {state, props, string} from 'cerebral/tags'\n\nexport default [\n  httpPatch(string`/items/${props`itemId`}`, state`patchData`), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## post\n\n### action\n```js\nfunction somePostAction ({http}) {\n  const data = {}\n  const options = {}\n\n  return http.post('/items', data, options)\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpPost} from '@cerebral/http/operators'\nimport {props} from 'cerebral/tags'\n\nexport default [\n  httpPost('/items', {\n    title: props`itemTitle`,\n    foo: 'bar'\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {httpPost} from '@cerebral/http/operators'\nimport {props} from 'cerebral/tags'\n\nexport default [\n  httpPost('/items', {\n    title: props`itemTitle`,\n    foo: 'bar'\n  }), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## put\n\n### action\n```js\nfunction somePutAction ({http}) {\n  const data = {}\n  const options = {}\n\n  return http.put('/items/1', data, options)\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpPost} from '@cerebral/http/operators'\n\nexport default [\n  httpPut('/items', {\n    // data object\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n\n### operator with paths\n```js\nimport {httpPost} from '@cerebral/http/operators'\n\nexport default [\n  httpPut('/items', {\n    // data object\n  }), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n## responses\nThere are two types of responses from the HTTP provider. A **response** and an **error** of type *HttpProviderError*. A **response** will be received on status codes 200-299. Everything else is an **error**.\n\n### response\n```js\n{\n  result: 'the response body',\n  headers: {...},\n  status: 200,\n  isAborted: false\n}\n```\n\n### error\n```js\n{\n  name: 'HttpProviderError',\n  message: 'Some potential error message',\n  result: 'Message or response body',\n  status: 500,\n  isAborted: false,\n  headers: {},\n  stack: '...'\n}\n```\n\n## request\n\n```js\nfunction someGetAction ({http}) {\n  return http.request({\n    // Any http method\n    method: 'GET',\n\n    // Url you want to request to\n    url: '/items'\n\n    // Request body as object. Will automatically be stringified if json and\n    // urlEncoded if application/x-www-form-urlencoded\n    body: {},\n\n    // Query as object, will automatically be urlEncoded\n    query: {},\n\n    // If cross origin request, pass cookies\n    withCredentials: false,\n\n    // Any additional http headers, or overwrite default\n    headers: {},\n\n    // A function or signal path (foo.bar.requestProgressed) that\n    // triggers on request progress. Passes {progress: 45} etc.\n    onProgress: null\n  })\n}\n```\n\n## uploadFile\n\n### action\n```js\nfunction someDeleteAction ({http, props}) {\n  return http.uploadFile('/upload', props.files, {\n    name: 'filename.png', // Default to \"files\"\n    data: {}, // Additional form data\n    headers: {},\n    onProgress: 'some.signal.path' // Upload progress\n  })\n    .then((response) => {\n      return {response}\n    })\n    .catch((error) => {\n      return {error}\n    })\n}\n```\n\n### operator\n```js\nimport {httpUploadFile} from '@cerebral/http/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpUploadFile('/uploads', props`file`, {\n    name: state`currentFileName`\n  }), {\n    success: [\n      /* PROPS: {response: {...}} */\n    ],\n    error: [\n      /* PROPS: {error: {...}} */\n    ],\n    abort: [\n      /* PROPS: {error: {...}} */\n    ],\n\n    // Optionally any status code, ex. 404: []\n    '${STATUS_CODE}': [\n      /* PROPS: {response/error: {...}} */\n    ]\n  }\n]\n```\n\n### operator with paths\n```js\nimport {httpUploadFile} from '@cerebral/http/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  httpUploadFile('/uploads', props`file`, {\n    name: state`currentFileName`\n  }),\n  /*\n    PROPS: {\n      response: {...}\n    }\n  */\n]\n```\n","title":"@cerebral/http"},"storage":{"raw":"# @cerebral/storage\n\n## Install\n**NPM**\n\n`npm install @cerebral/storage`\n\n## Description\nThis module exposes local storage or session storage as a provider,\nwhere it by default parses and serializes to JSON.\n\n## Instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport StorageProvider from '@cerebral/storage'\n\nconst controller = Controller({\n  providers: [StorageProvider({\n    // instance of storage, can be window.localStorage / localStorage\n    // or window.sessionStorage / sessionStorage\n    target: localStorage\n    // Serializes and parses to JSON by default\n    json: true,\n    // Synchronize state when it changes\n    sync: {\n      'someStorageKey': 'some.state.path'\n    },\n    // Set prefix for storagekey \"somePrefix.someStorageKey\"\n    prefix: 'somePrefix'\n  })]\n})\n```\n\n## get\nGet data from storage.\n\n*action*\n```javascript\nfunction someAction({storage}) {\n  const data = storage.get('someKey')\n}\n```\n\n*operator*\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {getStorage} from '@cerebral/storage/operators'\n\nexport default [\n  getStorage('someKey'),\n  function someAction ({props}) {\n    props.value // Whatever was on \"someKey\"\n  }\n]\n```\n\n## remove\nRemove data from storage.\n\n*action*\n```javascript\nfunction someAction({storage}) {\n  storage.remove('someKey')\n}\n```\n\n*operator*\n```javascript\nimport {state} from 'cerebral/tags'\nimport {removeStorage} from '@cerebral/storage/operators'\n\nexport default [\n  removeStorage(state`currentStorageKey`)\n]\n```\n\n## set\nWrite data to storage.\n\n*action*\n```javascript\nfunction someAction({storage}) {\n  storage.set('someKey', {foo: 'bar'})\n}\n```\n\n*operator*\n```javascript\nimport {state, props} from 'cerebral/tags'\nimport {setStorage} from '@cerebral/storage/operators'\n\nexport default [\n  setStorage(state`currentStorageKey`, props`someData`)\n]\n```\n","title":"@cerebral/storage"},"shortcuts":{"raw":"# @cerebral/shortcuts\n\n## Install\n\n**NPM**\n\n`npm install @cerebral/shortcuts`\n\n## Description\nThis is a tiny module that allows you to bind keyboard shortcuts to Cerebral signals.\n\nIt's created using a very nice library called [\"shortway\" by Thiago Santos](https://github.com/thiamsantos/shortway)\n\n## Instantiate\n\n```javascript\n\nimport shortcuts from '@cerebral/shortcuts';\n\nconst controller = Controller({\n  signals: {\n    testSignal: () => console.log(\"shortcut pressed!\")\n  },\n  modules: {\n    shortcuts: shortcuts({\n      \"ctrl+s\": \"testSignal\"\n    })\n  }\n});\n\n```\n","title":"@cerebral/shortcuts"},"router":{"raw":"# @cerebral/router\n\n## Install\n**NPM**\n\n`npm install @cerebral/router`\n\n## Description\nThe router of Cerebral does not affect your view layer. A url change triggers a signal that puts your application in the correct state. Your view just reacts to this state, like any other state change.\n\nRead more about the router in the [Cerebral in depth - Routing](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_routing) article.\n\n## Instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from '@cerebral/router'\n\nconst controller = Controller({\n  modules: {\n    router: Router({\n      // Define routes and point to signals\n      routes: [{\n        path: '/',\n        signal: 'app.homeRouted'\n      }]\n\n      // Only react to hash urls\n      onlyHash: false,\n\n      // Set a base url, if your app lives on a subpath\n      baseUrl: null,\n\n      // Will allow none matching routes on same origin to run as normal\n      allowEscape: false,\n\n      // Will make the router not run the initial route\n      preventAutostart: false\n    })\n  }\n})\n```\n\n## getOrigin\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000/items?foo=bar\", returns \"http://localhost:3000\"\n  router.getOrigin()\n}\n```\n\n## getPath\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000/items?foo=bar\", returns \"/items\"\n  router.getPath()\n}\n```\n\n## getSignalUrl\nAllows you to convert a signal to its corresponding url. This is useful when you actually want to produce the url for a hyperlink etc. To do this you need to create the router in its own file:\n\n*router.js*\n```js\nimport Router from '@cerebral/router'\n\nexport default Router({\n  routes: [{\n    path: '/items/:itemKey',\n    signal: 'items.itemRouted'\n  }]\n})\n```\n\nAnd attaching it to the controller:\n\n*controller.js*\n```js\nimport {Controller} from 'cerebral'\nimport router from './modules/router'\nimport items from './modules/items'\n\nexport default Controller({\n  modules: {items, router}\n})\n```\n\nYou will be able to use the same router instance to produce url based on registered signals:\n\n```js\nimport router from './router'\n\nexport default connect({\n  item: state`items.list.${props`itemKey`}`,\n},\n  function ListItem ({itemKey, item, itemRouted}) {\n    return (\n      <li key={itemKey}>\n        <a href={router.getSignalUrl('items.itemRouted', {itemKey})}>{item.name}</a>\n      </li>\n    )\n  }\n)\n```\n\n## getUrl\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000/items?foo=bar\", returns \"/items?foo=bar\"\n  router.getUrl()\n}\n```\n\n## getValues\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000/items/123?foo=bar\", returns \"{itemId: '123', foo: 'bar'}\"\n  router.getValues()\n}\n```\n\n## goTo\n*action*\n```js\nfunction myAction({router}) {\n  // Go to a new url\n  router.goTo('/items')\n}\n```\n\n*operator*\n```js\nimport {goTo} from '@cerebral/router/operators'\n\nexport default [\n  goTo('/items')\n]\n```\n\n*operator with dynamic URL*\n```js\nimport {state, string} from 'cerebral/tags'\nimport {goTo} from '@cerebral/router/operators'\n\nexport default [\n  goTo(string`/${state`app.currentView`}`)\n]\n```\n\n## redirect\n*action*\n```js\nfunction myAction({router}) {\n  // Go to a new url, replacing current url\n  router.redirect('/items')\n}\n```\n\n*operator*\n```js\nimport {redirect} from '@cerebral/router/operators'\n\nexport default [\n  redirect('/items')\n]\n```\n\n*operator with dynamic URL*\n```js\nimport {state, string} from 'cerebral/tags'\nimport {redirect} from '@cerebral/router/operators'\n\nexport default [\n  redirect(string`/${state`app.currentView`}`)\n]\n```\n\n## redirectToSignal\n*action*\n```js\nfunction myAction({router}) {\n  // Trigger a signal bound to router\n  router.redirectToSignal('app.itemsRouted', {foo: 'bar'})\n}\n```\n\n*operator*\n```js\nimport {redirectToSignal} from '@cerebral/router/operators'\n\nexport default [\n  redirectToSignal('app.itemsRouted', props`payload`)\n]\n```\n\n## routes\n```js\nimport {Controller} from 'cerebral'\nimport Router from '@cerebral/router'\n\nconst controller = Controller({\n  modules: {\n    router: Router({\n      routes: [\n        {\n          path: '/',\n          signal: 'app.homeRouted'\n        },\n        {\n          // Params are passed as props to the signal.\n          // Query parameters are also passed as props\n          path: '/projects/:projectId',\n          signal: 'app.projectRouted',\n        }\n      ]\n    })\n  }\n})\n```\n\nWhen a mapped signal triggers it will trigger with a payload if either **params** are defined on the route or the url has a **query**. For example */projects/123?showUser=true* will produce the following payload to the signal, available on the **props** :\n\n```js\n{\n  projectId: '123',\n  showUser: true\n}\n```\n\n## setUrl\n```js\nfunction myAction({router}) {\n  // If url is \"http://localhost:3000\", changes to \"http://localhost:3000/foo\"\n  router.setUrl('/foo')\n}\n```\n\n### EXPERIMENTAL\nWe are currently working on functionality that allows you to bind urls to your state, also allowing you to create more complex relationships between your application state and the url. This API is very likely to change, but please feel free to try it out and give us feedback.\n\n#### mapping\nThe `map` property let's you create a mapping between state and\nurl parameters. This works both ways: when you change the state,\nit sets the url from state and when the url changes, it triggers\nthe state changes.\n\nThis automatic mapping is only active if the current url\nis active. Note also that when you use state mapping, the 'signal'\nis optional.\n\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from '@cerebral/router'\n\nconst controller = Controller({\n  modules: {\n    router: Router({\n      routes: [\n        {\n          path: '/projects/:projectId',\n          map: {projectId: state`app.currentProjectId`},\n          signal: 'app.projectRouted',\n        },\n        {\n          path: '/settings/:tab',\n          // whitelist 'focus' query parameter\n          // and 'tab' url parameter\n          map: {tab: props`tab`, focus: props`focus`},\n          signal: 'app.settingsRouted',\n        }\n      ]\n    })\n  }\n})\n```\n\n\n#### computed mapping\n\nYou can use a `compute` value here to run a computed in order to prepare\nthe value passed to build the url.\n\n```js\nmap: {\n  urlKey: compute(/* ... */)\n}\n```\n\nIf you use a `compute` the router cannot map back from the url key to the\nstate and you need to define a reverse map with `rmap`:\n\n```js\nrmap: {\n  'some.state': compute(props`urlKey`, (urlKey) => /* ... */),\n  'other.state': compute(props`urlKey`, (urlKey) => /* ... */)\n}\n```\n\n```js\nimport {Controller} from 'cerebral'\nimport Router from '@cerebral/router'\nimport {props, state} from 'cerebral/tags'\n\nconst controller = Controller({\n  modules: {\n    router: Router({\n      routes: [\n        {\n          path: '/settings/:tab',\n          // This maps a complex app state to the `opts` param in\n          // url query.\n          map: {\n            opts: compute(\n              state`projectId`,\n              state`user.lang`,\n              (projectId, lang) => ({projectId, lang})\n            )\n          },\n          // This parses the url query `opts` into two state values.\n          // It does a 'reverse map' hence the 'rmap' name.\n          rmap: {\n            'projectId': compute(\n              state`projectId`,\n              props`opts`,\n              (projectId, opts) => opts.projectId || projectId\n            ),\n            'user.lang': compute(\n              state`validLangs`,\n              props`opts`,\n              (validLangs, opts) => (\n                validLangs[opts.lang] ? opts.lang : 'en'\n              )\n            )\n          }\n        }\n      ],\n      query: true\n    })\n  }\n})\n```\n","title":"@cerebral/router"},"useragent":{"raw":"# @cerebral/useragent\n\n## Install\n\n**NPM**\n\n`npm install @cerebral/useragent`\n\n## Description\nThe useragent module puts information about the browser into your state tree, and it also updates this information when this information changes.\n\n- UA parser: browser and device\n- Window: size & orientation\n- Media queries\n- Feature detection\n- Internet connectivity\n\n## Instantiate\n\n```js\nimport {Controller} from 'cerebral'\nimport Useragent from '@cerebral/useragent'\n\nconst controller = Controller({\n  modules: {\n    useragent: Useragent({\n      // Use CSS media queries to determine\n      // custom sizes available in your model.\n      // They will be toggle between true/false in your\n      // model\n      media: {\n        small: '(min-width: 600px)',\n        medium: '(min-width: 1024px)',\n        large: '(min-width: 1440px)',\n        portrait: '(orientation: portrait)'\n      },\n\n      // store all feature tests in model\n      feature: true,\n\n      parse: {\n        // parse useragent.browser from ua string\n        browser: true,\n        // parse useragent.device from ua string\n        device: true\n      },\n\n      // check the docs at: https://github.com/HubSpot/offline#advanced\n      offline: {\n        checkOnLoad: false,\n        interceptRequests: true,\n        reconnect: {\n          initialDelay: 3,\n          delay: 1.5\n        },\n        requests: false\n      },\n\n      // update window size on resize\n      window: true\n    })\n  }\n})\n```\n","title":"@cerebral/useragent"}},"resources":{"index":{"raw":"# Cerebral in depth\n- [Routing](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_routing)\n- [Operators](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_operators)\n- [Server Side Rendering](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_ssr)\n- [Http](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_http)\n- [Composing](https://www.jsblog.io/articles/christianalfoni/cerebral_in_depth_composing)\n","title":"Cerebral in depth"},"boilerplates":{"raw":"# Boilerplates\n\n## create-react-app\n\nFacebook released a boilerplating tool for React, called [create-react-app](https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html). As a beginner it can be a good idea to create a project with create-react-app first and install Cerebral as instructed in [Install Cerebral](/docs/introduction/install.html).\n\n## saitodisse/cerebral2-boilerplates\n\nVarious scripts that uses [create-react-app](https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html), yarn and some shell script to start a cerebral project based on cerebral's official examples: tutorial, demo, forms-demo and todomvc. (_tested on Linux, may work on Mac_)\n","title":"Boilerplates"},"migration":{"raw":"# Migration\n\nWhen migrating from 1.x to 2.x you need to take the following under consideration.\n\n- There are no models left to choose from. Cerebral now comes with one model.\n- Services have been removed in favor of function-tree/providers.\n\n## Controller\nInstead of choosing your model and connecting to the *Controller* as in 1.x as shown below\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nconst controller = Controller(Model({\n  // You can add some initial state here if you want\n}))\n\nexport default controller\n```\n\nYou would simply do the following in 2.x\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  state: {\n    // You can add some initial state here if you want\n  }\n})\n\nexport default controller\n```\n\n**controller.getSignals()** is removed from 2.x so favor **controller.getSignal('some.signal')** instead.\n\n## Modules\nIn 1.x you would have done something like this\n\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral/models/immutable'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  home: Home,\n  admin: Admin\n})\n\nexport default controller\n```\n\nIn 2.x the modules are defined along with the controller\n\n```js\nimport {Controller} from 'cerebral'\n\nimport Home from './modules/Home'\nimport Admin from './modules/Admin'\n\nconst controller = Controller({\n  modules: {\n    home: Home(),\n    admin: Admin()\n  }\n})\n\nexport default controller\n```\n\nSub-modules can be defined by each module in the same way (see below).\n\nIn 1.x you would create your own module like this\n\n```js\n// 1.x\nexport default module => {\n  module.addState({\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  })\n\n  module.addSignals({\n    newItemTitleSubmitted: submitNewItemTitle\n  })\n}\n```\n\naddState, addSignals have been removed, so in 2.x you simply return an object\n\n```js\n// 2.x\nexport default {\n  state: {\n    items: [],\n    newItemTitle: '',\n    isSaving: false,\n    error: null\n  },\n  modules: {\n    subModule: SubModule()\n  },\n  signals: {\n    newItemTitleSubmitted: submitNewItemTitle\n  }\n}\n```\n\n## Operators\nThe biggest change to Cerebral 2.x is the operators. You can read more about them in the Operators docs. They have become very powerful and you can create your own operators. Operators in Cerebral 2.x has been moved into core Cerebral. You can still use the old operators if you want by installing them via npm.\n\n```js\nnpm install cerebral-operators\n```\n\nThe new operators now use tagged template literals and you can reduce number of actions and instead use the new operators. Here is a quick sample. As you can see you import them from 'cerebral/operators'\n\n```js\nimport {set} from 'cerebral/operators'\nimport {state, props} from 'cerebral/tags'\n\nexport default [\n  set(state`foo.bar`, props`bar`)\n]\n```\n\nOther operators include: wait, when, equals, debounce, push, pop, shift, toggle, unset, splice\n\n## Signals\nYou handle signals mostly the same way as in 1.x. You can describe signals in a module or in the controller directly.\n\n### 1.x\n```js\nimport {Controller} from 'cerebral'\nimport Model from 'cerebral-model-immutable'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller(Model({}))\n\ncontroller.addSignals({\n  buttonClicked: doSomething,\n  fieldChanged: { immediate: true, chain: updateField }\n})\n```\n### 2.x\n```js\nimport {Controller} from 'cerebral'\nimport doSomething from './chains/doSomething'\nimport updateField from './chains/updateField'\n\nconst controller = Controller({\n  signals: {\n    buttonClicked: doSomething,\n    fieldChanged: updateField\n  }\n})\n```\n\nOne note when using signals is that the **immediate** option is gone. This keeps the api cleaner.\n\n## Actions\nSince cerebral 2.x is using **function-tree** under the hood we have other, more powerful options than before. The state is the same, but output is gone and input is renamed to props. You can just return an object from the action that will be available in the props for the next action. You can also return a **path** that is a new concept in Cerebral 2.x and outdates output. **path** is used to determine the execution path for your chain. You do no longer have services as an argument in the context, use providers instead.\n\n### 1.x\n```js\nfunction myAction({props, state, output, services}) {\n\n}\n```\n\nIn 2.x you have the following. Instead of services you hook up providers that supersedes services.\n\n```js\nfunction myAction({props, state, path /*, myProvider, otherProvider */ }) {\n\n}\n```\n\nWhen you wanted to output to paths in 1.x you would do something like this\n```js\nfunction myAction({state, output}) {\n  if (state.get('app.isAwesome')) {\n    output.awesome()\n  } else {\n    output.notSoAwesome()\n  }\n}\nmyAction.outputs = ['awesome', 'notSoAwesome']\n```\n\nWith the new **path** concept this is simpler. In 2.x you would just do what is stated below. Please note the **return path...**. The same is true with promises. They need to be returned.\n\n```js\nfunction myAction({state, path}) {\n  if (state.get('app.isAwesome')) {\n    return path.awesome()\n  } else {\n    return path.notSoAwesome()\n  }\n}\n```\n\nIf you don't want to take another path in the execution tree you could return a new object that would be available in the props object.\n\n```js\nfunction myAction({state, path}) {\n  return {\n    someData: 'Some new data available at output.someData'\n  }\n}\n```\n\nWhen doing async operations you would do something like this in 1.x\n\n```js\nfunction myAction({output}) {\n  setTimeout(() => {\n    output({ /* optional output */ }) // or output.pathName({ /* optional output */ })\n  }, 1000)\n}\n\nmyAction.async = true\n```\n\nIn Cerebral 2 you you must resolve or reject a returned promise.\n\n```js\nfunction myAction({path}) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({ /* optional output */ }) // or resolve(path.pathName({ /* optional output */ }))\n    }, 1000)\n  })\n}\n```\n\nIn 1.x you could set a path that wasn't defined yet in the state tree. Let's say your state looked like this.\n\n```js\n{\n  app: {\n    nodes: {}\n  }\n}\n```\n\nYou could do this in an action.\n\n```js\nfunction myAction({state}) {\n  state.set('app.nodes.some.state.more', {updated: true})\n}\n```\n\nWith 2.x this is no longer possible. It's easy to mistype paths and therefore this option is no longer available. Your paths need to be in place before setting values to them.\n\nWhen using computed data in an action you could call **state.computed(myComputed())** in the action. This has changed in 2.x in favor of\n**state.compute(myComputed)**. You can also pass props to the compute function.\n\n```js\nfunction myAction({state}) {\n  state.compute(someComputed)\n  state.compute(someComputed.props({foo: 'bar'}))\n}\n```\n\nThis works the same in context for 2.x\n\n```js\nconnect({\n  foo: someComputed,\n  foo2: someComputedFactory({foo: 'bar'})\n})\n```\n\n## Providers (outdates services)\n\nIn 1.x you could add services that would be available to you in the actions. Typically, you would do something like this in 1.x\n\n```js\nimport someExternalApi from 'some-external-api'\n\nexport default (options = {}) => module => {\n\n  if (!options.apiKey) {\n    throw new Error('This service needs an apiKey')\n  }\n\n  module.addServices({\n    connect() {\n      return someExternalApi.connect({\n        apiKey: options.apiKey\n      })\n    }\n  })\n\n}\n```\n\nIn 2.x you would use providers instead.\n\n```js\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  providers: [\n    ContextProvider({\n      axios\n    })\n  ]\n})\n```\n\nor manually\n\n```js\nimport {Controller} from 'cerebral'\n\nconst controller = Controller({\n  provider(context) {\n    context.myProvider = {\n      doSomething() {}\n    }\n    return context\n  }\n})\n```\n\nNow instead of having services in the context object in an action you would have the **axios** object.\n\n```js\nfunction myAction({axios}) {\n\n}\n```\n\n## Views\nHow you import view specific packages has changed. In 1.x you would import Container like this.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral-view-react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x you would not import the Container from another package.\n\n```js\nimport controller from './controller.js'\nimport React from 'react'\nimport {render} from 'react-dom'\nimport {Container} from 'cerebral/react'\n\n// Your main application component\nimport App from './components/App'\n\nrender(\n  <Container controller={controller}>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nThe same is true when connecting Cerebral to your component. In 1.x you would import it like this.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral-view-react'\n\nexport default connect({\n  isLoading: 'app.isLoading'\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 2.x you would have to use a different import.\n\n```js\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {state} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`\n},\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIn 1.x you would first connect state, then signals as separate arguments in connect. In Cerebral 2.x these are combined, tags are used to differentiate between state, signals and props.\n\n```js\n// 2.x\nimport React from 'react'\nimport {connect} from 'cerebral/react'\nimport {props, state, signal} from 'cerebral/tags'\n\nexport default connect({\n  isLoading: state`app.isLoading`,\n  item: state`items.${props`itemId`}`,\n  someSignal: signal`app.someSignal`\n}.\n  function App(props) {\n    return (\n      <div>\n        {props.isLoading ? 'loading...' : null}\n      </div>\n    )\n  }\n)\n```\n\nIf you really want all signals in props as in 1.x you can set this as an option in the controller.\n\n```js\n// 2.x\nimport {Controller} from 'cerebral'\nimport ContextProvider from 'cerebral/providers/context'\nimport axios from 'axios'\n\nconst controller = Controller({\n  options: {\n     signalsProp: true\n   }\n})\n```\n\n\n##  Model\nThe following functions have been removed from Cerebral 2.x when using state inside an action\n\n- logModel\n- export\n- findWhere\n- keys\n- import\n- toJs\n- toJson\n\n## Strict render mode\nTo setup strict render mode in 1.x for React was specified as follows.\n\n```js\nrender(\n  <Container controller={controller} strict>\n    <App/>\n  </Container>\n, document.querySelector('#app'))\n```\n\nIn 2.x this is the only mode\n\n## Devtools\nThe devtools has changed as well. Go to chrome store and install cerebral2 debugger. The setup has slightly changed from 1.x to 2.x as well as the import.\n\n### 1.x\n```js\nimport Controller from 'cerebral'\nimport Model from 'cerebral/model/immutable'\nimport Devtools from 'cerebral-module-devtools'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools()\n})\n\nexport default controller\n```\n\n### 2.x\n```js\nimport Controller from 'cerebral'\nimport Devtools from 'cerebral/devtools'\n\nconst controller = Controller({\n  devtools: process.env.NODE_ENV === 'production' ? () => {} : Devtools(),\n  modules: {\n    ...\n  }\n})\n\nexport default controller\n```\n\n## Router\nThe router now defines its routes with an array\n\n### 1.x\n```js\nimport Controller from 'cerebral'\nimport Model from 'cerebral/model/immutable'\nimport Router from 'cerebral-module-router'\n\nconst controller = Controller(Model({}))\n\ncontroller.addModules({\n  modules: {\n    router: Router({\n      routes: {\n        '/': 'appRouted'\n      }\n    })\n  }\n})\n\nexport default controller\n```\n\n### 2.x\n```js\nimport Controller from 'cerebral'\nimport Router from '@cerebral/router'\n\nconst controller = Controller({\n  modules: {\n    router: Router({\n      routes: [{\n        path: '/',\n        signal: 'appRouted'\n      }]\n    })\n  }\n})\n\nexport default controller\n```\n","title":"Migration"},"articles":{"raw":"# Articles\n- [Function-Tree](http://www.christianalfoni.com/articles/2017_04_16_The-second-case-for-function-tree)\n- [Cerebral 2](http://www.christianalfoni.com/articles/2017_03_19_Cerebral-2)\n- [The story of Cerebral](http://medium.com/p/5793c08db2cc)\n- [An unlikely success story](https://gist.github.com/christianalfoni/b08a99faa09df054afe87528a2134730)\n- [CerebralJS - Gentle introduction](https://dev.to/reflog/cerebraljs)","title":"Articles"},"videos":{"raw":"# Videos\n- [Ducky architecture](https://youtu.be/uXlxNJfGKjU?t=4m19s)\n- [Fingerprint analysis](https://youtu.be/iKkGg8UR514?t=58m41s)\n- [Car dealer provision system](https://youtu.be/iKkGg8UR514?t=1m37s)\n","title":"Videos"},"projects":{"raw":"# Cerebral projects\n- [Webpackbin](https://www.webpackbin.com). A bin service using Webpack ([Source Code](https://github.com/cerebral/webpackbin)).\n- [Unity connect](https://connect.unity.com/). The Unity social platform\n- [Projects overview](https://github.com/cerebral/cerebral/issues/713). A github issue with multiple projects (images)\n- [rehace](https://www.npmjs.com/package/rehace-github-magnolia). A CMS component/controller library\n","title":"Cerebral projects"}}}